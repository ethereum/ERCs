---
eip: 7757
title: Instinct-Based Automatic Transactions
description: AI-driven transactions with on-chain instincts, temptation values, and environment variables for agent autonomy.
author: James Savechives (@jamesavechives) <james.walstonn@gmail.com>
discussions-to: https://ethereum-magicians.org/t/erc-7751-instinct-based-automatic-transactions/20886
status: Draft
type: Standards Track
category: ERC
created: 2024-08-19
---

## Abstract

This ERC proposes a standard for enabling AI-driven automatic transactions on the Ethereum blockchain, where the blockchain serves as a repository of shared **instincts**—common rules and guidelines that direct AI agents in their off-chain computations and actions. Given that AI and machine learning require substantial computational resources and are typically executed off-chain, this standard allows the blockchain to provide a decentralized, immutable framework of instincts that AI agents from different providers can access and follow.

Each instinct is associated with a **temptation value**, a numerical metric (positive for rewards, negative for penalties) that incentivizes AI agents to pursue certain actions. Instincts represent final goals that agents strive to achieve, while **mid-way targets** are intermediate steps generated on-chain to guide agents toward these goals. Both instincts and mid-way targets are evaluated based on their temptation values, enabling AI agents to prioritize actions by weighing potential rewards against associated costs.

Additionally, this ERC highlights the **importance of on-chain environment variables** that agents can both read and modify. These environment variables may include balances, ownership records, or any other agent-specific statuses, forming a decentralized “memory” that persists for all participants. By updating these environment variables on-chain, agents maintain a shared, trust-minimized state that fosters collaboration and transparency.

AI agents differ from simple Large Language Models (LLMs) in that they are not strictly driven by user prompts; instead, they rely on **instincts** and **environmental cues** to make autonomous decisions, sense the blockchain’s state, and update that state as needed to achieve their goals. When the trigger conditions for an instinct or mid-way target are met—either through on-chain events or verified off-chain computations—the blockchain automatically executes the associated transactions without requiring AI agents to manage private keys.

This system addresses key challenges in integrating AI with blockchain technology:

- **Common Rules for AI Agents**: By storing instincts and environment variables on the blockchain, AI agents from different providers operate under a unified set of rules, promoting interoperability and fairness.
- **Security and Efficiency**: Automatic execution of transactions eliminates the need for AI agents to handle private keys, enhancing security and reducing the potential for human error.
- **Adaptability**: The use of dynamic instincts and mid-way targets allows the system to adapt to changing conditions, ensuring that AI agents can respond effectively to real-world events while operating off-chain.
- **Shared On-Chain State**: Agents can create or modify environment variables on-chain (like agent balances, ownership, or other statuses), enabling a decentralized “memory” that multiple agents can access and rely on.

By providing a decentralized, secure, and adaptive framework of instincts and environment variables, this ERC enables the creation of a self-regulating, collaborative ecosystem where AI agents can make autonomous decisions guided by shared principles stored on the blockchain.

## Motivation

As the field of artificial intelligence (AI) evolves, autonomous systems increasingly require decentralized, common rules to ensure fairness, security, and cooperation among different agents. Moreover, while Large Language Models (LLMs) typically respond directly to user prompts, **autonomous agents** go further: they continually sense and update the environment to meet their ultimate goals, often without explicit user prompting at each step. 

This ERC addresses the need for a framework that allows the blockchain to store and enforce **instincts**—guidelines that direct AI agents operating off-chain to achieve specific goals—and maintain **environment variables** that represent the agent’s state or status in a decentralized, tamper-proof form. Given that AI computations demand significant resources and are typically executed off-chain, the blockchain's role is to provide a transparent, tamper-proof structure of shared rules and data to ensure consistent and secure behavior across diverse agents.

### Key Concepts:

1. **Off-Chain AI Processing**:  
   AI agents handle computation-intensive tasks off-chain, but they rely on **instincts** stored on-chain to guide their decisions. The blockchain doesn't handle the heavy computation but rather provides the rules and environment variables under which AI agents operate.

2. **Instincts as Shared Rules**:  
   Instincts are the core concept, representing predefined or dynamic goals AI agents follow. These instincts ensure interoperability between AI agents from different providers, allowing them to operate under a unified set of rules. The blockchain acts as the central repository of these instincts, offering an immutable, decentralized system for rule enforcement.

3. **Mid-Way Targets and Automatic Execution**:  
   Blockchain-generated **mid-way targets**—smaller tasks AI agents must complete to achieve a final instinct—help break down complex goals into manageable actions. When conditions for these targets are met, the blockchain automatically executes the corresponding transactions, ensuring efficiency and transparency without requiring agents to handle private keys.

4. **On-Chain Environment Variables**:  
   To facilitate autonomous behavior, agents must sense and modify environmental data—like agent balances, ownership details, or internal “memory” states. This standard enables agents to read these environment variables from the blockchain and update them via transactions, ensuring a shared, consistent view of the agent’s status or the broader environment. By decentralizing environment variables, multiple agents can collaboratively or independently act on the same data, thus enabling robust multi-agent systems.

### Use Cases:

1. **Automated Financial Trading**:  
   In decentralized finance (DeFi), AI agents use blockchain-stored instincts and environment variables (e.g., price feeds or agent balances) to optimize trading strategies. For example, instincts could instruct an agent to buy assets when their price drops by 5% or sell when prices increase by 10%. Mid-way targets break down these strategies into smaller steps; the blockchain ensures these trades are executed automatically and securely.

2. **Supply Chain Optimization**:  
   AI agents in logistics can rely on instincts stored on the blockchain, as well as environment variables tracking shipment ownership or location. For instance, instincts may direct an agent to reduce delivery times, while mid-way targets specify route optimizations. Agents update environment variables on-chain with real-time status changes (e.g., shipment arrived) that other agents can read and act upon.

3. **Energy Grid Management**:  
   In decentralized energy markets, AI agents could be tasked with minimizing energy costs. The blockchain stores instincts (like “switch to renewables at certain price points”) and environment variables (grid capacity, usage data) to guide agent decisions. When conditions are met, the system automatically executes purchases or redistributions.

4. **Maximizing Account Balance**:  
   AI agents might have instincts to maximize an account balance while taking environment variables—like current token prices—into account. The blockchain provides a secure environment for evaluating and executing the most efficient decisions, and the agent can update environment variables (e.g., its own status or holdings) to reflect new balances.

5. **Gaming and Virtual Environments**:  
   In blockchain-based games, instincts and environment variables stored on-chain guide AI agents in completing quests or winning battles. Mid-way targets such as “collect resources” or “defeat enemies” are stored on the blockchain. The system automatically executes in-game actions and updates environment variables (inventory, levels, etc.) when conditions are met, enhancing transparency and multi-agent interactions.

### Problem Solved

By offloading computationally intensive tasks off-chain but anchoring the **instincts** and **environment variables** on-chain, this ERC provides a transparent, immutable system for rule enforcement and data sharing. AI agents, operating autonomously, can sense and modify these environment variables to reflect their changing states or “memories,” making them accessible to all participants in a decentralized fashion. This approach ensures:

- **Interoperability**: Agents from multiple providers can rely on the same shared data and instincts.  
- **Security and Consistency**: A trust-minimized environment where updates to agent status or environment variables are immediately visible and auditable.  
- **Scalability**: Heavy computations remain off-chain, while the blockchain focuses on secure storage of rules, triggers, and environment data.

## Specification

### Solidity Interface

The following Solidity interface outlines the core functions, events, and data structures required for the **Instinct-Based Automatic Transactions** ERC. This interface serves as a contract that implementations must adhere to, ensuring consistency and interoperability across different implementations.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title ERC-7757 Instinct-Based Automatic Transactions Interface
/// @notice Interface for managing instincts and facilitating AI-driven automatic transactions
interface IERC7757Instincts {

    /// @notice Emitted when a new instinct is created
    event InstinctCreated(
        bytes32 indexed instinctID,
        int256 temptationValue,
        string triggerConditions,
        bool isStatic,
        bool autoExecution
    );

    /// @notice Emitted when an instinct is modified
    event InstinctModified(
        bytes32 indexed instinctID,
        int256 newTemptationValue,
        string newTriggerConditions
    );

    /// @notice Emitted when an instinct is deleted
    event InstinctDeleted(bytes32 indexed instinctID);

    /// @notice Emitted when an AI agent evaluates instincts
    event InstinctsEvaluated(address indexed agent, bytes32[] instinctsEvaluated);

    /// @notice Emitted when an AI agent acts on an instinct
    event ActOnInstinct(address indexed agent, bytes32 indexed instinctID, bool success);

    /// @notice Emitted when an instinct is labeled with a cost by an AI agent
    event InstinctLabeled(bytes32 indexed instinctID, int256 cost);

    /// @notice Emitted when an instinct is updated dynamically
    event InstinctUpdated(bytes32 indexed instinctID, int256 updatedTemptationValue);

    /// @notice Struct representing an instinct
    struct Instinct {
        bytes32 instinctID;
        int256 temptationValue;
        string triggerConditions;
        bool isStatic;
        bool autoExecution;
        bool exists;
    }

    /// @notice Creates a new instinct
    /// @param instinctID Unique identifier for the instinct
    /// @param temptationValue Numerical metric indicating reward (positive) or penalty (negative)
    /// @param triggerConditions Conditions under which the instinct is triggered
    /// @param isStatic Indicates if the instinct is immutable
    /// @param autoExecution Determines if the transaction executes automatically upon triggering
    function createInstinct(
        bytes32 instinctID,
        int256 temptationValue,
        string calldata triggerConditions,
        bool isStatic,
        bool autoExecution
    ) external;

    /// @notice Modifies an existing instinct
    /// @param instinctID Unique identifier for the instinct to modify
    /// @param newTemptationValue Updated temptation value
    /// @param newTriggerConditions Updated trigger conditions
    function modifyInstinct(
        bytes32 instinctID,
        int256 newTemptationValue,
        string calldata newTriggerConditions
    ) external;

    /// @notice Deletes an existing instinct
    /// @param instinctID Unique identifier for the instinct to delete
    function deleteInstinct(bytes32 instinctID) external;

    /// @notice Evaluates instincts for a given AI agent within a specified timeframe
    /// @param agent Address of the AI agent
    /// @param timeFrame Timeframe for evaluation (e.g., block number or timestamp)
    /// @return instinctsEvaluated Array of instinct IDs evaluated
    function evaluateInstincts(address agent, uint256 timeFrame) external returns (bytes32[] memory instinctsEvaluated);

    /// @notice AI agent acts on a selected instinct
    /// @param instinctID Unique identifier for the instinct to act upon
    /// @param agent Address of the AI agent
    /// @return success Indicates if the action was successfully executed
    function actOnInstinct(bytes32 instinctID, address agent) external returns (bool success);

    /// @notice Labels an instinct with the incurred cost by an AI agent
    /// @param instinctID Unique identifier for the instinct
    /// @param cost Cost incurred during the pursuit of the instinct
    function labelInstinct(bytes32 instinctID, int256 cost) external;

    /// @notice Updates the temptation value of an instinct dynamically
    /// @param instinctID Unique identifier for the instinct
    /// @param newTemptationValue Updated temptation value based on external conditions
    function updateInstinct(bytes32 instinctID, int256 newTemptationValue) external;

    /// @notice Retrieves the details of a specific instinct
    /// @param instinctID Unique identifier for the instinct
    /// @return Instinct struct containing instinct details
    function getInstinct(bytes32 instinctID) external view returns (Instinct memory);

    /// @notice Retrieves all existing instincts
    /// @return instincts Array of all Instinct structs
    function getAllInstincts() external view returns (Instinct[] memory);
}
```

### Detailed Behavior Descriptions

#### 1. Instinct Creation and Management

- **`createInstinct`**
  - **Access Control**: Only authorized accounts (e.g., contract owner or designated administrators) can create new instincts.
  - **Behavior**:
    - Validates that the `instinctID` is unique and does not already exist.
    - Stores the new instinct with all provided attributes on-chain.
    - Emits the `InstinctCreated` event upon successful creation.
    - Reverts if the `instinctID` already exists or if any parameters are invalid.

- **`modifyInstinct`**
  - **Access Control**: Only authorized accounts can modify existing instincts. Additionally, static instincts (`isStatic = true`) cannot be modified.
  - **Behavior**:
    - Checks if the instinct exists and is not static.
    - Updates the `temptationValue` and `triggerConditions` of the specified instinct.
    - Emits the `InstinctModified` event upon successful modification.
    - Reverts if the instinct does not exist, is static, or if parameters are invalid.

- **`deleteInstinct`**
  - **Access Control**: Only authorized accounts can delete instincts.
  - **Behavior**:
    - Verifies the existence of the instinct.
    - Removes the instinct from the storage.
    - Emits the `InstinctDeleted` event upon successful deletion.
    - Reverts if the instinct does not exist.

- **`updateInstinct`**
  - **Access Control**: Only authorized accounts or approved oracles can dynamically update instincts.
  - **Behavior**:
    - Validates the existence of the instinct.
    - Updates the `temptationValue` based on external conditions or predefined rules.
    - Emits the `InstinctUpdated` event upon successful update.
    - Reverts if the instinct does not exist or if parameters are invalid.

#### 2. AI-Agent Interaction

- **`evaluateInstincts`**
  - **Access Control**: Open to any AI agent address.
  - **Behavior**:
    - Retrieves all instincts relevant to the AI agent within the specified `timeFrame`.
    - Filters instincts based on `triggerConditions` and current blockchain state.
    - Returns an array of `instinctID`s that the agent should consider acting upon.
    - Emits the `InstinctsEvaluated` event with the list of evaluated instincts.

- **`actOnInstinct`**
  - **Access Control**: Only the AI agent associated with the `agent` address can act on instincts designated for it.
  - **Behavior**:
    - Validates that the `instinctID` exists and that the `agent` is authorized to act on it.
    - Verifies the `triggerConditions` are met either through on-chain data or trusted oracles.
    - If `autoExecution` is `true`, executes the associated transaction automatically.
    - Transfers rewards or applies penalties based on the outcome.
    - Emits the `ActOnInstinct` event indicating success or failure.
    - Reverts if validations fail or if execution conditions are not met.

- **`labelInstinct`**
  - **Access Control**: Only the AI agent associated with the `agent` address can label instincts it has acted upon.
  - **Behavior**:
    - Records the `cost` incurred by the agent for pursuing the specified `instinctID`.
    - Stores the cost data for future reference and collective learning.
    - Emits the `InstinctLabeled` event with the cost information.
    - Reverts if the `instinctID` does not exist or if the caller is unauthorized.

#### 3. Learning and Strategy Update

- **`updateStrategy`** (Off-Chain Functionality)
  - **Behavior**:
    - AI agents periodically retrieve labeled cost data from the blockchain.
    - Based on the historical costs and rewards, agents adjust their decision-making algorithms to optimize future actions.
    - This function is implemented off-chain and interacts with the smart contract via read operations.

#### 4. Retrieval Functions

- **`getInstinct`**
  - **Behavior**:
    - Returns the details of the specified `instinctID`.
    - Reverts if the instinct does not exist.

- **`getAllInstincts`**
  - **Behavior**:
    - Returns an array of all instincts stored on the blockchain.
    - Useful for AI agents to retrieve the complete set of rules and guidelines.

### Implementation Guidelines

To ensure consistency and security across different implementations, the following guidelines should be followed:

1. **Access Control**: Implement robust access control mechanisms using modifiers such as `onlyOwner` or role-based access (e.g., using OpenZeppelin's `AccessControl`) to restrict who can create, modify, or delete instincts.  
2. **Data Validation**: Ensure all input parameters are validated to prevent erroneous data from being stored. For example, check that `temptationValue` is within acceptable bounds and that `triggerConditions` are well-formed.  
3. **Event Emission**: Emit appropriate events for all state-changing operations to facilitate off-chain monitoring and indexing by AI agents and other stakeholders.  
4. **Gas Optimization**: Optimize storage and function logic to minimize gas costs, especially for functions that may be called frequently by multiple AI agents.  
5. **Security Audits**: Conduct thorough security audits to identify and mitigate potential vulnerabilities, such as reentrancy attacks or unauthorized access.

### Example Implementation

Below is a simplified example of how the interface can be implemented in a Solidity contract. This example uses OpenZeppelin's `AccessControl` for role management and includes basic functionalities as defined in the interface.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IERC7757Instincts.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract InstinctsManager is IERC7757Instincts, AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    // Mapping from instinctID to Instinct
    mapping(bytes32 => Instinct) private instincts;

    // Modifier to check if instinct exists
    modifier instinctExists(bytes32 instinctID) {
        require(instincts[instinctID].exists, "Instinct does not exist");
        _;
    }

    constructor() {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ADMIN_ROLE, msg.sender);
    }

    /// @notice Creates a new instinct
    function createInstinct(
        bytes32 instinctID,
        int256 temptationValue,
        string calldata triggerConditions,
        bool isStatic,
        bool autoExecution
    ) external override onlyRole(ADMIN_ROLE) {
        require(!instincts[instinctID].exists, "Instinct ID already exists");

        instincts[instinctID] = Instinct({
            instinctID: instinctID,
            temptationValue: temptationValue,
            triggerConditions: triggerConditions,
            isStatic: isStatic,
            autoExecution: autoExecution,
            exists: true
        });

        emit InstinctCreated(instinctID, temptationValue, triggerConditions, isStatic, autoExecution);
    }

    /// @notice Modifies an existing instinct
    function modifyInstinct(
        bytes32 instinctID,
        int256 newTemptationValue,
        string calldata newTriggerConditions
    ) external override onlyRole(ADMIN_ROLE) instinctExists(instinctID) {
        Instinct storage instinct = instincts[instinctID];
        require(!instinct.isStatic, "Cannot modify a static instinct");

        instinct.temptationValue = newTemptationValue;
        instinct.triggerConditions = newTriggerConditions;

        emit InstinctModified(instinctID, newTemptationValue, newTriggerConditions);
    }

    /// @notice Deletes an existing instinct
    function deleteInstinct(bytes32 instinctID) external override onlyRole(ADMIN_ROLE) instinctExists(instinctID) {
        delete instincts[instinctID];
        emit InstinctDeleted(instinctID);
    }

    /// @notice Evaluates instincts for an AI agent
    function evaluateInstincts(address agent, uint256 timeFrame) external override returns (bytes32[] memory instinctsEvaluated) {
        // Simplified evaluation logic (to be expanded based on trigger conditions)
        // WARNING: This is a placeholder and not suitable for production due to potential gas issues
        uint256 count = 0;
        uint256 maxInstincts = 10; // Example limit to prevent infinite loops
        instinctsEvaluated = new bytes32[](maxInstincts);
        for (bytes32 id = 0; id < bytes32(type(uint256).max); id++) {
            if (instincts[id].exists) {
                instinctsEvaluated[count] = id;
                count++;
                // Break condition to prevent infinite loop in example
                if (count >= maxInstincts) break;
            }
        }

        emit InstinctsEvaluated(agent, instinctsEvaluated);
        return instinctsEvaluated;
    }

    /// @notice AI agent acts on a selected instinct
    function actOnInstinct(bytes32 instinctID, address agent) external override instinctExists(instinctID) returns (bool success) {
        // Simplified action logic
        Instinct memory instinct = instincts[instinctID];
        require(instinct.autoExecution, "Auto execution not enabled for this instinct");

        // Implement actual transaction logic here (e.g., transferring tokens)
        // This is a placeholder for demonstration purposes

        emit ActOnInstinct(agent, instinctID, true);
        return true;
    }

    /// @notice Labels an instinct with the incurred cost by an AI agent
    function labelInstinct(bytes32 instinctID, int256 cost) external override instinctExists(instinctID) {
        // Implement cost labeling logic (e.g., storing costs per agent)
        // This is a placeholder for demonstration purposes

        emit InstinctLabeled(instinctID, cost);
    }

    /// @notice Updates the temptation value of an instinct dynamically
    function updateInstinct(bytes32 instinctID, int256 newTemptationValue) external override onlyRole(ADMIN_ROLE) instinctExists(instinctID) {
        instincts[instinctID].temptationValue = newTemptationValue;
        emit InstinctUpdated(instinctID, newTemptationValue);
    }

    /// @notice Retrieves the details of a specific instinct
    function getInstinct(bytes32 instinctID) external view override instinctExists(instinctID) returns (Instinct memory) {
        return instincts[instinctID];
    }

    /// @notice Retrieves all existing instincts
    function getAllInstincts() external view override returns (Instinct[] memory) {
        // WARNING: This is a placeholder and not suitable for production due to potential gas issues
        uint256 total = 0;
        uint256 maxInstincts = 10; // Example limit
        for (bytes32 id = 0; id < bytes32(type(uint256).max); id++) {
            if (instincts[id].exists) {
                total++;
            }
            // Break condition to prevent infinite loop in example
            if (id == bytes32(uint256(10))) break;
        }

        Instinct[] memory allInstincts = new Instinct[](total);
        uint256 index = 0;
        for (bytes32 id = 0; id < bytes32(type(uint256).max); id++) {
            if (instincts[id].exists) {
                allInstincts[index] = instincts[id];
                index++;
            }
            if (index >= total) break;
        }

        return allInstincts;
    }
}
```

## Rationale

The design decisions in this ERC are centered around creating a flexible, adaptive framework that allows AI agents operating off-chain to interact seamlessly with **blockchain-stored instincts** as well as **on-chain environment variables**. These environment variables let agents sense, record, and share status or “memory” data in a decentralized manner. The goal is to enable **autonomous decision-making** while ensuring security, efficiency, and interoperability among diverse AI systems.

1. **Blockchain as a Provider of Common Rules (Instincts) and Environment Variables**  
   - **Decision**: Utilize the blockchain both to store **instincts**—shared rules and guidelines that AI agents follow in their off-chain computations—and to hold **environment variables** that represent each agent’s or system’s on-chain state.  
   - **Rationale**: By centralizing instincts *and* environment variables on the blockchain, we ensure that all AI agents, regardless of origin or provider, operate under a unified, tamper-proof set of rules and shared data. This fosters interoperability and trust among decentralized agents that can autonomously update or reference these variables (e.g., account balances, agent ownership, or other statuses).

2. **Temptation Values for Prioritization**  
   - **Decision**: Assign temptation values (positive for rewards, negative for costs) to instincts and mid-way targets to help AI agents prioritize actions.  
   - **Rationale**: Temptation values provide a quantitative measure for AI agents to evaluate the potential benefits and costs of pursuing certain instincts. By factoring these into their decision-making, agents can weigh environment variables (like current network congestion or resource availability) against potential rewards, optimizing their choices based on real-time incentives.

3. **Mid-way Targets to Guide Progress**  
   - **Decision**: Introduce mid-way targets as intermediate steps toward achieving final instincts, each with its own temptation value and conditions.  
   - **Rationale**: Breaking down complex goals into smaller, manageable tasks allows AI agents to proceed incrementally. **Storing and updating environment variables** at each step helps agents “remember” state changes or progress markers, enabling them to continuously re-evaluate their path toward final instincts.

4. **Automatic Execution of Transactions**  
   - **Decision**: Enable the blockchain to automatically execute transactions when the trigger conditions for instincts or mid-way targets are met, without requiring AI agents to manage private keys.  
   - **Rationale**: Since AI agents operate off-chain and often cannot securely handle private keys, automatic execution ensures secure, efficient interaction with the blockchain. It also allows agents to modify or create environment variables on-chain (e.g., agent status updates, transferring tokens) once triggers are satisfied, improving system reliability and autonomy.

5. **Dynamic Instincts for Adaptability**  
   - **Decision**: Allow instincts to be dynamic, updating their temptation values and conditions based on real-time data, external factors, or changes in environment variables.  
   - **Rationale**: Dynamic instincts enable the system to remain relevant in ever-changing environments. Agents can detect, through environment variables or oracles, that conditions have shifted—such as changes in resource availability, prices, or network load—and adapt their behavior accordingly, ensuring that actions remain aligned with current realities.

6. **Learning Process for Continuous Improvement**  
   - **Decision**: Incorporate a learning mechanism where AI agents label instincts with incurred costs (or rewards) and update their decision-making strategies based on historical outcomes stored on-chain.  
   - **Rationale**: By referencing on-chain data and environment variables, agents can observe the consequences of certain strategies (e.g., excessive gas costs or an unexpectedly large payoff) and refine their approach. This collective learning fosters an ecosystem where agents progressively converge on more efficient, cost-effective instincts.

7. **Static vs. Dynamic Instincts for Flexibility**  
   - **Decision**: Provide the option to define instincts as static (immutable) or dynamic (modifiable), giving users control over how instincts evolve.  
   - **Rationale**: Some use cases might benefit from stable, unchanging instincts (e.g., regulatory compliance in a highly controlled environment), while others may need rapid updates to environment variables and triggers. Supporting both static and dynamic instincts ensures broad applicability across domains where adaptability is key.

8. **Security Through On-Chain Verification**  
   - **Decision**: Utilize the blockchain’s inherent security features to verify the outcomes of off-chain AI computations when agents act on instincts, including verifying environment variable updates.  
   - **Rationale**: By verifying results on-chain, the ecosystem ensures the integrity and correctness of actions taken by AI agents. Whether it’s a complex calculation or a simple environment variable update (e.g., “Agent X now owns Resource Y”), on-chain verification adds transparency and reduces the risk of malicious behavior or data tampering.

### Summary

The rationale behind these design choices is to create a system where the **blockchain serves as both a rule enforcer (via instincts) and a shared data layer (via environment variables)**. AI agents operating off-chain rely on these on-chain primitives to make autonomous, optimized decisions—balancing temptation values, mid-way targets, and relevant state changes. **Automatic execution** and **learning processes** further empower agents to continually improve while maintaining security and transparency. By accommodating both static and dynamic instincts, the system remains flexible, adaptable, and trustworthy across diverse applications, from financial trading bots to collaborative supply-chain agents.


## Test Cases

Below are representative test cases that demonstrate how AI agents interact with instincts, environment variables, and automated transaction execution on-chain.

### 1. Instinct Creation and Modification

- **Test Case 1.1: Creating a New Instinct**

  - **Input**: A user (or system administrator) calls 
    ```solidity
    createInstinct(
      instinctID = 0xINSTINCT1, 
      temptationValue = +10, 
      triggerConditions = "VIX > 30", 
      static = false, 
      autoExecution = true
    );
    ```
  - **Expected Output**:  
    - The new instinct is stored on-chain with the specified properties, including `triggerConditions` referencing external data (like a market volatility oracle).  
    - AI agents operating off-chain can now evaluate this instinct.  
    - Querying the instinct returns `0xINSTINCT1` with `temptationValue = +10`, `triggerConditions = "VIX > 30"`, `static = false`, `autoExecution = true`.

- **Test Case 1.2: Modifying an Existing Instinct**

  - **Input**: An authorized account calls 
    ```solidity
    modifyInstinct(
      instinctID = 0xINSTINCT1, 
      newTemptationValue = +15, 
      newTriggerConditions = "VIX > 25"
    );
    ```
  - **Expected Output**:  
    - The system updates the existing instinct `0xINSTINCT1` to have a higher temptation value and an adjusted trigger threshold.  
    - Agents are notified (via on-chain event or subsequent queries) of the new conditions and can adapt their strategies accordingly.  
    - Querying the instinct now reflects `temptationValue = +15` and `triggerConditions = "VIX > 25"`.

- **Test Case 1.3: Deleting an Instinct**

  - **Input**: The system calls 
    ```solidity
    deleteInstinct(0xINSTINCT1);
    ```
  - **Expected Output**:  
    - The instinct `0xINSTINCT1` is removed from on-chain storage.  
    - Agents will no longer consider `0xINSTINCT1` a valid action path. Queries for that instinct return an error or indicate non-existence.

### 2. AI-Agent Decision-Making

- **Test Case 2.1: Evaluating Instincts**

  - **Input**: An AI agent periodically reads the blockchain and sees multiple instincts. Off-chain, it calls 
    ```solidity
    evaluateInstincts(0xAGENT1, currentBlockTime);
    ```
  - **Expected Output**:  
    - The contract returns a list of relevant instincts (and/or mid-way targets) that `0xAGENT1` can act upon, based on the `triggerConditions` and any environment variables (like balances or ownership data) that may factor into those conditions.  
    - The agent then decides which instinct to pursue based on its internal strategy.

- **Test Case 2.2: Selecting and Acting on an Instinct**

  - **Input**: The agent chooses an instinct—for instance, `0xINSTINCT2` with condition “ETH price < 2,000”—and, after verifying off-chain that the condition is met, calls 
    ```solidity
    actOnInstinct(0xINSTINCT2, 0xAGENT1);
    ```
  - **Expected Output**:  
    - The contract checks on-chain or via an oracle feed that `ETH price < 2,000` is indeed true.  
    - Since `autoExecution` is `true`, it automatically executes the defined action (e.g., buying ETH or updating a resource ownership variable).  
    - An event `ActOnInstinct` logs the result.

### 3. Automatic Execution

- **Test Case 3.1: Automatic Execution without Agent Intervention**

  - **Input**: An instinct `0xINSTINCT3` is stored with `autoExecution = true`, referencing a condition like “Renewable supply > 80%.”  
  - **Expected Output**:  
    - When an oracle reports that renewable energy availability is above 80%, the smart contract automatically reallocates resources (e.g., updates environment variables or executes a token transfer).  
    - Agents observing the chain see the environment variable update (e.g., “RenewableResourceOwnedBy = 0xAGENT1”), and can adapt their off-chain plans accordingly.

### 4. Learning and Strategy Update

- **Test Case 4.1: Labeling an Instinct with Cost**

  - **Input**: After following an instinct that required extensive gas usage, the agent calls 
    ```solidity
    labelInstinct(0xINSTINCT2, -10);
    ```
  - **Expected Output**:  
    - The contract stores or emits an event indicating the cost label of `-10` for `0xINSTINCT2`.  
    - Future off-chain computations by the same or other agents can access this cost information, learning from past actions to avoid similarly expensive tasks unless heavily rewarded.

- **Test Case 4.2: Updating Agent Strategy**

  - **Input**: The agent modifies its off-chain logic to deprioritize instincts labeled as high-cost.  
  - **Expected Output**:  
    - In subsequent calls to `evaluateInstincts`, the agent weighs the cost labels more heavily, potentially ignoring or delaying `0xINSTINCT2` in favor of more profitable instincts.

### 5. Dynamic Instinct Adjustment

- **Test Case 5.1: Instinct Updating Based on External Data**

  - **Input**: A dynamic instinct `0xINSTINCT4` is configured with `temptationValue = +10` and `triggerConditions` related to network congestion.  
  - **Expected Output**:  
    - If an oracle or an on-chain environment variable indicates that congestion has dropped below a threshold, an authorized account calls 
      ```solidity
      updateInstinct(0xINSTINCT4, +20);
      ```
    - Agents see the updated `temptationValue = +20`, making the instinct more appealing. If `autoExecution` is disabled, agents must initiate the final transaction themselves, once triggered.

### 6. Verification of Off-Chain Computations

- **Test Case 6.1: Verifying Agent Actions On-Chain**

  - **Input**: An AI agent completes a resource-intensive computation off-chain (e.g., image recognition, large dataset analysis), then submits a proof:
    ```solidity
    actOnInstinct(0xINSTINCT5, 0xAGENT2, proofData);
    ```
  - **Expected Output**:  
    - The smart contract verifies `proofData` (e.g., via a zero-knowledge proof or a signature from a trusted oracle).  
    - If verified, it executes the associated transaction—such as updating an environment variable (“Agent2TaskComplete = true”) or issuing tokens as a reward.  
    - This ensures trust-minimized recognition of the agent’s off-chain work.

---

## Security Considerations

1. **Instinct Integrity**:  
   - Ensure that instincts and their attributes (temptation values, trigger conditions, environment variable references) are immutable unless specifically designed to be dynamic.  
   - Protect them from unauthorized modification or deletion.
2. **AI-Agent Security**:  
   - Prevent malicious actors from masquerading as legitimate agents.  
   - Use on-chain or cryptographic methods to authenticate the entity calling `actOnInstinct`.
3. **Environment Variable Protection**:  
   - Only authorized or valid transactions should be allowed to modify critical environment variables.  
   - Implement robust role-based permissioning to avoid tampering with agent states or memory records.
4. **Data Privacy**:  
   - Recognize that on-chain data is publicly visible. If environment variables contain sensitive information, consider encryption or other privacy-preserving measures.
5. **Oracle and Off-Chain Verification**:  
   - Dependence on external data (oracle feeds, off-chain proofs) introduces trust assumptions.  
   - Mitigate by using decentralized oracles, robust validation mechanisms, or multi-signature approvals.

By integrating **instincts** and **environment variables** on-chain, this ERC empowers AI agents to sense, record, and adapt to dynamic conditions in a trust-minimized ecosystem. Automatic transactions and learning processes further expand the possibilities for robust, autonomous decision-making in decentralized contexts.


## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).