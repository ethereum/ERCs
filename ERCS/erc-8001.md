---
eip: 8001
title: Agent Coordination Framework
description: Efficient framework for autonomous agent coordination with modular security and cross-chain capabilities
author: Kwame Bryan (@kbryan)
discussions-to: https://ethereum-magicians.org/t/erc-8001-secure-intents-a-cryptographic-framework-for-autonomous-agent-coordination-draft-erc-8001/24989
status: Draft
type: Standards Track
category: ERC
created: 2025-08-02
requires: 712, 2612
---

## Abstract

This proposal builds on [EIP-712](./eip-712.md) and complements [ERC-7683](./eip-7683.md) and [ERC-7521](./eip-7521.md). [ERC-8001](./erc-8001.md) defines a secure framework for direct agent-to-agent coordination in decentralized environments. The Core specification provides cryptographically secure intent semantics with multi-party consensus, while maintaining [EIP-712](./eip-712.md) compatibility for wallet and agent integration. Optional modules extend functionality with enhanced security, batch execution, and cross-chain coordination. This enables autonomous agents in DeFi, MEV search, cross-chain arbitrage, and market making to coordinate securely without trusted intermediaries.

## Motivation

Autonomous agents operating in DeFi, MEV extraction, cross-chain arbitrage, and automated market making require standardized coordination mechanisms to collaborate efficiently without trusted intermediaries. Current solutions suffer from several limitations:

1. **Lack of standardization**: Each agent system implements custom coordination protocols, preventing interoperability
2. **Security vulnerabilities**: Ad-hoc coordination mechanisms often lack proper cryptographic guarantees
3. **Trust requirements**: Many systems require trusted coordinators or centralized infrastructure
4. **Limited multi-party support**: Existing intent frameworks focus on single-user scenarios

While [ERC-7683](./eip-7683.md) addresses user-initiated cross-chain intents and [ERC-7521](./eip-7521.md) handles transfer-centric scenarios, neither provides the multi-party consensus and agent-specific features required for autonomous agent coordination.

[ERC-8001](./erc-8001.md) addresses these gaps by providing:
- **Cryptographically secure multi-party coordination** with [EIP-712](./eip-712.md) signatures
- **Standardized agent discovery and reputation** tracking
- **Modular security levels** from basic coordination to maximum confidentiality
- **Cross-chain atomic coordination** with finality guarantees
- **Gas-efficient batch execution** for complex multi-agent strategies

## Specification

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Core Data Structures

```solidity
struct AgentIntent {
    bytes32 payloadHash;        // keccak256 of CoordinationPayload
    uint64  expiry;             // Unix timestamp expiration (MUST be > block.timestamp)
    uint64  nonce;              // Replay protection (MUST be > agentNonces[agentId])
    uint32  chainId;            // EIP-155 chain identifier
    address agentId;            // Proposing agent identifier
    bytes32 coordinationType;   // Type of coordination (e.g., "ARBITRAGE_V1")
    uint256 maxGasCost;         // Maximum gas cost per participant
    uint8   priority;           // Execution priority (0-255, higher = more urgent)
    bytes32 dependencyHash;     // Hash of dependent intent (0x0 if none)
    uint8   securityLevel;      // Security requirements (0=BASIC, 1=STANDARD, 2=ENHANCED, 3=MAXIMUM)
    address[] participants;     // All participating agents (MUST include agentId)
    uint256 coordinationValue;  // Total value being coordinated (wei)
}

struct CoordinationPayload {
    bytes32 version;            // Payload format version
    bytes32 coordinationType;   // MUST match AgentIntent.coordinationType
    bytes   coordinationData;   // Type-specific coordination parameters
    bytes32 conditionsHash;     // Hash of execution conditions
    uint256 timestamp;          // Payload creation timestamp
    bytes   metadata;           // Additional coordination metadata
}

struct AcceptanceAttestation {
    bytes32 intentHash;         // Hash of AgentIntent being accepted
    address participant;        // Accepting agent address
    uint64  nonce;              // Participant's acceptance nonce
    uint64  expiry;             // Acceptance validity period
    bytes32 conditionsHash;     // Hash of participant's additional conditions
    bytes   signature;          // EIP-712 signature over attestation
}
```

### EIP-712 Domain and Type Definitions

```solidity
// Domain separator
bytes32 constant DOMAIN_TYPEHASH = keccak256(
    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
);

// Intent type hash
bytes32 constant AGENT_INTENT_TYPEHASH = keccak256(
    "AgentIntent(bytes32 payloadHash,uint64 expiry,uint64 nonce,uint32 chainId,address agentId,bytes32 coordinationType,uint256 maxGasCost,uint8 priority,bytes32 dependencyHash,uint8 securityLevel,bytes32 participantsHash,uint256 coordinationValue)"
);

// Acceptance type hash
bytes32 constant ACCEPTANCE_TYPEHASH = keccak256(
    "AcceptanceAttestation(bytes32 intentHash,address participant,uint64 nonce,uint64 expiry,bytes32 conditionsHash)"
);

function getIntentHash(AgentIntent memory intent) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        AGENT_INTENT_TYPEHASH,
        intent.payloadHash,
        intent.expiry,
        intent.nonce,
        intent.chainId,
        intent.agentId,
        intent.coordinationType,
        intent.maxGasCost,
        intent.priority,
        intent.dependencyHash,
        intent.securityLevel,
        keccak256(abi.encodePacked(intent.participants)),
        intent.coordinationValue
    ));
}
```

### Core Interface

```solidity
interface IAgentCoordinationCore {
    /// @notice Coordination lifecycle events
    event CoordinationProposed(
        bytes32 indexed intentHash,
        address indexed proposer,
        bytes32 coordinationType,
        uint256 participantCount,
        uint256 coordinationValue
    );
    
    event CoordinationAccepted(
        bytes32 indexed intentHash,
        address indexed participant,
        bytes32 acceptanceHash,
        uint256 acceptedCount,
        uint256 requiredCount
    );
    
    event CoordinationExecuted(
        bytes32 indexed intentHash,
        address indexed executor,
        bool success,
        uint256 gasUsed,
        bytes result
    );
    
    event CoordinationCancelled(
        bytes32 indexed intentHash,
        address indexed canceller,
        string reason,
        uint8 finalStatus
    );

    /// @notice Agent management events
    event AgentNonceUpdated(address indexed agent, uint64 newNonce);
    event SecurityLevelUpdated(bytes32 indexed intentHash, uint8 newLevel);

    /// @notice Core coordination functions
    function proposeCoordination(
        AgentIntent calldata intent,
        bytes calldata signature,
        CoordinationPayload calldata payload
    ) external returns (bytes32 intentHash);

    function acceptCoordination(
        bytes32 intentHash,
        AcceptanceAttestation calldata attestation
    ) external returns (bool allAccepted);

    function executeCoordination(
        bytes32 intentHash,
        CoordinationPayload calldata payload,
        bytes calldata executionData
    ) external returns (bool success, bytes memory result);

    function cancelCoordination(
        bytes32 intentHash,
        string calldata reason
    ) external;

    /// @notice View functions
    function getCoordinationStatus(bytes32 intentHash) 
        external view returns (
            uint8 status,
            address proposer,
            address[] memory participants,
            address[] memory acceptedBy,
            uint256 expiry
        );

    function validateIntent(
        AgentIntent calldata intent,
        bytes calldata signature
    ) external view returns (bool valid, string memory reason);

    function getAgentNonce(address agent) external view returns (uint64);
    
    function getRequiredAcceptances(bytes32 intentHash) external view returns (uint256);
}
```

### Security Module Interface

```solidity
interface IAgentSecurityModule {
    enum SecurityLevel { BASIC, STANDARD, ENHANCED, MAXIMUM }
    
    struct SecurityContext {
        SecurityLevel level;
        bytes32[] authorizedAgents;
        bytes encryptionKey;
        uint256 timelock;
        bytes32 accessControlHash;
    }

    function validateSecurityLevel(
        bytes32 intentHash,
        SecurityLevel level,
        bytes calldata proof
    ) external view returns (bool valid, string memory reason);

    function encryptCoordinationData(
        bytes calldata data,
        address[] calldata participants,
        SecurityLevel level
    ) external view returns (bytes memory encryptedData, bytes memory keyData);

    function decryptCoordinationData(
        bytes calldata encryptedData,
        bytes calldata keyData,
        address participant,
        SecurityLevel level
    ) external view returns (bytes memory decryptedData);
}
```

## Rationale

### Multi-Party Coordination Design

The core design prioritizes **secure multi-party coordination** over single-user intent execution. Key design decisions:

1. **Explicit Participant Lists**: All participants must be declared upfront, enabling proper access control and preventing unauthorized coordination hijacking.

2. **Cryptographic Attestations**: Each participant must provide an [EIP-712](./eip-712.md) signed attestation, ensuring non-repudiation and preventing coordinator manipulation.

3. **Modular Security Levels**: Different coordination scenarios require different security guarantees, from basic coordination (gas-efficient) to maximum security (with encryption and formal verification).

### Gas Optimization Strategy

The framework optimizes for coordination efficiency:

- **Batch Acceptance**: Multiple participants can accept in a single transaction
- **Lazy Execution**: Coordination data is only validated during execution, not during proposal
- **Modular Security**: Applications pay only for the security level they require
- **Efficient Hashing**: Participant lists are hashed to reduce storage costs

### EIP-712 Integration

Full [EIP-712](./eip-712.md) compatibility ensures:
- **Wallet Integration**: Standard wallets can sign coordination intents
- **Human Readability**: Users can understand what they're signing
- **Replay Protection**: Domain separation prevents cross-contract attacks
- **Type Safety**: Structured data prevents signature malleability

## Backwards Compatibility

This ERC is fully backwards compatible:

1. **No existing interface modifications**: Introduces new functionality without changing existing standards
2. **EIP-712 compliance**: Works with all [EIP-712](./eip-712.md) compatible wallets and tools
3. **Complementary to existing ERCs**: Can be used alongside [ERC-7683](./eip-7683.md), [ERC-7521](./eip-7521.md), and other intent standards
4. **Optional adoption**: Existing agent systems can adopt incrementally through the modular design

## Test Cases

### Core Functionality Tests

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/AgentCoordinationFramework.sol";
import "../src/AgentSecurityModule.sol";

contract AgentCoordinationTest is Test {
    AgentCoordinationFramework coordination;
    AgentSecurityModule security;
    
    address alice = address(0xA11CE);
    address bob = address(0xB0B);
    address charlie = address(0xC0DE);
    
    uint256 aliceKey = 0xa11ce;
    uint256 bobKey = 0xb0b;
    uint256 charlieKey = 0xc0de;

    function setUp() public {
        coordination = new AgentCoordinationFramework();
        security = new AgentSecurityModule();
        
        vm.deal(alice, 10 ether);
        vm.deal(bob, 10 ether);
        vm.deal(charlie, 10 ether);
    }

    function testBasicCoordination() public {
        // Create coordination intent
        address[] memory participants = new address[](2);
        participants[0] = alice;
        participants[1] = bob;
        
        IAgentCoordinationCore.AgentIntent memory intent = IAgentCoordinationCore.AgentIntent({
            payloadHash: bytes32(0), // Will be computed
            expiry: uint64(block.timestamp + 3600),
            nonce: 1,
            chainId: uint32(block.chainid),
            agentId: alice,
            coordinationType: keccak256("ARBITRAGE_V1"),
            maxGasCost: 100000,
            priority: 128,
            dependencyHash: bytes32(0),
            securityLevel: 0, // BASIC
            participants: participants,
            coordinationValue: 1 ether
        });

        IAgentCoordinationCore.CoordinationPayload memory payload = IAgentCoordinationCore.CoordinationPayload({
            version: keccak256("v1"),
            coordinationType: intent.coordinationType,
            coordinationData: abi.encode("arbitrage", "ETH/USDC", 1000000),
            conditionsHash: keccak256("price > 1800"),
            timestamp: block.timestamp,
            metadata: ""
        });

        intent.payloadHash = coordination.getPayloadHash(payload);
        
        // Sign intent
        bytes32 intentHash = coordination.getIntentHash(intent);
        bytes32 domainSeparator = coordination.getDomainSeparator();
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, intentHash));
        
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(aliceKey, digest);
        bytes memory signature = abi.encodePacked(r, s, v);

        // Propose coordination
        vm.prank(alice);
        bytes32 resultHash = coordination.proposeCoordination(intent, signature, payload);
        assertEq(resultHash, intentHash);

        // Verify status
        (uint8 status, address proposer, address[] memory parts, address[] memory accepted, uint256 expiry) = 
            coordination.getCoordinationStatus(intentHash);
        assertEq(status, 0); // PROPOSED
        assertEq(proposer, alice);
        assertEq(parts.length, 2);
        assertEq(accepted.length, 0);

        // Bob accepts coordination
        IAgentCoordinationCore.AcceptanceAttestation memory attestation = IAgentCoordinationCore.AcceptanceAttestation({
            intentHash: intentHash,
            participant: bob,
            nonce: 1,
            expiry: uint64(block.timestamp + 1800),
            conditionsHash: keccak256("agreed"),
            signature: ""
        });

        bytes32 acceptanceHash = coordination.getAcceptanceHash(attestation);
        bytes32 acceptanceDigest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, acceptanceHash));
        (v, r, s) = vm.sign(bobKey, acceptanceDigest);
        attestation.signature = abi.encodePacked(r, s, v);

        vm.prank(bob);
        bool allAccepted = coordination.acceptCoordination(intentHash, attestation);
        assertTrue(allAccepted);

        // Execute coordination
        vm.prank(alice);
        (bool success, bytes memory result) = coordination.executeCoordination(intentHash, payload, "");
        assertTrue(success);
        assertEq(result, payload.coordinationData);
    }

    function testReplayProtection() public {
        address[] memory participants = new address[](1);
        participants[0] = alice;
        
        IAgentCoordinationCore.AgentIntent memory intent = createTestIntent(participants);
        IAgentCoordinationCore.CoordinationPayload memory payload = createTestPayload();
        intent.payloadHash = coordination.getPayloadHash(payload);
        
        bytes memory signature = signIntent(intent, aliceKey);

        // First proposal should succeed
        vm.prank(alice);
        coordination.proposeCoordination(intent, signature, payload);

        // Second proposal with same nonce should fail
        vm.prank(alice);
        vm.expectRevert("Invalid nonce");
        coordination.proposeCoordination(intent, signature, payload);
    }

    function testExpiredIntent() public {
        address[] memory participants = new address[](1);
        participants[0] = alice;
        
        IAgentCoordinationCore.AgentIntent memory intent = createTestIntent(participants);
        intent.expiry = uint64(block.timestamp - 1); // Expired
        
        IAgentCoordinationCore.CoordinationPayload memory payload = createTestPayload();
        intent.payloadHash = coordination.getPayloadHash(payload);
        
        bytes memory signature = signIntent(intent, aliceKey);

        vm.prank(alice);
        vm.expectRevert("Intent expired");
        coordination.proposeCoordination(intent, signature, payload);
    }

    function testUnauthorizedParticipant() public {
        address[] memory participants = new address[](2);
        participants[0] = alice;
        participants[1] = bob;
        
        IAgentCoordinationCore.AgentIntent memory intent = createTestIntent(participants);
        IAgentCoordinationCore.CoordinationPayload memory payload = createTestPayload();
        intent.payloadHash = coordination.getPayloadHash(payload);
        
        bytes memory signature = signIntent(intent, aliceKey);

        vm.prank(alice);
        bytes32 intentHash = coordination.proposeCoordination(intent, signature, payload);

        // Charlie tries to accept but is not a participant
        IAgentCoordinationCore.AcceptanceAttestation memory attestation = IAgentCoordinationCore.AcceptanceAttestation({
            intentHash: intentHash,
            participant: charlie,
            nonce: 1,
            expiry: uint64(block.timestamp + 1800),
            conditionsHash: keccak256("unauthorized"),
            signature: ""
        });

        bytes32 acceptanceHash = coordination.getAcceptanceHash(attestation);
        bytes32 domainSeparator = coordination.getDomainSeparator();
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, acceptanceHash));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(charlieKey, digest);
        attestation.signature = abi.encodePacked(r, s, v);

        vm.prank(charlie);
        vm.expectRevert("Not a participant");
        coordination.acceptCoordination(intentHash, attestation);
    }

    function testInvalidSignature() public {
        address[] memory participants = new address[](1);
        participants[0] = alice;
        
        IAgentCoordinationCore.AgentIntent memory intent = createTestIntent(participants);
        IAgentCoordinationCore.CoordinationPayload memory payload = createTestPayload();
        intent.payloadHash = coordination.getPayloadHash(payload);
        
        // Sign with wrong key
        bytes memory signature = signIntent(intent, bobKey);

        vm.prank(alice);
        vm.expectRevert("Invalid signature");
        coordination.proposeCoordination(intent, signature, payload);
    }

    function testPayloadHashMismatch() public {
        address[] memory participants = new address[](1);
        participants[0] = alice;
        
        IAgentCoordinationCore.AgentIntent memory intent = createTestIntent(participants);
        IAgentCoordinationCore.CoordinationPayload memory payload = createTestPayload();
        IAgentCoordinationCore.CoordinationPayload memory wrongPayload = createTestPayload();
        wrongPayload.coordinationData = "wrong data";
        
        intent.payloadHash = coordination.getPayloadHash(payload);
        bytes memory signature = signIntent(intent, aliceKey);

        vm.prank(alice);
        bytes32 intentHash = coordination.proposeCoordination(intent, signature, payload);

        vm.prank(alice);
        vm.expectRevert("Payload hash mismatch");
        coordination.executeCoordination(intentHash, wrongPayload, "");
    }

    // Helper functions
    function createTestIntent(address[] memory participants) internal view returns (IAgentCoordinationCore.AgentIntent memory) {
        return IAgentCoordinationCore.AgentIntent({
            payloadHash: bytes32(0),
            expiry: uint64(block.timestamp + 3600),
            nonce: coordination.getAgentNonce(alice) + 1,
            chainId: uint32(block.chainid),
            agentId: alice,
            coordinationType: keccak256("TEST_V1"),
            maxGasCost: 100000,
            priority: 128,
            dependencyHash: bytes32(0),
            securityLevel: 0,
            participants: participants,
            coordinationValue: 1 ether
        });
    }

    function createTestPayload() internal view returns (IAgentCoordinationCore.CoordinationPayload memory) {
        return IAgentCoordinationCore.CoordinationPayload({
            version: keccak256("v1"),
            coordinationType: keccak256("TEST_V1"),
            coordinationData: abi.encode("test", "data"),
            conditionsHash: keccak256("test conditions"),
            timestamp: block.timestamp,
            metadata: ""
        });
    }

    function signIntent(IAgentCoordinationCore.AgentIntent memory intent, uint256 privateKey) internal view returns (bytes memory) {
        bytes32 intentHash = coordination.getIntentHash(intent);
        bytes32 domainSeparator = coordination.getDomainSeparator();
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, intentHash));
        
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, digest);
        return abi.encodePacked(r, s, v);
    }
}
```

### Security Property Tests

```solidity
contract SecurityPropertyTest is Test {
    AgentCoordinationFramework coordination;
    
    function testIntentUniqueness() public {
        // Test that different intents have different hashes
        address[] memory participants1 = new address[](1);
        participants1[0] = address(0x1);
        
        address[] memory participants2 = new address[](1);
        participants2[0] = address(0x2);
        
        IAgentCoordinationCore.AgentIntent memory intent1 = createIntent(participants1, 1);
        IAgentCoordinationCore.AgentIntent memory intent2 = createIntent(participants2, 1);
        
        bytes32 hash1 = coordination.getIntentHash(intent1);
        bytes32 hash2 = coordination.getIntentHash(intent2);
        
        assertTrue(hash1 != hash2);
    }
    
    function testNonceMonotonicity() public {
        address agent = address(0x123);
        
        // Initial nonce should be 0
        assertEq(coordination.getAgentNonce(agent), 0);
        
        // After coordination, nonce should increment
        // [Test implementation would create and execute coordination]
        
        assertTrue(coordination.getAgentNonce(agent) > 0);
    }
}
```

## Reference Implementation

### Core Coordination Contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract AgentCoordinationFramework is IAgentCoordinationCore {
    // Constants
    bytes32 public constant DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
    );

    bytes32 public constant AGENT_INTENT_TYPEHASH = keccak256(
        "AgentIntent(bytes32 payloadHash,uint64 expiry,uint64 nonce,uint32 chainId,address agentId,bytes32 coordinationType,uint256 maxGasCost,uint8 priority,bytes32 dependencyHash,uint8 securityLevel,bytes32 participantsHash,uint256 coordinationValue)"
    );

    bytes32 public constant ACCEPTANCE_TYPEHASH = keccak256(
        "AcceptanceAttestation(bytes32 intentHash,address participant,uint64 nonce,uint64 expiry,bytes32 conditionsHash)"
    );

    // State variables
    bytes32 public immutable DOMAIN_SEPARATOR;

    mapping(address => uint64) public agentNonces;
    mapping(bytes32 => CoordinationState) private coordinationStates;

    struct CoordinationState {
        address proposer;
        bytes32 payloadHash;
        uint8 status; // 0=PROPOSED, 1=READY, 2=EXECUTED, 3=CANCELLED, 4=EXPIRED
        uint64 expiry;
        address[] participants;
        mapping(address => bool) acceptances;
        uint256 acceptanceCount;
        uint8 securityLevel;
        uint256 coordinationValue;
    }

    modifier nonReentrant() {
        require(!_locked, "Reentrant call");
        _locked = true;
        _;
        _locked = false;
    }
    bool private _locked;

    constructor() {
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            DOMAIN_TYPEHASH,
            keccak256("AgentCoordinationFramework"),
            keccak256("1"),
            block.chainid,
            address(this)
        ));
    }

    function proposeCoordination(
        AgentIntent calldata intent,
        bytes calldata signature,
        CoordinationPayload calldata payload
    ) external nonReentrant returns (bytes32 intentHash) {
        // Validate intent structure
        require(intent.expiry > block.timestamp, "Intent expired");
        require(intent.chainId == block.chainid, "Invalid chain ID");
        require(intent.participants.length > 0, "No participants");
        require(intent.coordinationType == payload.coordinationType, "Type mismatch");
        require(intent.nonce > agentNonces[intent.agentId], "Invalid nonce");

        // Validate payload hash
        bytes32 computedPayloadHash = keccak256(abi.encode(
            payload.version,
            payload.coordinationType,
            payload.coordinationData,
            payload.conditionsHash,
            payload.timestamp,
            payload.metadata
        ));
        require(intent.payloadHash == computedPayloadHash, "Payload hash mismatch");

        // Verify proposer is in participants list
        bool proposerInList = false;
        for (uint256 i = 0; i < intent.participants.length; i++) {
            if (intent.participants[i] == intent.agentId) {
                proposerInList = true;
                break;
            }
        }
        require(proposerInList, "Proposer not in participants");

        // Verify signature
        intentHash = getIntentHash(intent);
        require(verifyIntentSignature(intentHash, signature, intent.agentId), "Invalid signature");

        // Store coordination state
        CoordinationState storage state = coordinationStates[intentHash];
        require(state.proposer == address(0), "Coordination exists");

        state.proposer = intent.agentId;
        state.payloadHash = computedPayloadHash;
        state.status = 0; // PROPOSED
        state.expiry = intent.expiry;
        state.participants = intent.participants;
        state.securityLevel = intent.securityLevel;
        state.coordinationValue = intent.coordinationValue;

        // Update nonce
        agentNonces[intent.agentId] = intent.nonce;

        emit CoordinationProposed(
            intentHash,
            intent.agentId,
            intent.coordinationType,
            intent.participants.length,
            intent.coordinationValue
        );
    }

    function acceptCoordination(
        bytes32 intentHash,
        AcceptanceAttestation calldata attestation
    ) external nonReentrant returns (bool allAccepted) {
        CoordinationState storage state = coordinationStates[intentHash];
        require(state.proposer != address(0), "Coordination not found");
        require(state.status == 0, "Invalid status");
        require(block.timestamp <= state.expiry, "Coordination expired");
        require(attestation.intentHash == intentHash, "Intent hash mismatch");
        require(attestation.expiry > block.timestamp, "Acceptance expired");

        // Verify participant is in list
        bool isParticipant = false;
        for (uint256 i = 0; i < state.participants.length; i++) {
            if (state.participants[i] == attestation.participant) {
                isParticipant = true;
                break;
            }
        }
        require(isParticipant, "Not a participant");
        require(!state.acceptances[attestation.participant], "Already accepted");

        // Verify acceptance signature
        bytes32 acceptanceHash = keccak256(abi.encode(
            ACCEPTANCE_TYPEHASH,
            attestation.intentHash,
            attestation.participant,
            attestation.nonce,
            attestation.expiry,
            attestation.conditionsHash
        ));
        require(verifyAcceptanceSignature(acceptanceHash, attestation.signature, attestation.participant), "Invalid acceptance signature");

        // Record acceptance
        state.acceptances[attestation.participant] = true;
        state.acceptanceCount++;

        bytes32 acceptanceCommitment = keccak256(abi.encodePacked(
            intentHash,
            attestation.participant,
            block.number
        ));

        emit CoordinationAccepted(
            intentHash,
            attestation.participant,
            acceptanceCommitment,
            state.acceptanceCount,
            state.participants.length
        );

        // Check if all participants have accepted
        allAccepted = (state.acceptanceCount == state.participants.length);
        if (allAccepted) {
            state.status = 1; // READY
        }
    }

    function executeCoordination(
        bytes32 intentHash,
        CoordinationPayload calldata payload,
        bytes calldata executionData
    ) external nonReentrant returns (bool success, bytes memory result) {
        CoordinationState storage state = coordinationStates[intentHash];
        require(state.proposer != address(0), "Coordination not found");
        require(state.status == 1, "Not ready for execution");
        require(block.timestamp <= state.expiry, "Coordination expired");

        // Verify payload
        bytes32 computedPayloadHash = keccak256(abi.encode(
            payload.version,
            payload.coordinationType,
            payload.coordinationData,
            payload.conditionsHash,
            payload.timestamp,
            payload.metadata
        ));
        require(state.payloadHash == computedPayloadHash, "Payload hash mismatch");

        // Execute coordination logic
        uint256 gasStart = gasleft();

        // Basic execution - can be extended by modules
        state.status = 2; // EXECUTED
        success = true;
        result = payload.coordinationData;

        uint256 gasUsed = gasStart - gasleft();

        emit CoordinationExecuted(intentHash, msg.sender, success, gasUsed, result);
    }

    function cancelCoordination(bytes32 intentHash, string calldata reason) external nonReentrant {
        CoordinationState storage state = coordinationStates[intentHash];
        require(state.proposer != address(0), "Coordination not found");
        require(state.status < 2, "Already executed");
        require(msg.sender == state.proposer || block.timestamp > state.expiry, "Not authorized");

        uint8 finalStatus = block.timestamp > state.expiry ? 4 : 3; // EXPIRED : CANCELLED
        state.status = finalStatus;

        emit CoordinationCancelled(intentHash, msg.sender, reason, finalStatus);
    }

    // View functions
    function getCoordinationStatus(bytes32 intentHash) external view returns (
        uint8 status,
        address proposer,
        address[] memory participants,
        address[] memory acceptedBy,
        uint256 expiry
    ) {
        CoordinationState storage state = coordinationStates[intentHash];
        status = state.status;
        proposer = state.proposer;
        participants = state.participants;
        expiry = state.expiry;

        // Build accepted participants list
        uint256 acceptedCount = 0;
        for (uint256 i = 0; i < state.participants.length; i++) {
            if (state.acceptances[state.participants[i]]) {
                acceptedCount++;
            }
        }

        acceptedBy = new address[](acceptedCount);
        uint256 index = 0;
        for (uint256 i = 0; i < state.participants.length; i++) {
            if (state.acceptances[state.participants[i]]) {
                acceptedBy[index++] = state.participants[i];
            }
        }
    }

    function validateIntent(AgentIntent calldata intent, bytes calldata signature) external view returns (bool valid, string memory reason) {
        if (intent.expiry <= block.timestamp) {
            return (false, "Intent expired");
        }

        if (intent.chainId != block.chainid) {
            return (false, "Invalid chain ID");
        }

        if (intent.nonce <= agentNonces[intent.agentId]) {
            return (false, "Invalid nonce");
        }

        if (intent.participants.length == 0) {
            return (false, "No participants");
        }

        bytes32 intentHash = getIntentHash(intent);
        if (!verifyIntentSignature(intentHash, signature, intent.agentId)) {
            return (false, "Invalid signature");
        }

        return (true, "");
    }

    function getAgentNonce(address agent) external view returns (uint64) {
        return agentNonces[agent];
    }

    function getRequiredAcceptances(bytes32 intentHash) external view returns (uint256) {
        return coordinationStates[intentHash].participants.length;
    }

    function getDomainSeparator() external view returns (bytes32) {
        return DOMAIN_SEPARATOR;
    }

    function getIntentHash(AgentIntent calldata intent) public pure returns (bytes32) {
        return keccak256(abi.encode(
            AGENT_INTENT_TYPEHASH,
            intent.payloadHash,
            intent.expiry,
            intent.nonce,
            intent.chainId,
            intent.agentId,
            intent.coordinationType,
            intent.maxGasCost,
            intent.priority,
            intent.dependencyHash,
            intent.securityLevel,
            keccak256(abi.encodePacked(intent.participants)),
            intent.coordinationValue
        ));
    }

    function getPayloadHash(CoordinationPayload calldata payload) public pure returns (bytes32) {
        return keccak256(abi.encode(
            payload.version,
            payload.coordinationType,
            payload.coordinationData,
            payload.conditionsHash,
            payload.timestamp,
            payload.metadata
        ));
    }

    function getAcceptanceHash(AcceptanceAttestation calldata attestation) public pure returns (bytes32) {
        return keccak256(abi.encode(
            ACCEPTANCE_TYPEHASH,
            attestation.intentHash,
            attestation.participant,
            attestation.nonce,
            attestation.expiry,
            attestation.conditionsHash
        ));
    }

    function verifyIntentSignature(bytes32 intentHash, bytes calldata signature, address expectedSigner) public view returns (bool) {
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, intentHash));
        return recoverSigner(digest, signature) == expectedSigner;
    }

    function verifyAcceptanceSignature(bytes32 acceptanceHash, bytes calldata signature, address expectedSigner) public view returns (bool) {
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, acceptanceHash));
        return recoverSigner(digest, signature) == expectedSigner;
    }

    function recoverSigner(bytes32 digest, bytes calldata signature) internal pure returns (address) {
        require(signature.length == 65, "Invalid signature length");

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := calldataload(signature.offset)
            s := calldataload(add(signature.offset, 32))
            v := byte(0, calldataload(add(signature.offset, 64)))
        }

        return ecrecover(digest, v, r, s);
    }
}
```

## Security Considerations

### Cryptographic Security

**Signature Verification**: All intents and acceptances MUST be verified using [EIP-712](./eip-712.md) structured data signing with proper domain separation. This prevents:
- **Signature replay attacks**: Domain separation ensures signatures cannot be replayed across different contracts or chains
- **Signature malleability**: Structured typing prevents manipulation of signed data
- **Cross-contract attacks**: Domain binding ties signatures to specific contract instances

**Nonce Management**: Agent nonces MUST be monotonically increasing and checked during intent proposal to prevent replay attacks. Each agent maintains an independent nonce sequence.

**Hash Integrity**: All payload hashes MUST be verified during execution to ensure the executed coordination matches the originally proposed and accepted intent.

### Multi-Party Consensus Security

**Participant Authorization**: Only explicitly listed participants can accept a coordination, preventing unauthorized agents from hijacking coordination processes.

**Acceptance Attestations**: Each participant must provide a cryptographically signed acceptance with its own expiry and conditions, ensuring non-repudiation and preventing coordinator manipulation.

**All-or-Nothing Consensus**: Coordination only becomes executable when ALL participants have provided valid acceptance attestations, preventing partial execution attacks.

### Attack Vector Analysis

**Agent Collusion**: Malicious participants could collude to manipulate coordination outcomes. Mitigations:
- All coordination terms are transparent and cryptographically committed
- Reputation systems (via Discovery Module) can track malicious behavior
- Economic incentives align participant interests with honest behavior

**Griefing Attacks**: Participants could propose coordination with no intention to execute. Mitigations:
- Coordination value and gas cost limits prevent excessive resource consumption
- Expiry mechanisms automatically clean up stale coordination
- Reputation penalties for agents that frequently propose but don't execute

**Replay Attacks**: Prevented through:
- Monotonic nonce sequences per agent
- EIP-712 domain separation
- Chain ID validation
- Expiry timestamps

**Front-Running**: Coordination proposals are public, potentially allowing front-running. Mitigations:
- Security modules provide encryption for sensitive coordination data
- Commitment schemes can hide coordination details until execution
- Time-locks can prevent immediate execution after proposal

### Cross-Chain Security

**Finality Requirements**: Cross-chain coordination MUST wait for finality on source chains before proceeding. The Cross-Chain Module MUST:
- Define explicit finality requirements for each supported chain
- Implement proof verification for cross-chain state
- Provide automatic rollback mechanisms for failed cross-chain operations

**Bridge Security**: Integration with cross-chain bridges MUST:
- Only use bridges with formal security audits
- Implement timeouts and rollback mechanisms
- Validate bridge-specific finality proofs

### Economic Security

**Value Protection**: The `coordinationValue` field enables economic security analysis:
- Participants can assess the economic risk of coordination
- Reputation systems can weight behavior by coordination value
- Slashing mechanisms can be proportional to coordination value

**Gas Cost Management**: The `maxGasCost` field prevents griefing through excessive gas consumption during execution.

### Privacy Considerations

**Metadata Exposure**: Basic coordination reveals participant lists and coordination types. For privacy-sensitive coordination:
- Use enhanced security levels with encryption
- Implement commit-reveal schemes through Security Module
- Consider zero-knowledge proofs for sensitive coordination data

**Timing Analysis**: Coordination timing patterns could reveal strategic information. Implementations SHOULD consider:
- Randomized execution timing
- Batching multiple coordination in single transactions
- Using privacy-preserving coordination pools

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).