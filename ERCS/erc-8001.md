---
eip: 8001
title: Secure Intents Framework
description: Minimal framework for cryptographic intents enabling MEV protection and cross-chain coordination
author: Kwame Bryan (@kbryan)
discussions-to: https://ethereum-magicians.org/t/erc-8001-secure-intents-a-cryptographic-framework-for-autonomous-agent-coordination-draft-erc-8001/24989
status: Draft
type: Standards Track
category: ERC
created: 2025-08-02
requires: 712, 2612
---

## Abstract

[ERC-8001](./erc-8001.md) defines a modular framework for cryptographically signed intents with progressive complexity tiers. The core specification requires ~5,000 gas for basic intent validation, with optional modules for privacy (~25,000 gas), cross-chain coordination (~55,000 gas), and batch execution (40% gas savings per additional intent). The framework addresses MEV extraction ($1B+ annually) by enabling users to specify execution conditions while deferring actual execution to a competitive solver network.

## Motivation

Ethereum users lose over $1 billion annually to MEV extraction through sandwich attacks and front-running. Current solutions force users to choose between:

1. **Public mempool exposure**: 1-3% value loss to MEV
2. **Centralized services**: Trust assumptions defeating decentralization
3. **Complex ZK approaches**: 100,000+ gas making them economically unviable

Users need a gas-efficient way to sign intents with execution conditions, allowing specialized solvers to execute them competitively. For a 10,000 dollar trade, spending 2 dollars in gas (5,000 gas at 40 gwei) to save $100+ in MEV extraction provides clear economic value.

Cross-chain fragmentation further complicates user experience. Users cannot easily express desires like "move funds to the chain offering >10% yield" without manual bridge operations and monitoring.

This ERC proposes a modular solution where developers adopt only needed components, enabling immediate deployment for MEV protection while supporting advanced multi-chain strategies.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Core Intent Structure

```solidity
struct CoreIntent {
    bytes32 payloadHash;    // Keccak256 hash of payload
    uint64 expiry;          // Unix timestamp expiration
    uint64 nonce;           // Replay protection
    uint32 chainId;         // EIP-155 chain identifier
    address executor;       // Optional specific executor (0x0 for any)
    uint256 maxFee;         // Maximum fee in wei
    uint8 priority;         // Execution priority (0-255)
}
```

### Intent Hash Calculation

```solidity
bytes32 intentHash = keccak256(abi.encode(
    payloadHash,
    expiry,
    nonce,
    chainId,
    executor,
    maxFee,
    priority
));
```

### Payload Specification

```solidity
struct StandardPayload {
    bytes32 version;
    bytes32 intentType;
    bytes data;
    bytes32 conditionsHash;
}
```

### Standard Intent Types

```solidity
bytes32 constant SWAP = keccak256("SWAP_V1");
bytes32 constant BRIDGE = keccak256("BRIDGE_V1");
bytes32 constant BATCH = keccak256("BATCH_V1");
bytes32 constant LIMIT_ORDER = keccak256("LIMIT_ORDER_V1");
```

### Signature Schemes

Implementations MUST support ECDSA and SHOULD support [EIP-712](./eip-712.md) structured data signing.

**Standard Signature:**

```solidity
address signer = ecrecover(
    keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", intentHash)),
    v, r, s
);
```

**EIP-712 Signature:**

```solidity
bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    keccak256("IntentProtocol"),
    keccak256("1"),
    block.chainid,
    address(this)
));

bytes32 digest = keccak256(abi.encodePacked(
    "\x19\x01",
    DOMAIN_SEPARATOR,
    keccak256(abi.encode(TYPEHASH, intent))
));
```

### Core Contract Interface

```solidity
interface IIntentCore {
    event IntentCreated(bytes32 indexed intentHash, address indexed creator, uint8 priority, uint256 maxFee);
    event IntentExecuted(bytes32 indexed intentHash, address indexed executor, uint256 gasUsed, uint256 feeCharged);
    event IntentCancelled(bytes32 indexed intentHash, address indexed creator);

    function validateIntent(CoreIntent calldata intent, bytes calldata signature) external view returns (bool valid, string memory reason);
    function executeIntent(CoreIntent calldata intent, bytes calldata signature, StandardPayload calldata payload) external returns (bool success, bytes memory result);
    function cancelIntent(bytes32 intentHash) external;
    function estimateExecution(CoreIntent calldata intent, StandardPayload calldata payload) external view returns (uint256 gasEstimate, uint256 feeEstimate);
}
```

### Module Interfaces

#### Intent Module

```solidity
interface IIntentModule {
    function processIntent(CoreIntent calldata intent, StandardPayload calldata payload, bytes calldata moduleData) external returns (bool success, bytes memory result);
    function validateModule(CoreIntent calldata intent, bytes calldata moduleData) external view returns (bool valid);
    function getModuleGasCost() external view returns (uint256);
}
```

#### Privacy Module (Optional)

```solidity
interface IPrivacyModule is IIntentModule {
    struct PrivateIntent {
        bytes encryptedPayload;
        bytes32 payloadCommitment;
        address[] authorizedSolvers;
        uint256 revealBlock;
    }

    function submitPrivateIntent(PrivateIntent calldata intent, bytes calldata signature) external returns (bytes32 intentHash);
    function revealAndExecute(bytes32 intentHash, StandardPayload calldata decryptedPayload, bytes calldata proof) external returns (bool success);
}
```

#### Cross-Chain Module (Optional)

```solidity
interface ICrossChainModule is IIntentModule {
    struct CrossChainConfig {
        uint32 targetChainId;
        address targetContract;
        uint256 maxBridgeFee;
        uint256 confirmationBlocks;
        bytes bridgeData;
    }

    function initiateCrossChain(CoreIntent calldata intent, CrossChainConfig calldata config, bytes calldata signature) external payable returns (bytes32 messageId);
    function completeCrossChain(bytes32 messageId, bytes calldata proof) external returns (bool success);
}
```

#### Batch Module (Optional)

```solidity
interface IBatchModule is IIntentModule {
    function executeBatch(CoreIntent[] calldata intents, bytes[] calldata signatures, StandardPayload[] calldata payloads) external returns (bool[] memory results);
    function calculateBatchGas(uint256 intentCount) external pure returns (uint256 totalGas);
}
```

### Economic Incentives

```solidity
interface IIncentives {
    uint256 constant SOLVER_FEE_BPS = 10;
    uint256 constant MIN_SOLVER_STAKE = 0.1 ether;

    function stakeSolver() external payable;
    function claimRewards() external returns (uint256);
    function slashSolver(address solver, string calldata reason) external;
}
```

### Cross-Chain Finality Considerations

Cross-chain modules SHOULD validate finality using:
- ZK/light clients
- Oracle relays (e.g., Chainlink CCIP, LayerZero)
- Fraud windows & confirmation blocks

Bridges MUST implement proof-of-finality or rollback protection.

## Rationale

### Modular Architecture

The tiered approach allows progressive adoption:
- **Core Only**: 5,000 gas for simple limit orders
- **Core + Privacy**: 25,000 gas for MEV protection
- **Core + Cross-chain**: 55,000 gas for multi-chain coordination
- **Full Suite**: 70,000 gas for maximum functionality

This design avoids forcing unnecessary complexity on simple use cases while enabling sophisticated strategies.

### Gas Efficiency

**Optimizations**:
- Storing `payloadHash` instead of full payload saves ~200 bytes of storage
- Binary encoding over JSON reduces calldata by 95%
- Batch processing amortizes signature verification costs
- Module lazy-loading prevents unnecessary computation

### Economic Sustainability

The 0.1% solver fee on successful execution creates sustainable incentives while remaining competitive with centralized alternatives. For a $10,000 trade, this represents $10 in solver rewards - sufficient to maintain a competitive solver network while providing 10x value to users through MEV protection.

## Backwards Compatibility

This standard is fully opt-in and does not interfere with existing Ethereum transaction mechanics.

## Test Cases

### Extended Test Cases

```javascript
// Test 1: Replayed nonce
await intentCore.executeIntent(intent, sig, payload);
await expectRevert(intentCore.executeIntent(intent, sig, payload), "Invalid nonce");

// Test 2: Expired intent
intent.expiry = block.timestamp - 60;
await expectRevert(intentCore.validateIntent(intent, sig), "Intent expired");

// Test 3: Payload hash mismatch
intent.payloadHash = keccak256("invalid");
await expectRevert(intentCore.executeIntent(intent, sig, payload), "Payload mismatch");

// Test 4: Fee cap enforcement
assert(executedFee <= intent.maxFee);

// Test 5: Batch intent amortisation
assert(batchGas < 2 * singleGas);
```

### Forge Test Suite

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/IntentCore.sol";
import "../src/modules/BatchModule.sol";

contract IntentCoreTest is Test {
    IntentCore public intentCore;
    BatchModule public batchModule;
    
    address public user;
    address public solver;
    uint256 public userPrivateKey;
    uint256 public solverPrivateKey;
    
    function setUp() public {
        intentCore = new IntentCore();
        batchModule = new BatchModule(address(intentCore));
        
        userPrivateKey = 0x12341234;
        solverPrivateKey = 0x56785678;
        user = vm.addr(userPrivateKey);
        solver = vm.addr(solverPrivateKey);
        
        vm.deal(user, 10 ether);
        vm.deal(solver, 5 ether);
        
        vm.prank(solver);
        intentCore.stakeSolver{value: 1 ether}();
    }
    
    function testValidIntentSignature() public {
        CoreIntent memory intent = createTestIntent();
        bytes memory signature = signIntent(intent, userPrivateKey);
        
        (bool valid, string memory reason) = intentCore.validateIntent(intent, signature);
        assertTrue(valid);
        assertEq(reason, "");
    }
    
    function testRejectExpiredIntents() public {
        CoreIntent memory intent = createTestIntent();
        intent.expiry = uint64(block.timestamp - 3600);
        
        bytes memory signature = signIntent(intent, userPrivateKey);
        (bool valid, string memory reason) = intentCore.validateIntent(intent, signature);
        
        assertFalse(valid);
        assertEq(reason, "Intent expired");
    }
    
    function testPreventNonceReplay() public {
        CoreIntent memory intent = createTestIntent();
        StandardPayload memory payload = createTestPayload();
        bytes memory signature = signIntent(intent, userPrivateKey);
        
        vm.prank(solver);
        (bool success1,) = intentCore.executeIntent(intent, signature, payload);
        assertTrue(success1);
        
        vm.prank(solver);
        vm.expectRevert("Invalid nonce");
        intentCore.executeIntent(intent, signature, payload);
    }
    
    function testBatchExecutionGasSavings() public {
        CoreIntent[] memory intents = new CoreIntent[](2);
        intents[0] = createTestIntent();
        intents[0].nonce = 1;
        intents[1] = createTestIntent();
        intents[1].nonce = 2;
        
        bytes[] memory signatures = new bytes[](2);
        signatures[0] = signIntent(intents[0], userPrivateKey);
        signatures[1] = signIntent(intents[1], userPrivateKey);
        
        StandardPayload[] memory payloads = new StandardPayload[](2);
        payloads[0] = createTestPayload();
        payloads[1] = createTestPayload();
        
        uint256 gas1 = measureExecutionGas(intents[0], signatures[0], payloads[0]);
        uint256 gas2 = measureExecutionGas(intents[1], signatures[1], payloads[1]);
        uint256 totalIndividual = gas1 + gas2;
        
        uint256 gasBefore = gasleft();
        vm.prank(solver);
        batchModule.executeBatch(intents, signatures, payloads);
        uint256 batchGas = gasBefore - gasleft();
        
        assertLt(batchGas, (totalIndividual * 80) / 100);
    }
    
    function createTestIntent() internal view returns (CoreIntent memory) {
        StandardPayload memory payload = createTestPayload();
        return CoreIntent({
            payloadHash: keccak256(abi.encode(payload)),
            expiry: uint64(block.timestamp + 3600),
            nonce: 1,
            chainId: uint32(block.chainid),
            executor: address(0),
            maxFee: 0.01 ether,
            priority: 128
        });
    }
    
    function createTestPayload() internal pure returns (StandardPayload memory) {
        return StandardPayload({
            version: 0x01,
            intentType: keccak256("SWAP_V1"),
            data: abi.encode("test swap data"),
            conditionsHash: keccak256("conditions")
        });
    }
    
    function signIntent(CoreIntent memory intent, uint256 privateKey) internal pure returns (bytes memory) {
        bytes32 intentHash = keccak256(abi.encode(
            intent.payloadHash,
            intent.expiry,
            intent.nonce,
            intent.chainId,
            intent.executor,
            intent.maxFee,
            intent.priority
        ));
        
        bytes32 messageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", intentHash));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, messageHash);
        return abi.encodePacked(r, s, v);
    }
    
    function measureExecutionGas(
        CoreIntent memory intent,
        bytes memory signature,
        StandardPayload memory payload
    ) internal returns (uint256) {
        uint256 gasBefore = gasleft();
        vm.prank(solver);
        intentCore.executeIntent(intent, signature, payload);
        return gasBefore - gasleft();
    }
}
```

## Reference Implementation

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract IntentCore is IIntentCore {
    mapping(bytes32 => uint8) public intentStatus;
    mapping(address => uint64) public userNonces;
    
    uint256 constant SOLVER_FEE_BPS = 10;
    uint256 constant MIN_SOLVER_STAKE = 0.1 ether;
    
    modifier nonReentrant() {
        require(!locked, "Reentrant call");
        locked = true;
        _;
        locked = false;
    }
    bool private locked;
    
    function validateIntent(
        CoreIntent calldata intent,
        bytes calldata signature
    ) external view returns (bool valid, string memory reason) {
        if (block.timestamp > intent.expiry) {
            return (false, "Intent expired");
        }
        
        address signer = recoverSigner(intent, signature);
        if (intent.nonce <= userNonces[signer]) {
            return (false, "Invalid nonce");
        }
        
        if (signer == address(0)) {
            return (false, "Invalid signature");
        }
        
        return (true, "");
    }
    
    function executeIntent(
        CoreIntent calldata intent,
        bytes calldata signature,
        StandardPayload calldata payload
    ) external nonReentrant returns (bool success, bytes memory result) {
        (bool valid, string memory reason) = this.validateIntent(intent, signature);
        require(valid, reason);
        
        require(keccak256(abi.encode(payload)) == intent.payloadHash, "Payload mismatch");
        
        address signer = recoverSigner(intent, signature);
        userNonces[signer] = intent.nonce;
        
        if (payload.intentType == SWAP) {
            (success, result) = executeSwap(payload.data);
        } else if (payload.intentType == LIMIT_ORDER) {
            (success, result) = executeLimitOrder(payload.data);
        } else {
            revert("Unsupported intent type");
        }
        
        uint256 fee = calculateFee(intent, result);
        require(fee <= intent.maxFee, "Fee exceeds maximum");
        
        payable(msg.sender).transfer(fee);
        
        bytes32 intentHash = getIntentHash(intent);
        intentStatus[intentHash] = 2; // Executed
        
        emit IntentExecuted(intentHash, msg.sender, gasleft(), fee);
    }
    
    function recoverSigner(
        CoreIntent memory intent,
        bytes memory signature
    ) internal pure returns (address) {
        bytes32 hash = getIntentHash(intent);
        bytes32 messageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
        );
        
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);
        return ecrecover(messageHash, v, r, s);
    }
    
    function getIntentHash(CoreIntent memory intent) internal pure returns (bytes32) {
        return keccak256(abi.encode(
            intent.payloadHash,
            intent.expiry,
            intent.nonce,
            intent.chainId,
            intent.executor,
            intent.maxFee,
            intent.priority
        ));
    }
}
```

### Implementation Requirements

#### Formal Verification

All core contracts MUST:
- Undergo formal verification of critical properties
- Pass property-based testing for invariant preservation
- Include mathematical proofs of economic security
- Provide gas optimization formal analysis

#### Audit Requirements

Before mainnet deployment:
- **Level 1**: Automated security analysis (Slither, Mythril)
- **Level 2**: Professional audit by recognized firm
- **Level 3**: Economic security analysis by MEV research group
- **Level 4**: Formal verification of core properties

#### Cross-Chain Security Standards

Cross-chain modules MUST implement:
- **Finality Verification**: Light client or oracle-based finality proofs
- **Rollback Protection**: Automated rollback for failed cross-chain operations
- **Timeout Mechanisms**: Guaranteed execution or refund within specified timeframe
- **Bridge Security**: Integration only with audited, secure bridge protocols

### Economic Analysis

#### Value Proposition
- **User Savings**: $100+ MEV protection for $2 gas cost
- **Solver Revenue**: 0.1% fee on $10B+ annual DEX volume = $10M opportunity
- **Network Effect**: More solvers → better execution → more users

#### Adoption Incentives
- **Wallets**: Reduced user MEV losses increase satisfaction
- **Protocols**: Competitive execution improves user experience
- **Solvers**: New revenue stream with clear profit potential

### Governance and Upgradability

#### Parameter Governance
The following parameters MAY be adjusted by governance:
- `MIN_SOLVER_STAKE`: Adjust based on MEV value and security needs
- `SOLVER_FEE_BPS`: Balance solver incentives with user costs
- `SLASH_PERCENTAGE`: Optimize deterrent effect

#### Module Registry
New modules MUST:
- Pass formal verification requirements
- Complete professional security audit
- Pay registration fee to prevent spam
- Provide 30-day notice before activation

#### Emergency Procedures
In case of critical vulnerabilities:
- Governance can pause specific modules
- Emergency upgrades require time delay + multi-sig
- Users maintain ability to cancel pending intents

## Security Considerations

### Critical Security Requirements

1. **Key Management**: Implementations MUST provide key rotation and revocation mechanisms
2. **Replay Protection**: Nonces MUST be strictly monotonically increasing per user
3. **Cross-Chain Security**: MUST verify block finality before accepting cross-chain proofs
4. **Privacy**: Encrypted payloads MUST use authenticated encryption (ECIES with secp256k1)
5. **Slashing**: Malicious solvers MUST be penalized through stake slashing

### Attack Vectors and Mitigations

- **MEV Extraction**: Mitigated through privacy module and commit-reveal patterns
- **Griefing**: Mitigated through solver staking and slashing
- **Cross-chain Failures**: Mitigated through timeout and rollback mechanisms
- **Signature Replay**: Prevented through nonce and chain ID validation

### Formal Security Properties

The following properties MUST be formally verified:

1. **Intent Uniqueness**: No two intents can have the same hash
2. **Nonce Monotonicity**: User nonces strictly increase
3. **Fee Bounds**: Actual fees never exceed specified maximum
4. **Expiry Enforcement**: Expired intents cannot be executed
5. **Signature Authenticity**: Only valid signatures from intent creators accepted

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).