---
eip: 8001
title: Secure Intents Framework
description: Minimal framework for cryptographic intents enabling MEV protection and cross-chain coordination
author: Kwame Bryan (@kbryan)
discussions-to: https://ethereum-magicians.org/t/erc-8001-secure-intents-a-cryptographic-framework-for-autonomous-agent-coordination-draft-erc-8001/24989
status: Draft
type: Standards Track
category: ERC
created: 2025-08-02
requires: 712, 2612
---

## Abstract

[ERC-8001](./erc-8001.md) defines a modular framework for cryptographically signed intents with progressive complexity tiers. The core specification requires ~5,000 gas for basic intent validation, with optional modules for privacy (~25,000 gas), cross-chain coordination (~55,000 gas), and batch execution (40% gas savings per additional intent). The framework addresses MEV extraction ($1B+ annually) by enabling users to specify execution conditions while deferring actual execution to a competitive solver network.

## Motivation

Ethereum users lose over $1 billion annually to MEV extraction through sandwich attacks and front-running. Current solutions force users to choose between:

1. **Public mempool exposure**: 1-3% value loss to MEV
2. **Centralized services**: Trust assumptions defeating decentralization
3. **Complex ZK approaches**: 100,000+ gas making them economically unviable

Users need a gas-efficient way to sign intents with execution conditions, allowing specialized solvers to execute them competitively. For a 10,000 dollar trade, spending 2 dollars in gas (5,000 gas at 40 gwei) to save 100+ dollars in MEV extraction provides clear economic value.

Cross-chain fragmentation further complicates user experience. Users cannot easily express desires like "move funds to the chain offering >10% yield" without manual bridge operations and monitoring.

This ERC proposes a modular solution where developers adopt only needed components, enabling immediate deployment for MEV protection while supporting advanced multi-chain strategies.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Core Intent Structure

```solidity
struct CoreIntent {
    bytes32 payloadHash;    // Keccak256 hash of payload
    uint64 expiry;          // Unix timestamp expiration
    uint64 nonce;           // Replay protection
    uint32 chainId;         // EIP-155 chain identifier
    address executor;       // Optional specific executor (0x0 for any)
    uint256 maxFee;         // Maximum fee in wei
    uint8 priority;         // Execution priority (0-255)
}
```

**Intent Hash Calculation**:
```solidity
bytes32 intentHash = keccak256(abi.encode(
    payloadHash,
    expiry,
    nonce,
    chainId,
    executor,
    maxFee,
    priority
));
```

### Payload Specification

The payload (whose hash is stored in `payloadHash`) MUST conform to:

```solidity
struct StandardPayload {
    bytes32 version;        // Payload format version (e.g., 0x01)
    bytes32 intentType;     // Type identifier (SWAP, BRIDGE, etc.)
    bytes data;             // Type-specific encoded data
    bytes32 conditionsHash; // Hash of execution conditions
}
```

**Standard Intent Types**:
```solidity
bytes32 constant SWAP = keccak256("SWAP_V1");
bytes32 constant BRIDGE = keccak256("BRIDGE_V1");
bytes32 constant BATCH = keccak256("BATCH_V1");
bytes32 constant LIMIT_ORDER = keccak256("LIMIT_ORDER_V1");
```

### Signature Schemes

Implementations MUST support ECDSA signatures and SHOULD support [EIP-712](./eip-712.md) structured data signing:

**Standard Signature**:
```solidity
address signer = ecrecover(
    keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", intentHash)),
    v, r, s
);
```

**EIP-712 Signature**:
```solidity
bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    keccak256("IntentProtocol"),
    keccak256("1"),
    block.chainid,
    address(this)
));

bytes32 digest = keccak256(abi.encodePacked(
    "\x19\x01",
    DOMAIN_SEPARATOR,
    keccak256(abi.encode(TYPEHASH, intent))
));
```

### Core Contract Interface

```solidity
interface IIntentCore {
    event IntentCreated(
        bytes32 indexed intentHash,
        address indexed creator,
        uint8 priority,
        uint256 maxFee
    );
    
    event IntentExecuted(
        bytes32 indexed intentHash,
        address indexed executor,
        uint256 gasUsed,
        uint256 feeCharged
    );
    
    event IntentCancelled(
        bytes32 indexed intentHash,
        address indexed creator
    );
    
    function validateIntent(
        CoreIntent calldata intent,
        bytes calldata signature
    ) external view returns (bool valid, string memory reason);
    
    function executeIntent(
        CoreIntent calldata intent,
        bytes calldata signature,
        StandardPayload calldata payload
    ) external returns (bool success, bytes memory result);
    
    function cancelIntent(bytes32 intentHash) external;
    
    function estimateExecution(
        CoreIntent calldata intent,
        StandardPayload calldata payload
    ) external view returns (uint256 gasEstimate, uint256 feeEstimate);
}
```

### Module System

Modules extend core functionality through a standardized interface:

```solidity
interface IIntentModule {
    function processIntent(
        CoreIntent calldata intent,
        StandardPayload calldata payload,
        bytes calldata moduleData
    ) external returns (bool success, bytes memory result);
    
    function validateModule(
        CoreIntent calldata intent,
        bytes calldata moduleData
    ) external view returns (bool valid);
    
    function getModuleGasCost() external view returns (uint256);
}
```

### Privacy Module (Optional)

For MEV-sensitive operations:

```solidity
interface IPrivacyModule is IIntentModule {
    struct PrivateIntent {
        bytes encryptedPayload;     // ECIES encrypted payload
        bytes32 payloadCommitment;  // Hash for verification
        address[] authorizedSolvers; // Whitelisted decryptors
        uint256 revealBlock;        // When intent becomes public
    }
    
    function submitPrivateIntent(
        PrivateIntent calldata intent,
        bytes calldata signature
    ) external returns (bytes32 intentHash);
    
    function revealAndExecute(
        bytes32 intentHash,
        StandardPayload calldata decryptedPayload,
        bytes calldata proof
    ) external returns (bool success);
}
```

### Cross-Chain Module (Optional)

For multi-chain coordination:

```solidity
interface ICrossChainModule is IIntentModule {
    struct CrossChainConfig {
        uint32 targetChainId;
        address targetContract;
        uint256 maxBridgeFee;
        uint256 confirmationBlocks;
        bytes bridgeData;
    }
    
    function initiateCrossChain(
        CoreIntent calldata intent,
        CrossChainConfig calldata config,
        bytes calldata signature
    ) external payable returns (bytes32 messageId);
    
    function completeCrossChain(
        bytes32 messageId,
        bytes calldata proof
    ) external returns (bool success);
}
```

### Batch Module (Optional)

For gas optimization:

```solidity
interface IBatchModule is IIntentModule {
    function executeBatch(
        CoreIntent[] calldata intents,
        bytes[] calldata signatures,
        StandardPayload[] calldata payloads
    ) external returns (bool[] memory results);
    
    // Gas reduction: base_cost + (additional_intents * 0.4 * base_cost)
    function calculateBatchGas(
        uint256 intentCount
    ) external pure returns (uint256 totalGas);
}
```

### Economic Incentives

Implementations SHOULD include solver incentives:

```solidity
interface IIncentives {
    // Solver earns percentage of transaction value
    uint256 constant SOLVER_FEE_BPS = 10; // 0.1%
    
    // Minimum stake to prevent spam
    uint256 constant MIN_SOLVER_STAKE = 0.1 ether;
    
    function stakeSolver() external payable;
    function claimRewards() external returns (uint256);
    function slashSolver(address solver, string calldata reason) external;
}
```

## Rationale

### Modular Architecture

The tiered approach allows progressive adoption:
- **Core Only**: 5,000 gas for simple limit orders
- **Core + Privacy**: 25,000 gas for MEV protection
- **Core + Cross-chain**: 55,000 gas for multi-chain coordination
- **Full Suite**: 70,000 gas for maximum functionality

This design avoids forcing unnecessary complexity on simple use cases while enabling sophisticated strategies.

### Gas Efficiency

**Optimizations**:
- Storing `payloadHash` instead of full payload saves ~200 bytes of storage
- Binary encoding over JSON reduces calldata by 95%
- Batch processing amortizes signature verification costs
- Module lazy-loading prevents unnecessary computation

### Economic Sustainability

The 0.1% solver fee on successful execution creates sustainable incentives while remaining competitive with centralized alternatives. For a 10,000 dollar trade, this represents 10 dollars in solver rewards - sufficient to maintain a competitive solver network while providing 10x value to users through MEV protection.

## Security Considerations

### Critical Security Requirements

1. **Key Management**: Implementations MUST provide key rotation and revocation mechanisms
2. **Replay Protection**: Nonces MUST be strictly monotonically increasing per user
3. **Cross-Chain Security**: MUST verify block finality before accepting cross-chain proofs
4. **Privacy**: Encrypted payloads MUST use authenticated encryption (ECIES with secp256k1)
5. **Slashing**: Malicious solvers MUST be penalized through stake slashing

### Attack Vectors and Mitigations

- **MEV Extraction**: Mitigated through privacy module and commit-reveal patterns
- **Griefing**: Mitigated through solver staking and slashing
- **Cross-chain Failures**: Mitigated through timeout and rollback mechanisms
- **Signature Replay**: Prevented through nonce and chain ID validation

## Backwards Compatibility

This ERC introduces new functionality without breaking existing systems. Integration is opt-in and can coexist with traditional transaction methods.

## Test Cases

### Test 1: Basic Intent Validation
```javascript
const intent = {
    payloadHash: keccak256(payload),
    expiry: Math.floor(Date.now() / 1000) + 3600,
    nonce: 1,
    chainId: 1,
    executor: "0x0000000000000000000000000000000000000000",
    maxFee: parseEther("0.01"),
    priority: 128
};

const signature = await signer.signMessage(intentHash);
const result = await intentCore.validateIntent(intent, signature);
assert(result.valid === true);
```

### Test 2: Fee Limit Enforcement
```javascript
const execution = await intentCore.executeIntent(intent, signature, payload);
assert(execution.feeCharged <= intent.maxFee);
```

### Test 3: Batch Gas Savings
```javascript
const singleGas = await intentCore.estimateGas.executeIntent(intent1);
const batchGas = await batchModule.estimateGas.executeBatch([intent1, intent2]);
assert(batchGas < singleGas * 2); // Verify gas savings
```

## Reference Implementation

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract IntentCore is IIntentCore {
    mapping(bytes32 => uint8) public intentStatus;
    mapping(address => uint64) public userNonces;
    
    uint256 constant SOLVER_FEE_BPS = 10;
    
    modifier nonReentrant() {
        require(!locked, "Reentrant call");
        locked = true;
        _;
        locked = false;
    }
    bool private locked;
    
    function validateIntent(
        CoreIntent calldata intent,
        bytes calldata signature
    ) external view returns (bool valid, string memory reason) {
        // Check expiry
        if (block.timestamp > intent.expiry) {
            return (false, "Intent expired");
        }
        
        // Check nonce
        address signer = recoverSigner(intent, signature);
        if (intent.nonce <= userNonces[signer]) {
            return (false, "Invalid nonce");
        }
        
        // Verify signature
        if (signer == address(0)) {
            return (false, "Invalid signature");
        }
        
        return (true, "");
    }
    
    function executeIntent(
        CoreIntent calldata intent,
        bytes calldata signature,
        StandardPayload calldata payload
    ) external nonReentrant returns (bool success, bytes memory result) {
        // Validate intent
        (bool valid, string memory reason) = this.validateIntent(intent, signature);
        require(valid, reason);
        
        // Verify payload hash
        require(keccak256(abi.encode(payload)) == intent.payloadHash, "Payload mismatch");
        
        // Update nonce
        address signer = recoverSigner(intent, signature);
        userNonces[signer] = intent.nonce;
        
        // Execute based on intent type
        if (payload.intentType == SWAP) {
            (success, result) = executeSwap(payload.data);
        } else if (payload.intentType == LIMIT_ORDER) {
            (success, result) = executeLimitOrder(payload.data);
        } else {
            revert("Unsupported intent type");
        }
        
        // Charge fee
        uint256 fee = calculateFee(intent, result);
        require(fee <= intent.maxFee, "Fee exceeds maximum");
        
        // Transfer fee to solver
        payable(msg.sender).transfer(fee);
        
        // Update status
        bytes32 intentHash = getIntentHash(intent);
        intentStatus[intentHash] = 2; // Executed
        
        emit IntentExecuted(intentHash, msg.sender, gasleft(), fee);
    }
    
    function recoverSigner(
        CoreIntent memory intent,
        bytes memory signature
    ) internal pure returns (address) {
        bytes32 hash = getIntentHash(intent);
        bytes32 messageHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
        );
        
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);
        return ecrecover(messageHash, v, r, s);
    }
    
    function getIntentHash(CoreIntent memory intent) internal pure returns (bytes32) {
        return keccak256(abi.encode(
            intent.payloadHash,
            intent.expiry,
            intent.nonce,
            intent.chainId,
            intent.executor,
            intent.maxFee,
            intent.priority
        ));
    }
}
```

## Security Considerations

**Replay Protection**: Nonce-based system with per-user tracking prevents replay attacks.

**Signature Security**: Support for both eth_sign and EIP-712 provides wallet compatibility while maintaining security.

**Fee Protection**: `maxFee` prevents executors from extracting excessive value.

**Time Bounds**: Expiry timestamps prevent stale intent execution.

**Key Management**: For privacy module, implementations MUST support key rotation and revocation mechanisms.

**Cross-Chain Security**: Implementations MUST verify finality and use fraud-proof capable bridges.



## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).