---
eip: 7722
title: Opaque Token
description: An opaque token designed to securely conceal balance information, enhancing privacy and security for users.
author: Ivica Aračić (@ivica7), SWIAT
discussions-to: https://ethereum-magicians.org/t/erc-7722-opaque-token/20249
status: Draft
type: Standards Track
category: ERC
created: 2024-06-09
---

## Abstract

This ERC proposes a specification for an opaque token with focus on privacy. Privacy is achieved by representing balances as off-chain data encapsulated in hashes, referred to as "baskets". These baskets can be reorganized, transferred, and managed through token functions on-chain.

## Motivation

In [ERC-20](./eip-20.html), balances are transparent on-chain, with privacy being partially ensured through the use of pseudonyms for the sender and receiver. However, this transparency makes it challenging to work with smart contract accounts like Gnosis Safe or [ERC-725](./eip-725.html). Moreover, in regulated environments where KYC (Know Your Customer) procedures are required, revealing an identity would expose the entire portfolio of that identity from the on-chain data.

Without additional privacy mechanisms, the use of pseudonyms can only partially mask the sender's and receiver's identities. The chain of transactions remains visible on-chain, and once a pseudonym is de-masked, significant data and metadata about the holder's portfolio and business activities can be extracted. This transparency complicates the use of smart contract accounts and on-chain identities and claims, as they expose the entire portfolio of the associated identity.

This proposal allows for moving balances to off-chain storage, thereby enabling a good level of privacy, particularly for smart contract accounts.

## Specification

### Baskets

Balances are represented on-chain as hashes of the form:

```
keccak256(abi.encode(salt, tokenId, value))

// where  salt (bytes32)    - random 32bytes to increase the entropy and
//                            make brute-forcing the hash impossible
//        tokenId (bytes32) - a unique tokenId within token's smart contract instance
//        value (uint256)   - the value of the position
```

For the remainder of this document, we refer to these hashes as "baskets" because they conceal the balance information in an opaque manner, similar to how a covered basket hides its contents.

### Token Interface

```
interface OpaqueToken {

  //
  // ROLES
  //
  // operator - ...
  // investor - ...
  // oracle   - ...

  //
  // TYPES
  //

  struct SIGNATURE {
    uint8 v; bytes32 r; bytes32 s;
  }

  struct ORACLECONFIG {
    uint8 minNumberOfOracles; // min. number of oracle signatures required for reorg
    address[] oracles;        // valid oracles
  }

  //
  // EVENTS
  //

  event CreateToken(address initiatedBy, bytes32 tokenId, bytes32 totalSupplyBasket, bytes32 ref);
  event Mint(address initiatedBy, bytes32[] baskets, bytes32 ref);
  event ReorgHolderBaskets(address initiatedBy, bytes32[] basketsIn, bytes32[] basketsOut, bytes32 ref);
  event ReorgSupplyBaskets(address initiatedBy, bytes32[] basketsIn, bytes32[] basketsOut, bytes32 ref);
  event Transfer(address initiatedBy, address receiver, bytes32[] baskets, bytes32 ref);
  event Burn(address initiatedBy, bytes32[] baskets, bytes32 ref);

  //
  // FUNCTIONS
  //

  /**
   * @dev returns the configuration for this token
   */
  function oracleConfig() external view returns (ORACLECONFIG memory);

  /**
   * @dev returns the address of the basket owner
   */
  function owner(bytes32 basket) external view returns (address);

  /**
   * @dev returns the total supply for a `tokenId``
   * All token investors are allowed to fetch this value from the token operator's off-chain storage.
   */
  function totalSupply(bytes32 tokenId) external view returns (bytes32);

  /**
   * @dev returns the operator of the offchain storage data
   */
  function tokenOperator() external view returns (address);
  
  /**
   * @dev Create a new token with the specified `tokenId` and an initial `totalSupplyBasket`. The 
   * `totalSupplyBasket` can be partitioned using {reorgSupplyBaskets} as needed 
   * when calling {mint}. The `ref` parameter can be used freely by the caller for any reference purpose.
   *
   * Allowed Roles: operator
   */
  function createToken(
      bytes32 tokenId,
      bytes32 totalSupplyBasket,
      bytes32 ref
  ) external;

  /**
   * @dev Mints the token by assigning `supplyBaskets` to a `receiver` which becomes the owner of these 
   * baskets. 
   */
  function mint(
      bytes32[] calldata supplyBaskets,
      address receiver,
      bytes32 ref
  ) external;
  
  /**
   * @dev transfers `baskets` to a `receiver` who becomes the new owner of these baskets. 
   */
  function transfer(
      bytes32[] calldata baskets,
      address receiver,
      bytes32 ref
  ) external;

  /**
   * @dev reorganizes a set of holder baskets (`basketsIn`) to a new set (`basketsOut`) having
   * the same value, i.e., the sum of all values from input baskets equals the sum of values
   * in output baskets. In order to ensure the integrity, external oracle service is required that
   * will sign the reorg proposal requested by the basket owner, which is passed as `reorgOracleSignatures`.
   * Depending on the oracle configuration, a minimum set of oracle signatures is required.
   */
  function reorgHolderBaskets(
      SIGNATURE[] calldata reorgOracleSignatures,
      bytes32[] calldata basketsIn,
      bytes32[] calldata basketsOut,
      bytes32 ref
  ) external;

  /**
   * @dev same as {reorgHolderBaskets}, but for the available supply baskets.
   */
  function reorgSupplyBaskets(
      SIGNATURE[] calldata reorgOracleSignatures,
      bytes32[] calldata basketsIn,
      bytes32[] calldata basketsOut,
      bytes32 ref
  ) external;

  /**
   * @dev burns holder's `baskets` and returns them to available supply
   */
  function burn(
      bytes32[] calldata baskets,
      bytes32 ref
  ) external;
}
```

### Off-chain Data Endpoints

The design requires off-chain storage for the details of the baskets. Providing the off-chain storage is in the responsibility of the operator of the token (e.g. issuer, or registrar). The operator MUST ensure the availability of the basket data and will share it on need-to-know basis with all eligible holders. (*TODO: authentication mechanism to be described. PUT/GET have diffferent requirements!*) Moreover, token holders SHOULD store details about their baskets in their own off-chain storage for the case that operator's service is unavailable.

REST API Endpoints for creating and querying baskets:

```
  Endpoint: PUT basket
  Provided by: operator
  PostData: 
  {
    basket: keccak256(abi.encode(salt, tokenId, value)),
    data: {
      salt: <bytes32>,
      tokenId: <bytes32>,
      value: <uint256>
    }
  }

  Endpoint: GET basket?basket-hash=<bytes32>
  Provided by: operator
  Response:
  {
    basket: keccak256(abi.encode(salt, tokenId, value)),
    data: {
      salt: <bytes32>,
      tokenId: <bytes32>,
      value: <uint256>
    }
  }
```

### reorg Endpoint

To ensure the integrity of a reorg and avoid accidental or fraudlent mints or burns, an oracle services is required. Oracles will sign any reorg proposal made by the basket holder where the sum of values in input baskets grouped by tokenId is equal the sum of values of the output baskets grouped by tokenId.

This endpoint requires no further authentication and can be used by anyone without restrictions.

This endpoint is stateless and requires only request data as input. The oracle endpoint must not persist data from the request.

```
Endpoint: POST reorg
Provided by: oracle
PostData:
{
  in: [
    {
      basket: keccak256(abi.encode(salt, tokenId, value)),
      data: {
        salt: <bytes32>,
        tokenId: <bytes32>,
        value: <uint256>
      }
    },
    ...
  ],
  out: [
    {
      basket: keccak256(abi.encode(salt, tokenId, value)),
      data: {
        salt: <bytes32>,
        tokenId: <bytes32>,
        value: <uint256>
      }
    },
    ...
  ]
}

Response: {
    // hash is signed with oracles private key
    // basketsIn and basketsIn are bytes32[]
    signature: sign(keccak256(abi.encode(basketsIn, basketsOut)))
}
```

Example for valid reorg requests (salt and hashes are omitted for better readability):

```
in : (..., token1, 10), (..., token1, 30), (..., token2, 5), (..., token2, 95)
out: (..., token1, 40), (..., token2, 100)

in : (..., token1, 40), (..., token2, 100)
out: (..., token1, 10), (..., token1, 30), (..., token2, 5), (..., token2, 95)
```

### Overlaying Noise (Differential Privacy)

To further strengthen the privacy and obscure who is transacting with whom, an additional layer of noise can be introduced through reorgs and empty transfers. For example, received baskets can be reorg'ed into new baskets to avoid leaking information to the previous owner of the basket. Moreover, it is also possible to have null-value baskets and send these to random receivers in order to make it difficult for observers to find out who is transferring to whom.

Example with reorg and null-value basket transfers:
```
A owns basket-a1{..., value:10}
B owns basket-b1{..., value:5}, basket-b2{..., value:15}, ...
A: transfer basket-a1 to B
B: reorg [basket-a1, basket-b1, basket-b2]
      to [basket-b3{..., value:10}, basket-b4{..., value:10}, basket-b5:{..., value:10},
            basket-b6:{..., value:0}, basket-b7:{..., value:0}]
      where sum of inputs is the sum of outputs
B: transfer basket-b5{value:10} to C
B: transfer basket-b6{value:0}  to D
B: transfer basket-b7{value:0}  to E
```

If B would directly send basket-a1 to C, A would know what C is receiving, however, now that B has reorg'ed the baskets, A can not know anymore what has been sent to C.

Moreover, observers still see who is communicating with whom, but since there is noise introduced, they can not tell which of these transfers are actually transferring real values.

## Rationale

### Breaking the ERC-20 Compatibility

The transparency inherent in ERC-20 tokens presents a significant issue for reusable blockchain identities, such as defined by ERC-725. To address this, we prioritize privacy over ERC-20 compatibility, ensuring that token balances remain confidential. 

### Reorg Oracles

The trusted oracles and the minimum number of required signatures can be configured to achieve the desired level of decentralization.

The basket holder proposes the input and output baskets for the reorg, while the oracles are responsible for verifying that the sums of the values on both sides (input and output) are equal. This system allows for mutual control, ensuring that no single party can manipulate the process.

Fraudlent oracles can be tracked back on-chain, i.e., the system ensures weak-integrity at minimum.

Note that it would also possible to apply Zero-Knowledge Proofs (ZKP) to provide reorg proofs (see "Future Work"), however, we have chosen to use oracles for efficiency and simplicity reasons.

### Off-chain Data Storage

We have chosen the token operator, which in most cases will be the issuer or registrar, as the initial and main source for off-chain data. This is acceptable, since they must know anyway which investor holds which positions to manage lifecycle events on the token. While this approach may not be suitable for every use case within the broader Ethereum ecosystem, it fits well the financial instruments in the regulated environment of the financial industry, which rely on strict KYC and token operation procedures.

### Authentication Mechanism

The data provider will determine whether an entity can query the data based on the basket ownership. To verify the requester's eligibility to access the data, the requester must sign the request using a key associated with the address to which the token is assigned. does not have to be the direct private key of the address, as we also aim to support smart contract accounts. *TODO: authentication mechanism is to be defined yet*

### Future Work: ZKP as alterantive to Oracles

Instead of using oracles in the future, it would also be possible to apply zero knowledge proofs (ZKPs) to verify if the sum of values from input baskets matches the sum of the values of the output baskets.

### Future Work: Unifying fungible and non-fungible 
If reorg function is disabled, we disable the fungibility of the token and it becomes a NFT.

## Backwards Compatibility

No backward compatibility issues found.

## Reference Implementation

To be included as inline code or in `../assets/eip-####/`.

## Security Considerations

To be discussed.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
