---
eip: 8063
title: Groups - Membership Tokens
description: ERC-20 tokens representing group membership with threshold-based access control.
author: Cheng Qian (@jamesavechives), Sam Wilson (@SamWilsn)
discussions-to: https://ethereum-magicians.org/t/erc-8063-groups-multi-member-onchain-containers-for-shared-resources/25999
status: Draft
type: Standards Track
category: ERC
created: 2025-10-28
requires: 20, 165, 5679
---

## Abstract

This proposal defines a "Group" as an [ERC-20](./eip-20.md) token extended with [ERC-5679](./eip-5679.md) for minting and burning, where token balance represents membership level. Unlike binary membership (member/non-member), this standard supports threshold-based membership: holding more tokens grants higher membership tiers or privileges. By building on ERC-20, Groups inherit full compatibility with existing wallets, explorers, and tooling.

## Motivation

Many applications need addressable groups of accounts with controlled membership and tiered access:
- **DAOs**: Voting power proportional to token holdings
- **Loyalty programs**: Bronze/Silver/Gold tiers based on token balance
- **Access control**: Different features unlocked at different balance thresholds
- **Partner networks**: Minimum token requirements for partnership benefits

Rather than define a new primitive, this standard builds on ERC-20 for maximum compatibility. The key insight is that **token balance naturally represents membership level**:
- `balanceOf(account) == 0` → Not a member
- `balanceOf(account) >= threshold` → Member at that tier

This approach provides:
- **Instant tooling compatibility**: Wallets, explorers, and portfolio trackers work out of the box
- **Tiered membership**: Different balance thresholds unlock different privileges
- **Transferable membership**: Standard ERC-20 transfers allow membership trading/delegation
- **No new primitives**: Pure ERC-20 + ERC-5679, minimal new interface surface

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Requirements

A compliant Group contract:

1. **MUST** implement [ERC-20](./eip-20.md)
2. **MUST** implement [ERC-5679](./eip-5679.md) (`IERC5679Ext20`) for minting and burning
3. **MUST** implement [ERC-165](./eip-165.md)
4. **MUST** implement the `IERC8063` interface defined below

### Membership Semantics

Token balance represents membership level:
- `balanceOf(account) == 0` → Account is **not** a member
- `balanceOf(account) > 0` → Account **is** a member
- `balanceOf(account) >= threshold` → Account qualifies for that membership tier

Applications define their own thresholds. For example:
- Basic membership: `balanceOf(account) >= 1`
- Silver tier: `balanceOf(account) >= 100`
- Gold tier: `balanceOf(account) >= 500`
- Platinum tier: `balanceOf(account) >= 1000`

### Interface

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

/// @title IERC8063 — Membership token with threshold-based access control
/// @notice Extends ERC-20 + ERC-5679 with membership semantics and access control introspection
interface IERC8063 {
    /// @notice Returns true if `account` holds at least `threshold` tokens
    /// @param account The address to check
    /// @param threshold Minimum balance required for membership at this tier
    function isMember(address account, uint256 threshold) external view returns (bool);

    /// @notice Returns true if `operator` is permitted to mint tokens
    function canMint(address operator) external view returns (bool);

    /// @notice Returns true if `operator` is permitted to burn `from`'s tokens
    function canBurn(address operator, address from) external view returns (bool);
}
```

### Semantics

#### Membership Check

- `isMember(account, threshold)` MUST return `true` if and only if `balanceOf(account) >= threshold`.
- `isMember(account, 0)` MUST return `true` for any account (including zero balance), as all accounts trivially meet a zero threshold.
- For basic membership (any non-zero balance), use `isMember(account, 1)`.

#### ERC-20 Operations

All standard ERC-20 operations work normally:
- `transfer(to, amount)` transfers membership tokens (and potentially membership tier)
- `approve` and `transferFrom` enable delegated transfers
- `decimals()` MAY return any value; membership thresholds are defined in the token's smallest unit

#### ERC-5679 Operations (Mint/Burn)

- `mint(to, amount, data)` MUST revert if `canMint(msg.sender)` returns `false`. Otherwise, increases `to`'s balance and `totalSupply`.
- `burn(from, amount, data)` MUST revert if `canBurn(msg.sender, from)` returns `false`. Otherwise, decreases `from`'s balance and `totalSupply`.

#### Access Control Introspection

- `canMint(operator)` MUST return `true` if and only if `operator` is permitted to call `mint` successfully.
- `canBurn(operator, from)` MUST return `true` if and only if `operator` is permitted to burn `from`'s tokens.

Access control policy is implementation-defined. Examples:
- **Admin-only**: `canMint` returns true only for admin address
- **Open minting**: `canMint` always returns true (anyone can join)
- **Self-burn only**: `canBurn(op, from)` returns `op == from`
- **Governance**: `canMint`/`canBurn` check voting or multisig state

### ERC-165 Introspection

- `supportsInterface(0x36372b07)` (ERC-20) MUST return `true`
- `supportsInterface(0xd0017968)` (ERC-5679 for ERC-20) MUST return `true`
- `supportsInterface(IERC8063_ID)` MUST return `true`

### Deployment Model

Following the [ERC-20](./eip-20.md) pattern, each group is its own contract deployment:

- **Group identity**: A group is uniquely identified by its contract address.
- **Deployment**: To create a group, deploy a contract implementing [ERC-20](./eip-20.md), [ERC-5679](./eip-5679.md), and this standard.
- **Discovery**: Applications can discover groups through Transfer events, registries, or direct address references.
- **Naming**: `name()` and `symbol()` follow standard ERC-20 conventions.

### Optional Aliases

Implementations MAY expose convenience functions that wrap standard operations:

```solidity
/// @notice Optional convenience interface
interface IERC8063Aliases {
    /// @notice Returns current member count (accounts with balance > 0)
    /// @dev This may be expensive to compute; consider tracking separately
    function getMemberCount() external view returns (uint256);

    /// @notice Adds tokens to `account` — wraps mint(account, amount, "")
    function addMember(address account, uint256 amount) external;

    /// @notice Burns caller's tokens — wraps burn(msg.sender, amount, "")
    function leaveGroup(uint256 amount) external;

    /// @notice Burns all of caller's tokens — wraps burn(msg.sender, balanceOf(msg.sender), "")
    function leaveGroupFully() external;
}
```

### Optional Extensions

#### Ownership (via [ERC-173](./eip-173.md))

Implementations that want a single-owner governance model SHOULD use [ERC-173](./eip-173.md) or [ERC-8023](./eip-8023.md). The owner would typically be the only address where `canMint` returns `true`.

#### Tiered Benefits

Applications can define membership tiers externally:

```solidity
// Example: Partner contract checking membership tiers
contract PartnerBenefits {
    IERC8063 public membershipToken;
    
    uint256 public constant BRONZE_THRESHOLD = 100 * 10**18;
    uint256 public constant SILVER_THRESHOLD = 500 * 10**18;
    uint256 public constant GOLD_THRESHOLD = 1000 * 10**18;
    
    function getDiscount(address user) external view returns (uint256) {
        if (membershipToken.isMember(user, GOLD_THRESHOLD)) return 30; // 30% off
        if (membershipToken.isMember(user, SILVER_THRESHOLD)) return 20; // 20% off
        if (membershipToken.isMember(user, BRONZE_THRESHOLD)) return 10; // 10% off
        return 0;
    }
}
```

#### Capped Membership (Balance ≤ 1)

For use cases requiring binary membership (member/non-member with no tiers), implementations MAY enforce `balanceOf(account) <= 1` for all accounts. This is a stricter subset of this standard.

## Rationale

- **ERC-20 foundation**: Building on ERC-20 provides instant compatibility with wallets, explorers, DEXs, and governance tools.
- **ERC-5679 for lifecycle**: Standardized mint/burn avoids custom function signatures for adding/removing members.
- **Threshold-based membership**: More flexible than binary membership; supports tiered access, loyalty programs, and proportional voting naturally.
- **No balance constraint**: Unlike capping balance at 1, allowing any balance enables richer membership semantics while remaining simpler to implement.
- **Access control introspection**: `canMint`/`canBurn` enable external contracts to check permissions before attempting operations.
- **Minimal new interface**: Only `isMember`, `canMint`, and `canBurn` are added beyond ERC-20 + ERC-5679.

## Backwards Compatibility

This standard is fully backwards compatible with:
- [ERC-20](./eip-20.md) — all ERC-20 methods work as expected
- [ERC-5679](./eip-5679.md) — standard mint/burn interface
- [ERC-165](./eip-165.md) — interface detection

Existing ERC-20 tooling will recognize Group contracts as tokens. Applications interpret token balance as membership level.

## Reference Implementation

Reference contracts are provided in the `assets/` directory:

- [`IERC8063.sol`](../assets/eip-8063/IERC8063.sol) — Interface definitions
- [`ERC8063.sol`](../assets/eip-8063/ERC8063.sol) — Reference implementation

## Security Considerations

- **Mint access control**: Carefully design who can mint. Unrestricted minting allows anyone to gain membership.
- **Burn access control**: Consider whether members can be forcibly removed and the implications for access rights they may have relied on.
- **Threshold manipulation**: If thresholds are stored onchain, ensure they cannot be manipulated by unauthorized parties.
- **Transfer implications**: Token transfers change membership. Consider whether this is desirable for your use case.
- **Approval risks**: Standard ERC-20 approval risks apply. Approving another address grants them ability to transfer your membership tokens.
- **Decimal handling**: Ensure thresholds account for the token's decimals. A threshold of "100" means different things for tokens with 0 vs 18 decimals.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
