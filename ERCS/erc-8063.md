---
eip: 8063
title: Groups - Membership Tokens
description: ERC-20 tokens with balance capped at one, representing group membership.
author: James Savechives (@jamesavechives)
discussions-to: https://ethereum-magicians.org/t/erc-8063-groups-multi-member-onchain-containers-for-shared-resources/25999
status: Draft
type: Standards Track
category: ERC
created: 2025-10-28
requires: 20, 165, 5679
---

## Abstract

This proposal defines a "Group" as an [ERC-20](./eip-20.md) token with balance constrained to `{0, 1}`, extended with [ERC-5679](./eip-5679.md) for minting (adding members) and burning (removing members), plus access control introspection. A balance of `1` indicates membership; `0` indicates non-membership. By building on ERC-20, Groups inherit full compatibility with existing wallets, explorers, and tooling.

## Motivation

Many coordination use cases—project teams, DAOs, game guilds, access cohorts—need an addressable set of accounts with controlled join/leave semantics. Rather than define a new primitive and layer ERC-20 compatibility on top, this standard takes the opposite approach: start with ERC-20 for maximum compatibility, constrain balances to represent membership, and add access control introspection for composability.

This approach provides:
- **Instant tooling compatibility**: Wallets, explorers, and portfolio trackers work out of the box
- **Established interfaces**: `transfer`, `approve`, `transferFrom` provide consent-based membership transfers
- **Minimal new surface area**: Only access control introspection is added beyond ERC-20 + ERC-5679

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Requirements

A compliant Group contract:

1. **MUST** implement [ERC-20](./eip-20.md)
2. **MUST** implement [ERC-5679](./eip-5679.md) (`IERC5679Ext20`) for minting and burning
3. **MUST** implement [ERC-165](./eip-165.md)
4. **MUST** implement the `IERC8063` interface defined below

### Balance Invariant

All operations MUST preserve the following invariant:

> For any address `a`, `balanceOf(a)` MUST be either `0` or `1`.

- `balanceOf(a) == 1` means `a` is a member
- `balanceOf(a) == 0` means `a` is not a member

### Interface

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

/// @title IERC8063 — Access control introspection for membership tokens
/// @notice Extends ERC-20 + ERC-5679 with permission checks for minting and burning
interface IERC8063 {
    /// @notice Returns true if `operator` is permitted to mint (add members)
    function canMint(address operator) external view returns (bool);

    /// @notice Returns true if `operator` is permitted to burn `from`'s membership
    function canBurn(address operator, address from) external view returns (bool);
}
```

The ERC-165 interface ID for `IERC8063` is `0x______` (TBD).

### Semantics

#### ERC-20 Constraints

- `decimals()` MUST return `0`.
- `transfer(to, amount)` MUST revert if `amount != 1`. MUST revert if `balanceOf(to) == 1` (already a member). Otherwise, transfers membership from caller to `to`.
- `transferFrom(from, to, amount)` MUST revert if `amount != 1`. MUST revert if `balanceOf(to) == 1`. Otherwise, transfers membership from `from` to `to` (requires prior approval).
- `approve` and `allowance` operate normally, enabling consent-based membership transfers.

#### ERC-5679 Semantics (Mint/Burn)

- `mint(to, amount, data)` MUST revert if `amount != 1`. MUST revert if `canMint(msg.sender)` returns `false`. MUST revert if `balanceOf(to) == 1` (already a member). Otherwise, sets `balanceOf(to) = 1`, increments `totalSupply`, and emits `Transfer(address(0), to, 1)`.
- `burn(from, amount, data)` MUST revert if `amount != 1`. MUST revert if `canBurn(msg.sender, from)` returns `false`. MUST revert if `balanceOf(from) == 0` (not a member). Otherwise, sets `balanceOf(from) = 0`, decrements `totalSupply`, and emits `Transfer(from, address(0), 1)`.

#### Access Control Introspection

- `canMint(operator)` MUST return `true` if and only if `operator` is permitted to call `mint` successfully (ignoring target-specific conditions like "already a member").
- `canBurn(operator, from)` MUST return `true` if and only if `operator` is permitted to burn `from`'s membership.

Access control policy is implementation-defined. Examples:
- **Admin-only**: `canMint` returns true only for admin address
- **Open membership**: `canMint` always returns true
- **Self-burn only**: `canBurn(op, from)` returns `op == from`
- **Governance**: `canMint`/`canBurn` check voting state

#### Voluntary Exit

Members can always exit by:
- Calling `burn(msg.sender, 1, "")` if `canBurn(msg.sender, msg.sender)` returns true, OR
- Calling `transfer(to, 1)` to transfer membership to another address

Implementations that want to allow self-exit SHOULD have `canBurn(addr, addr)` return `true` for all members.

### Group-Friendly Aliases (Optional)

Implementations MAY expose friendlier function names that wrap the underlying ERC-20/ERC-5679 operations:

```solidity
/// @notice Optional convenience interface wrapping ERC-20 + ERC-5679
interface IERC8063Aliases {
    /// @notice Returns true if `account` is a member (balanceOf >= 1)
    function isMember(address account) external view returns (bool);

    /// @notice Returns current member count (totalSupply)
    function getMemberCount() external view returns (uint256);

    /// @notice Returns the group name (ERC-20 name)
    function name() external view returns (string memory);

    /// @notice Adds `account` as a member — wraps mint(account, 1, "")
    function addMember(address account) external;

    /// @notice Removes `account` from membership — wraps burn(account, 1, "")
    function removeMember(address account) external;

    /// @notice Caller voluntarily leaves — wraps burn(msg.sender, 1, "")
    function leaveGroup() external;

    /// @notice Transfer membership to another address — wraps transfer(to, 1)
    function transferMembership(address to) external;
}
```

If implemented, these MUST behave as specified:
- `isMember(a)` ≡ `balanceOf(a) >= 1`
- `getMemberCount()` ≡ `totalSupply()`
- `addMember(a)` ≡ `mint(a, 1, "")`
- `removeMember(a)` ≡ `burn(a, 1, "")`
- `leaveGroup()` ≡ `burn(msg.sender, 1, "")`
- `transferMembership(to)` ≡ `transfer(to, 1)`

### ERC-165 Introspection

- `supportsInterface(0x36372b07)` (ERC-20) MUST return `true`
- `supportsInterface(0xd0017968)` (ERC-5679 for ERC-20) MUST return `true`
- `supportsInterface(IERC8063_ID)` MUST return `true`
- If aliases are implemented, `supportsInterface(IERC8063Aliases_ID)` SHOULD return `true`

### Deployment Model

Following the [ERC-20](./eip-20.md) pattern, each group is its own contract deployment:

- **Group identity**: A group is uniquely identified by its contract address.
- **Deployment**: To create a group, deploy a contract implementing ERC-20, ERC-5679, and IERC8063. Initial members are determined by the implementation.
- **Discovery**: Applications can discover groups through Transfer events, registries, or direct address references.
- **Naming**: `name()` and `symbol()` follow standard ERC-20 conventions.

### Optional Extensions

#### Ownership (via ERC-173)

Implementations that want a single-owner governance model SHOULD use [ERC-173](./eip-173.md) or [ERC-8023](./eip-8023.md). The owner would typically be the only address where `canMint` returns `true`.

#### Consent-Based Membership

ERC-20's `approve`/`transferFrom` already provides consent-based transfers:
1. Alice (member) calls `approve(Bob, 1)`
2. Bob calls `transferFrom(Alice, Bob, 1)`
3. Membership transfers from Alice to Bob

This can also be used for membership offers:
1. Admin mints to escrow contract
2. Recipient claims from escrow via `transferFrom`

## Rationale

- **ERC-20 foundation**: Building on ERC-20 provides instant compatibility with wallets, explorers, DEXs (for membership markets), and governance tools.
- **ERC-5679 for lifecycle**: Standardized mint/burn avoids custom function signatures for adding/removing members.
- **Access control introspection**: `canMint`/`canBurn` enable external contracts to check permissions before attempting operations, making the interface valuable to standardize.
- **Balance ≤ 1 invariant**: Membership is binary; fractional membership doesn't make sense for most coordination use cases.
- **Optional aliases**: Friendly names like `addMember` improve readability without requiring them in the core interface.

## Backwards Compatibility

This standard is fully backwards compatible with:
- [ERC-20](./eip-20.md) — all ERC-20 methods work as expected (with amount constraints)
- [ERC-5679](./eip-5679.md) — standard mint/burn interface
- [ERC-165](./eip-165.md) — interface detection

Existing ERC-20 tooling will recognize Group contracts as tokens. The `decimals() = 0` and balance ≤ 1 constraints are enforced by the contract, not the interface.

## Reference Implementation

Reference contracts are provided in the `assets/` directory:

- [`IERC8063.sol`](../assets/erc-8063/IERC8063.sol) — Interface definitions
- [`ERC8063.sol`](../assets/erc-8063/ERC8063.sol) — Reference implementation

## Security Considerations

- **Mint access control**: Carefully design who can mint. Unrestricted minting allows anyone to join.
- **Burn access control**: Consider whether members can be forcibly removed and the implications for access rights they may have relied on.
- **Balance invariant**: All operations must preserve balance ≤ 1. Implementations should use checks-effects-interactions pattern.
- **Transfer restrictions**: Consider whether all members should be able to transfer, or if some (e.g., admins) should be restricted.
- **Approval risks**: Standard ERC-20 approval risks apply. Members approving others grant them the ability to take their membership.
- **Last member**: Implementations SHOULD consider whether to prevent the last member from leaving/being burned.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
