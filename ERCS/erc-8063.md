---
eip: 8063
title: Group Standard
description: Onchain groups with membership, invitations, and shared metadata.
author: James Savechives (@jamesavechives)
discussions-to: https://ethereum-magicians.org/t/erc-8063-groups-multi-member-onchain-containers-for-shared-resources/25999
status: Draft
type: Standards Track
category: ERC
created: 2025-10-28
requires: 165
---

## Abstract

This proposal specifies a general-purpose "Group" primitive as a first-class, onchain object. A Group is identified by a `groupId` and has an owner, an extensible set of members, and optional metadata. The standard defines a minimal interface for creating groups, inviting and joining members, and membership introspection. Unlike token standards (e.g., [ERC-20](./eip-20.md)/[ERC-721](./eip-721.md)) that model units of transferable ownership, Groups model multi-party membership and coordination. The goal is to enable interoperable social, organizational, and collaborative primitives.

## Motivation

Tokens typically model ownership and transfer. Many applications instead need an addressable set of accounts with controlled join/leave semantics and shared state—e.g., project teams, DAOs, game parties, channels, or access cohorts. While [ERC-7743](./eip-7743.md) (MO-NFT) explores multi-ownership for a single token, it still anchors the abstraction to token semantics. Groups generalize this into a token-agnostic container where members can be added over time, without implying transfer or unitized ownership. External resources (tokens, NFTs, etc.) can be associated with groups through their own contracts, just as they would with any EOA or contract address.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Contracts that implement this standard MUST support [ERC-165](./eip-165.md).

### Interface

```solidity
/// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

/// @title IERC8063 — Minimal interface for onchain groups
/// @notice A group is a container with an owner and members
interface IERC8063 is IERC165 {
    /// @dev Emitted when a new group is created
    event GroupCreated(uint256 indexed groupId, address indexed owner, string name, string metadataURI);

    /// @dev Emitted when the owner invites an account
    event MemberInvited(uint256 indexed groupId, address indexed inviter, address indexed invitee);

    /// @dev Emitted when an invited account accepts and becomes a member
    event MemberJoined(uint256 indexed groupId, address indexed account);

    /// @dev Emitted when a member is removed (cannot remove the owner)
    event MemberRemoved(uint256 indexed groupId, address indexed account, address indexed by);

    /// @notice Create a new group; caller becomes owner and initial member
    /// @param name Optional human-readable group name
    /// @param metadataURI Optional offchain metadata (e.g., JSON document)
    /// @return groupId Newly created group identifier
    function createGroup(string calldata name, string calldata metadataURI) external returns (uint256 groupId);

    /// @notice Returns the owner of a group
    function groupOwner(uint256 groupId) external view returns (address);

    /// @notice Returns the human-readable name of the group (may be empty)
    function groupName(uint256 groupId) external view returns (string memory);

    /// @notice Returns true if `account` is a member of the group
    function isMember(uint256 groupId, address account) external view returns (bool);

    /// @notice Returns current number of members (including owner)
    function getMemberCount(uint256 groupId) external view returns (uint256);

    /// @notice Owner invites an account to join the group
    function inviteMember(uint256 groupId, address account) external;

    /// @notice Invitee accepts an outstanding invite and becomes a member
    function acceptInvite(uint256 groupId) external;

    /// @notice Owner removes a member (owner cannot be removed)
    function removeMember(uint256 groupId, address account) external;
}
```

### Semantics

- Group creation: `createGroup` MUST assign the caller as the group owner and an initial member, emit `GroupCreated`, and return a non-zero `groupId` unique within the contract.
- Invitations: Only the group owner MAY call `inviteMember`. Implementations MUST record an outstanding invitation for `account` and emit `MemberInvited`.
- Joining: `acceptInvite` MUST succeed only for invited accounts, add them as members exactly once, and emit `MemberJoined`.
- Removal: Only the owner MAY call `removeMember`. Implementations MUST NOT allow removing the owner.
- Introspection: `supportsInterface` MUST return true for `type(IERC165).interfaceId` and for `type(IERC8063).interfaceId`.

### Identifier model and naming

- Single-group deployments: For implementations that deploy exactly one group per contract, the canonical group identifier SHOULD be the contract address (`address(this)`). In such cases, interfaces MAY omit the `groupId` parameter by using a thin wrapper or adapter while preserving ERC-165 detection for interoperability.
- Multi-group containers: For contracts that hold multiple groups, `groupId` is a `uint256` unique within the contract. The canonical global identifier becomes the pair `(contract address, groupId)`.
- Naming: Implementations SHOULD provide a human-readable name at creation via `createGroup(name, ...)` and expose it via `groupName(groupId)`. Empty names are permitted.

### Optional extensions (non-normative)

- Admin roles: Owner-delegated administrators that can invite/remove members.
- Signature-based invites: Offchain signed invites verifiable onchain for gasless flows.
- Open groups: Opt-in groups without invitations where `acceptInvite` is implicitly allowed for any account.
- Resource associations: External contracts (e.g., [ERC-20](./eip-20.md), [ERC-721](./eip-721.md)) MAY track group ownership or membership-based access using the group's contract address and `groupId`.

## Rationale

- Token-agnostic: Separates membership from asset ownership/transfer semantics, suitable for social and coordination use cases.
- Minimal surface: Creation, invite/join, and membership queries are sufficient for broad interoperability while allowing richer policies via extensions.
- External resource model: Resources (tokens, NFTs) can be associated with groups externally, just as they would with any address, avoiding tight coupling and enabling flexible composition.
- Relationship to [ERC-7743](./eip-7743.md): MO-NFT models multi-ownership of a single token; Groups model multi-membership of a container. Implementations MAY associate a Group with tokens, but the standard does not require token interfaces.

## Backwards Compatibility

No known backward compatibility issues. This is a new interface with [ERC-165](./eip-165.md) detection.

## Reference Implementation

Reference contracts are provided in the `assets/` directory:

- `IERC8063.sol` — Interface definition
- `ERC8063.sol` — Minimal reference implementation

## Security Considerations

- Membership griefing: Implementations SHOULD bound per-tx iterations and avoid unbounded member enumeration onchain.
- Invite spoofing: Signature-based invites MUST protect against replay and domain separation if used. The baseline owner-called invites avoid this.
- Access control: Clearly document who can invite and remove members; conservative defaults recommend owner-only operations.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).


