---
eip: 8063
title: Groups — Multi-Member Containers
description: Onchain groups with membership, invitations, and shared resource metadata.
author: James Savechives (@jamesavechives)
discussions-to: https://ethereum-magicians.org/t/groups-multi-member-onchain-containers-for-shared-resources/25999
status: Draft
type: Standards Track
category: ERC
created: 2025-10-28
requires: 165
---

## Abstract

This proposal specifies a general-purpose "Group" primitive as a first-class, onchain object. A Group is identified by a `groupId` and has an owner, an extensible set of members, and arbitrary shared resources represented as key/value metadata. The standard defines a minimal interface for creating groups, inviting and joining members, membership introspection, and resource updates. Unlike token standards (e.g., [ERC-20](./eip-20.md)/[ERC-721](./eip-721.md)) that model units of transferable ownership, Groups model multi-party membership and coordination. The goal is to enable interoperable social, organizational, and collaborative primitives.

## Motivation

Tokens typically model ownership and transfer. Many applications instead need an addressable set of accounts with controlled join/leave semantics and shared state—e.g., project teams, DAOs, game parties, channels, or access cohorts. While [ERC-7743](./eip-7743.md) (MO-NFT) explores multi-ownership for a single token, it still anchors the abstraction to token semantics. Groups generalize this into a token-agnostic container where members can be added over time and share resources, without implying transfer or unitized ownership.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Contracts that implement this standard MUST support [ERC-165](./eip-165.md).

### Interface

```solidity
/// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

/// @title IERCGroup — Minimal interface for onchain groups
/// @notice A group is a container with an owner, members, and shared resources
interface IERCGroup is IERC165 {
    /// @dev Emitted when a new group is created
    event GroupCreated(uint256 indexed groupId, address indexed owner, string metadataURI);

    /// @dev Emitted when the owner invites an account
    event MemberInvited(uint256 indexed groupId, address indexed inviter, address indexed invitee);

    /// @dev Emitted when an invited account accepts and becomes a member
    event MemberJoined(uint256 indexed groupId, address indexed account);

    /// @dev Emitted when a member is removed (cannot remove the owner)
    event MemberRemoved(uint256 indexed groupId, address indexed account, address indexed by);

    /// @dev Emitted when a resource key is set/updated/cleared (empty value means delete)
    event ResourceUpdated(uint256 indexed groupId, bytes32 indexed key, string value, address indexed by);

    /// @notice Create a new group; caller becomes owner and initial member
    /// @param metadataURI Optional offchain metadata (e.g., JSON document)
    /// @return groupId Newly created group identifier
    function createGroup(string calldata metadataURI) external returns (uint256 groupId);

    /// @notice Returns the owner of a group
    function groupOwner(uint256 groupId) external view returns (address);

    /// @notice Returns true if `account` is a member of the group
    function isMember(uint256 groupId, address account) external view returns (bool);

    /// @notice Returns current number of members (including owner)
    function getMemberCount(uint256 groupId) external view returns (uint256);

    /// @notice Owner invites an account to join the group
    function inviteMember(uint256 groupId, address account) external;

    /// @notice Invitee accepts an outstanding invite and becomes a member
    function acceptInvite(uint256 groupId) external;

    /// @notice Owner removes a member (owner cannot be removed)
    function removeMember(uint256 groupId, address account) external;

    /// @notice Set or clear a resource value for the group
    /// @dev Setting to an empty string SHOULD be treated as deletion
    function setResource(uint256 groupId, bytes32 key, string calldata value) external;

    /// @notice Read a resource value for the group (empty string if unset)
    function getResource(uint256 groupId, bytes32 key) external view returns (string memory);
}
```

### Semantics

- Group creation: `createGroup` MUST assign the caller as the group owner and an initial member, emit `GroupCreated`, and return a non-zero `groupId` unique within the contract.
- Invitations: Only the group owner MAY call `inviteMember`. Implementations MUST record an outstanding invitation for `account` and emit `MemberInvited`.
- Joining: `acceptInvite` MUST succeed only for invited accounts, add them as members exactly once, and emit `MemberJoined`.
- Removal: Only the owner MAY call `removeMember`. Implementations MUST NOT allow removing the owner.
- Resources: `setResource` MUST update a group-scoped key/value string resource and emit `ResourceUpdated`. Implementations MAY restrict who can update resources. A simple baseline allows any member to set resources; alternative policies are acceptable if clearly documented.
- Introspection: `supportsInterface` MUST return true for `type(IERC165).interfaceId` and for `type(IERCGroup).interfaceId`.

### Optional extensions (non-normative)

- Admin roles: Owner-delegated administrators that can invite/remove members and manage resources.
- Signature-based invites: Offchain signed invites verifiable onchain for gasless flows.
- Open groups: Opt-in groups without invitations where `acceptInvite` is implicitly allowed for any account.

## Rationale

- Token-agnostic: Separates membership from asset ownership/transfer semantics, suitable for social and coordination use cases.
- Minimal surface: Creation, invite/join, membership queries, and resource metadata are sufficient for broad interoperability while allowing richer policies via extensions.
- Relationship to [ERC-7743](./eip-7743.md): MO-NFT models multi-ownership of a single token; Groups model multi-membership of a container. Implementations MAY associate a Group with tokens, but the standard does not require token interfaces.

## Backwards Compatibility

No known backward compatibility issues. This is a new interface with [ERC-165](./eip-165.md) detection.

## Reference Implementation

Reference contracts are provided in this repository:

- `assets/eip-groups/IERCGroup.sol`
- `assets/eip-groups/GroupContainer.sol`

## Security Considerations

- Membership griefing: Implementations SHOULD bound per-tx iterations and avoid unbounded member enumeration onchain.
- Invite spoofing: Signature-based invites MUST protect against replay and domain separation if used. The baseline owner-called invites avoid this.
- Resource integrity: If resources drive authorization offchain, rely on event logs and content-addressed URIs (e.g., IPFS/Arweave) to prevent tampering.
- Access control: Clearly document who can set resources; conservative defaults recommend owner- or member-only writes.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).


