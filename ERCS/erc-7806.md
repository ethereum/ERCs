---
eip: 7806
title: Minimal intent-centric EOA smart account
description: Minimal effort intent-centric interfaces for EOA account abstraction
author: hellohanchen (@hellohanchen)
discussions-to: https://ethereum-magicians.org/t/erc-7806-minimal-intent-centric-eoa-smart-account/21565
status: Draft
type: Standards Track
category: ERC
created: 2024-11-02
requires: 7702
---

## Abstract

This proposal defines interfaces to build intent-centric smart accounts. EOA account can delegate contract code to the
smart account implementation and sign intents to allow solvers (and relayers) to execute on behalf of account owner.

## Motivation

AA (Account abstraction) is a hot topic in blockchain industry because it gives accounts programmability features,
including but not limited to:

* **BatchExecution**
* **GasSponsorship**
* **AccessControl**

With [ERC-4337](./eip-4337.md), engineers built a permissionless AA standard. While unlocking enormous number of useful
features, ERC-4337 still has several limitations:

* **Complexity**: Requiring multiple components: Account, EntryPoint, Paymaster, Bundler, and
  Plugins ([ERC-6900](./eip-6900.md), [ERC-7579](./eip-7579.md). Services like bundler requires high engineer skills and
  heavy overhead work to run and maintain.
* **Compatibility**: Compatibility issue between components forces developers to upgrade multiple smart contracts within
  one version update, also divides the ecosystem.
* **Cost**: `UserOperation` processing costs high gas units.
* **Trust**: Although this standard is designed to be permissionless, there are still centralized processes. Paymaster
  is usually a centralized service because it needs to either trust the account owner to repay the sponsored gas.
  Bundlers are running on MEV based and accounts need to trust bundler providers to include their user operations in the
  transaction.

[ERC-7521](./eip-7521.md) discusses an SCA solution with intent-centric design. It enables solvers to fulfill account
owners' intents by acting "on behalf of" account owners. ERC-7521 allows arbitrary intents and verification logics while
trying to keep the whole solution forward-compatible.

With `SET_CODE_TX_TYPE=0x04` allowing EOA accounts to set contract code, EOA accounts will gain similar programmability
as SCA (Smart Contact Account). A new standard, that provides EOA with highly-demanded AA features while potentially
resolving some of the above challenges, will help bring in seamless user experience and drive mass adoptions.

The above EIPs inspired the author to build an intent-centric standard for EOA smart accounts.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### UserIntent bytes

Each intent is a packed data structure containing sufficient information about operations the account owner wants to
execute.

| Field          | Type      | Description                                                                                                                                              |
|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sender`       | `address` | The wallet making the intent                                                                                                                             |
| `standard`     | `address` | The `IStandard` implementation to validate and parse this `UserIntent`                                                                                   |
| `header`       | `bytes`   | The metadata of this `UserIntent`, used by `standard`, using `bytes` type to keep flexibility                                                            |
| `instructions` | `bytes[]` | The detailed content of this `UserIntent`, used by `standard` to determine the `Operation`s need to be executing, using `bytes` type to keep flexibility |
| `signatures`   | `bytes[]` | Validatable signatures, used by `standard`                                                                                                               |

But using `bytes[]` on functional interface is heavy especially when multiple intents are compound together. Therefore,
the "UserIntent" object is designed to be a pack-encoded `bytes calldata userIntent` contains the above information

| Section                         | Value Type | Description                                                     |
|---------------------------------|------------|-----------------------------------------------------------------|
| userIntent[0:20]                | `address`  | sender                                                          |
| userIntent[20:40]               | `address`  | standard                                                        |
| userIntent[40:42]               | `uint16`   | Length of header                                                |
| userIntent[42:44]               | `uint16`   | Length of instructions                                          |
| userIntent[44:46]               | `uint16`   | Length of signatures                                            |
| Next `headerLength` bytes       | `bytes`    | The actual header                                               |
| Next `instructionsLength` bytes | `bytes`    | The actual instructions                                         |
| Next `signatureLength` bytes    | `bytes`    | The actual signatures                                           |
| Anything left                   | `bytes`    | Extra data, e.g. nested intent to be executed within the intent |

The above schema is NOT REQUIRED for all implementations. Each `IAccount` and `IStandard` can fully determine their own way of handling the `bytes` data. In the above example, the fields can be used in this way
* `header`: The `bytes header` can carry information about how to validate the intent or how to prevent
  double-spending. For example, `header` can contain an `uint256 nonce` to check if the `nonce` is used already.
* `instructions`: These `bytes instructions` can just be concatenated `(address,value,calldata)` or can be
  standardized values, for example `(erc20TokenAddress,1000)` means the `instructions` can use up to 1000 of the
  specified [ERC-20](./eip-20.md) token. It is NOT REQUIRED that all `instructions` MUST be provided by the EOA owner to allow dynamically carry out other operations during intent executions, but the `IStandard` design needs to carefully handle this case.
* `signatures`: The `bytes signatures` field can support different signing methods. It is NOT REQUIRED that
  all `signatures` MUST be provided by the EOA owner, some of them MAY be provided by solver, relayer or anyone else.

### IStandard interface

Each standard defines how to parse and validate a user intent, it implements the following `IStandard` interface:

```solidity
interface IStandard {
    /**
     * Validate user's intent
     *
     * @dev returning validation result, the type uses bytes4 for extensibility purpose
     * @return result values representing validation outcomes
     */
    function validateUserIntent(bytes calldata intent) external view returns (bytes4 result);

    /**
     * Unpack user's intent, it is RECOMMENDED to validate intent while unpacking to save gas
     *
     * @dev returning unpacked result, the type uses bytes for extensibility purpose
     * @return result unpacked result status
     * @return operations unpacked operations that can be executed by the IAccount, NOT REQUIRED to match UserIntent.instructions
     */
    function unpackOperations(bytes calldata intent) external view returns (bytes4 memory result, bytes[] memory operations);
}
```

Notice that `IStandard` fully controls the validation process, similar to `EntryPoint` in ERC-4337 and ERC-7521,
each `IStandard` implementation MUST be pre-audited and SHOULD NOT be upgradable.

### IAccount interface

On the account side, `IAccount` is the interface to execute `bytes calldata intent`:

```solidity
interface IAccount {
    /**
     * Execute user's intent
     * 
     * @dev returning execution result, the type uses bytes for extensibility purpose
     * @return result values representing execution outcomes
     */
    function executeUserIntent(bytes calldata intent) external returns (bytes memory);
}
```

Using `SET_CODE_TX_TYPE=0x04`, each account is an implementation of `IAccount` interface and EOAs can delegate the contract code to the account. Account contract MUST be audited because it controls access to EOAs' assets. Thanks to the design that different EOAs can delegate to the same account implementation, each account only need to be deployed and audited once. It has to be the EOA account owners'
responsibility to delegate to a safe `IAccount` implementation.

It is RECOMMENDED that each account leverages `IStandard` to validate and unpack operations, check **Reference
Implementation** for examples. Account smart contract can be stateless to avoid sharing storage space with other EIP-7702 contracts.

### Usage of Bytes

There are many objects defined with `bytes` type for extensibility, future-compatibility purpose. All those objects are
optional and their usages depends on `IStandard` and `IAccount` implementation.

## Rationale

> The main challenge with a generalized intent standard is being able to adapt to the evolving world of intents. Users
> need to have a way to express their intents in a seamless way without having to make constant updates to their smart
> contract wallets. --- ERC-7521

The interface designs proposed in this EIP is inspired by ERC-7521, and the author tries to avoid turning EIP into a
real implementation.

### Execution in EOA contract code

`SET_CODE_TX_TYPE=0x04` gives EOA the ability to execute code. Executing from the EOA brings some benefits:

* Aligned with the nature of EOA that the execution is fully controlled by the account owner. EOA owner can easily turn
  off all smart contract features by un-delegating the contract code.
* `msg.sender` is always EOA address
* Execution code can be stateless, this allows `account` to store no data.

In the case that the EOA doesn't need to execute its contract code, or the intent cost is too high. The owner can use
the account as EOA.

### Validation in standard contract

Validation logic commonly relies on contract state, for example, weighted multi-owner signature needs to track the
weight of each signer. Keeping the functionality of intent validate purely inside `IStandard` makes it similar to
the `EntryPoint` concept in ERC-4337, but a simpler version. Standard only taking responsibility of validation makes it
easier for contract engineer to build, audit and maintain.

Also, the `IStandard` interface can be considered as "modular". There can be a "compound" standard that
breaks one intent into smaller pieces and call other standards to validate each piece and later combine the results
together.

### Gas abstraction

This design allows any address to initiate transaction on behalf of the intent's sender, providing a gasless experience. The sender can define the "payment" to the sender in intent header or instruction, with transfers any token from the sender's account to `tx.origin`.

### Auditability of both validation and execution

It is very important both the standard and account implementation can be publicly audited and shared. The most important
reason is security. And this can also help mediate the compatibility issues between standard and account.

### Solver is relayer, relayer is paymaster, paymaster is bundler

Within a intent-centric system, solvers are helping account owners to fulfill the intent and solvers are rewarded. This
proposal allows any solver to execute the intent, bringing a positive competitive environment. And supported by gas
abstraction, solvers will pay the native token as gas fee and take other tokens back from the EOA account. Besides,
solvers can further reduce the cost of their side by bundling multiple intent executions into one blockchain
transaction.

Each solver needs to develop its own strategy to maximize its profit. And this EIP doesn't define anything about how a
solver executes the intents, meaning there is no limitation.

### Intents can be rewarded, repeatable

And another fact, which is easy to be ignored, is that intent has value by itself. For example, if an EOA is always
willing to swap 1000 USDC to 1000 USDT and vice versa, this EOA will be considered as a "liquidity provider" in the
market. The account can send the signed intent to exchanges and make the exchange reward the account every time the
intent is executed.

## Backwards Compatibility

This `IAccount` shares the same backwards compatibility issue as set EOA account code. These interfaces are not
compatible with ERC-7521 or ERC-4337.

## Reference Implementation

WIP

## Security Considerations

This is mainly controlled by the standard and account implementation to make sure the account is safe. Solver needs to
responsible for its own security when executing intents.

More discussion needed.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
