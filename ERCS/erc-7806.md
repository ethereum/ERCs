---
eip: 7806
title: Minimal intent-centric EOA smart account
description: Minimal effort intent-centric interfaces for EOA account abstraction
author: hellohanchen (@hellohanchen)
discussions-to: https://ethereum-magicians.org/t/erc-7806-minimal-intent-centric-eoa-smart-account/21565
status: Draft
type: Standards Track
category: ERC
created: 2024-11-02
requires: 7702
---

## Abstract

This proposal defines interfaces to build intent-centric smart accounts. EOA account can delegate contract code to the
smart account implementation and sign intents to allow solvers (and relayers) to execute on behalf of account owner.

## Motivation

AA (Account abstraction) is a hot topic in blockchain industry because it gives accounts programmability features,
including but not limited to:

* **BatchExecution**
* **GasSponsorship**
* **AccessControl**

With [ERC-4337](./eip-4337.md), engineers built a permissionless AA standard. While unlocking enormous number of useful
features, ERC-4337 still has several limitations:

* **Complexity**: Requiring multiple components: Account, EntryPoint, Paymaster, Bundler, and
  Plugins ([ERC-6900](./eip-6900.md), [ERC-7579](./eip-7579.md). Services like bundler requires high engineer skills and
  heavy overhead work to run and maintain.
* **Compatibility**: Compatibility issue between components forces developers to upgrade multiple smart contracts within
  one version update, also divides the ecosystem.
* **Cost**: `UserOperation` processing costs high gas units.
* **Trust**: Although this standard is designed to be permissionless, there are still centralized processes. Paymaster
  is usually a centralized service because it needs to either trust the account owner to repay the sponsored gas.
  Bundlers are running on MEV based and accounts need to trust bundler providers to include their user operations in the
  transaction.

[ERC-7521](./eip-7521.md) discusses an SCA solution with intent-centric design. It enables solvers to fulfill account
owners' intents by acting "on behalf of" account owners. ERC-7521 allows arbitrary intents and verification logics while
trying to keep the whole solution forward-compatible.

With `SET_CODE_TX_TYPE=0x04` allowing EOA accounts to set contract code, EOA accounts will gain similar programmability
as SCA (Smart Contact Account). A new standard, that provides EOA with highly-demanded AA features while potentially
resolving some of the above challenges, will help bring in seamless user experience and drive mass adoptions.

The above EIPs inspired the author to build an intent-centric standard for EOA smart accounts.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT
RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### UserIntent bytes

Each intent is a packed data structure containing sufficient information about operations the account owner wants to
execute.

| Field          | Type      | Description                                                                                                                                              |
|----------------|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sender`       | `address` | The wallet making the intent                                                                                                                             |
| `standard`     | `address` | The `IStandard` implementation to validate and parse this `UserIntent`                                                                                   |
| `header`       | `bytes`   | The metadata of this `UserIntent`, used by `standard`, using `bytes` type to keep flexibility                                                            |
| `instructions` | `bytes[]` | The detailed content of this `UserIntent`, used by `standard` to determine the `Operation`s need to be executing, using `bytes` type to keep flexibility |
| `signatures`   | `bytes[]` | Validatable signatures, used by `standard`                                                                                                               |

But using `bytes[]` on functional interface is heavy especially when multiple intents are compound together. Therefore,
the "UserIntent" object is designed to be a pack-encoded `bytes calldata userIntent` contains the above information

| Section                         | Value Type | Description                                                     |
|---------------------------------|------------|-----------------------------------------------------------------|
| userIntent[0:20]                | `address`  | sender                                                          |
| userIntent[20:40]               | `address`  | standard                                                        |
| userIntent[40:42]               | `uint16`   | Length of header                                                |
| userIntent[42:44]               | `uint16`   | Length of instructions                                          |
| userIntent[44:46]               | `uint16`   | Length of signatures                                            |
| Next `headerLength` bytes       | `bytes`    | The actual header                                               |
| Next `instructionsLength` bytes | `bytes`    | The actual instructions                                         |
| Next `signatureLength` bytes    | `bytes`    | The actual signatures                                           |
| Anything left                   | `bytes`    | Extra data, e.g. nested intent to be executed within the intent |

The above schema is NOT REQUIRED for all implementations. Each `IAccount` and `IStandard` can fully determine their own way of handling the `bytes` data. In the above example, the fields can be used in this way
* `header`: The `bytes header` can carry information about how to validate the intent or how to prevent
  double-spending. For example, `header` can contain an `uint256 nonce` to check if the `nonce` is used already.
* `instructions`: These `bytes instructions` can just be concatenated `(address,value,calldata)` or can be
  standardized values, for example `(erc20TokenAddress,1000)` means the `instructions` can use up to 1000 of the
  specified [ERC-20](./eip-20.md) token. It is NOT REQUIRED that all `instructions` MUST be provided by the EOA owner to allow dynamically carry out other operations during intent executions, but the `IStandard` design needs to carefully handle this case.
* `signatures`: The `bytes signatures` field can support different signing methods. It is NOT REQUIRED that
  all `signatures` MUST be provided by the EOA owner, some of them MAY be provided by solver, relayer or anyone else.

### IStandard interface

Each standard defines how to parse and validate a user intent, it implements the following `IStandard` interface:

```solidity
interface IStandard {
    /**
     * Validate user's intent
     *
     * @dev returning validation result, the type uses bytes4 for extensibility purpose
     * @return result values representing validation outcomes
     */
    function validateUserIntent(bytes calldata intent) external view returns (bytes4 result);

    /**
     * Unpack user's intent, it is RECOMMENDED to validate intent while unpacking to save gas
     *
     * @dev returning unpacked result, the type uses bytes for extensibility purpose
     * @return result unpacked result status
     * @return operations unpacked operations that can be executed by the IAccount, NOT REQUIRED to match UserIntent.instructions
     */
    function unpackOperations(bytes calldata intent) external view returns (bytes4 memory result, bytes[] memory operations);
}
```

Notice that `IStandard` fully controls the validation process, similar to `EntryPoint` in ERC-4337 and ERC-7521,
each `IStandard` implementation MUST be pre-audited and SHOULD NOT be upgradable.

### IAccount interface

On the account side, `IAccount` is the interface to execute `bytes calldata intent`:

```solidity
interface IAccount {
    /**
     * Execute user's intent
     * 
     * @dev returning execution result, the type uses bytes for extensibility purpose
     * @return result values representing execution outcomes
     */
    function executeUserIntent(bytes calldata intent) external returns (bytes memory);
}
```

Using `SET_CODE_TX_TYPE=0x04`, each account is an implementation of `IAccount` interface and EOAs can delegate the contract code to the account. Account contract MUST be audited because it controls access to EOAs' assets. Thanks to the design that different EOAs can delegate to the same account implementation, each account only need to be deployed and audited once. It has to be the EOA account owners'
responsibility to delegate to a safe `IAccount` implementation.

It is RECOMMENDED that each account leverages `IStandard` to validate and unpack operations, check **Reference
Implementation** for examples. Account smart contract can be stateless to avoid sharing storage space with other delegated contracts.

### Usage of Bytes

There are many objects defined with `bytes` type for extensibility, future-compatibility purpose. All those objects are
optional and their usages depends on `IStandard` and `IAccount` implementation.

## Rationale

> The main challenge with a generalized intent standard is being able to adapt to the evolving world of intents. Users
> need to have a way to express their intents in a seamless way without having to make constant updates to their smart
> contract wallets. --- ERC-7521

The interface designs proposed in this EIP is inspired by ERC-7521, and the author tries to avoid turning EIP into a
real implementation.

### Execution in EOA contract code

`SET_CODE_TX_TYPE=0x04` gives EOA the ability to execute code. Executing from the EOA brings some benefits:

* Aligned with the nature of EOA that the execution is fully controlled by the account owner. EOA owner can easily turn
  off all smart contract features by un-delegating the contract code.
* `msg.sender` is always EOA address
* Execution code can be stateless, this allows `account` to store no data.

In the case that the EOA doesn't need to execute its contract code, or the intent cost is too high. The owner can use
the account as EOA.

### Validation in standard contract

Validation logic commonly relies on contract state, for example, weighted multi-owner signature needs to track the
weight of each signer. Keeping the functionality of intent validate purely inside `IStandard` makes it similar to
the `EntryPoint` concept in ERC-4337, but a simpler version. Standard only taking responsibility of validation makes it
easier for contract engineer to build, audit and maintain.

Also, the `IStandard` interface can be considered as "modular". There can be a "compound" standard that
breaks one intent into smaller pieces and call other standards to validate each piece and later combine the results
together.

### Gas abstraction

This design allows any address to initiate transaction on behalf of the intent's sender, providing a gasless experience. The sender can define the "payment" to the sender in intent header or instruction, with transfers any token from the sender's account to `tx.origin`.

### Auditability of both validation and execution

It is very important both the standard and account implementation can be publicly audited and shared. The most important
reason is security. And this can also help mediate the compatibility issues between standard and account.

### Solver is relayer, relayer is paymaster, paymaster is bundler

Within a intent-centric system, solvers are helping account owners to fulfill the intent and solvers are rewarded. This
proposal allows any solver to execute the intent, bringing a positive competitive environment. And supported by gas
abstraction, solvers will pay the native token as gas fee and take other tokens back from the EOA account. Besides,
solvers can further reduce the cost of their side by bundling multiple intent executions into one blockchain
transaction.

Each solver needs to develop its own strategy to maximize its profit. And this EIP doesn't define anything about how a
solver executes the intents, meaning there is no limitation.

### Intents can be rewarded, repeatable

And another fact, which is easy to be ignored, is that intent has value by itself. For example, if an EOA is always
willing to swap 1000 USDC to 1000 USDT and vice versa, this EOA will be considered as a "liquidity provider" in the
market. The account can send the signed intent to exchanges and make the exchange reward the account every time the
intent is executed.

## Backwards Compatibility

This `IAccount` shares the same backwards compatibility issue as set EOA account code. These interfaces are not
compatible with ERC-7521 or ERC-4337.

## Reference Implementation

This `RelayedExecutionStandard` allows relayer to execute the operations on chain and take ERC20 token from the intent sender, 
thus achieve a gas-less experience for the sender.

```solidity
/*
RelayedExecutionStandard

This standard allows sender to define a list of execution instructions and asks the relayer to execute
on chain on behalf of the sender. It is hash and time gated means the intent can only be executed before
a timestamp and can only be executed once.

The first 20 bytes of the `intent` is sender address.
The next 20 bytes of the `intent` is the standard address, which should be equal to address of this standard.
The following is the length section, containing 3 uint16 defining header length, instructions length and signature length.

The header is either 8 bytes long or 28 bytes long.
The 8-byte part is the timestamp in epoch seconds.
The optional 20-byte defines the assigned relayer address if the sender only wants a specific relayer to execute.

The instructions contains 2 main part.
The first 36 bytes is a packed encoded (address, uint128) pair representing the 'payment' that the sender will pay to the
relayer. It should be an ERC20 token.
The following 1-byte is an uint8 defining the number of instructions to execute.
The instructions are concatenated together, the first 2 bytes (uint16) defines the length of each instruction, the following
is the instruction body. Instructions should be abi.encode(address, uint256, bytes) which can directly be executed by
the sender account.

The signature field is always 65 bytes long. It contains the signed bytes.concat(header, instructions).
*/
contract RelayedExecutionStandard is HashGatedStandard {
    using ECDSA for bytes32;

    string public constant DESCRIPTION = "Timed Hashed Relayed Execution Standard";
    string public constant VERSION = "0.0.0";
    string public constant AUTHOR = "hellohanchen";

    bytes4 public constant VALIDATION_DENIED = 0x00000000;
    bytes4 public constant VALIDATION_APPROVED = 0x00000001;
    bytes4 public constant IACCOUNT_EXECUTE_USER_INTENT_SELECTOR = IAccount.executeUserIntent.selector;

    function validateUserIntent(bytes calldata intent) external view returns (bytes4) {
        (address sender, address addressVar) = PackedIntent.getSenderAndStandard(intent);
        require(addressVar == address(this), "Not this standard");
        (uint256 uint256Var1, uint256 uint256Var2, uint256 uint256Var3) = PackedIntent.getLengths(intent);
        require(uint256Var1 == 28 || uint256Var1 == 8, "Invalid header length");
        require(uint256Var2 >= 36, "Instructions too short");
        require(uint256Var3 == 65, "Invalid signature length");
        // end of instructions
        uint256Var2 = 46 + uint256Var1 + uint256Var2;
        require(uint256Var2 + uint256Var3 == intent.length, "Invalid intent length");

        // validate signature
        uint256 hash = _validateSignatures(sender, intent, uint256Var2);
        require(!this.checkHash(sender, hash), "Hash is already executed");

        // header contains expiration timestamp and assigned relayer (optional)
        require(uint256(uint64(bytes8(intent[46 : 54]))) >= block.timestamp, "Intent expired");
        // assignedRelayerAddress = address(intent[54:74]) [optional]

        // end of header section / begin of instruction section
        uint256Var1 = 46 + uint256Var1;
        // first 20 bytes of instruction is out token address
        uint256Var2 = uint256Var1 + 20;
        addressVar = address(bytes20(intent[uint256Var1 : uint256Var2]));
        // out token amount, use uint128 to shorten the intent
        uint256Var3 = uint256Var2 + 16;
        uint256Var1 = uint256(uint128(bytes16(intent[uint256Var2 : uint256Var3])));
        if (addressVar != address(0)) {
            (bool success, bytes memory data) = addressVar.staticcall(
                abi.encodeWithSelector(IERC20.balanceOf.selector, sender)
            );
            if (!success || data.length != 32) {
                revert("Not ERC20 token");
            }
            require(abi.decode(data, (uint256)) >= uint256Var1, "Insufficient token balance");
        } else {
            require(sender.balance >= uint256Var1, "Insufficient eth balance");
        }

        // end of outToken instruction
        uint256 numExecutions = uint256(uint8(bytes1(intent[uint256Var3 : uint256Var3 + 1])));
        // instruction index
        uint256Var1 = 0;
        // begin of the first instruction
        uint256Var3 = uint256Var3 + 1;
        uint256 instructionsEnd = intent.length - 65;

        while (uint256Var1 < numExecutions) {
            uint256Var2 = uint256Var3 + 2;
            require(uint256Var2 <= instructionsEnd, "Intent too short: instruction length");
            // end of this execution instruction
            uint256Var3 = uint256Var2 + uint256(uint16(bytes2(intent[uint256Var3 : uint256Var2])));
            require(uint256Var3 <= instructionsEnd, "Intent too short: single instruction");

            uint256Var1 += 1;
        }
        require(uint256Var3 == instructionsEnd, "Intent length doesn't match");

        return VALIDATION_APPROVED;
    }

    function unpackOperations(bytes calldata intent) external view returns (bytes4 code, bytes[] memory unpackedInstructions) {
        (address sender, address addressVar) = PackedIntent.getSenderAndStandard(intent);
        require(addressVar == address(this), "Not this standard");
        (uint256 uint256Var1, uint256 uint256Var2, uint256 uint256Var3) = PackedIntent.getLengths(intent);
        require(uint256Var1 == 28 || uint256Var1 == 8, "Invalid header length");
        require(uint256Var2 >= 36, "Instructions too short");
        require(uint256Var3 == 65, "Invalid signature length");
        // end of instructions
        uint256Var2 = 46 + uint256Var1 + uint256Var2;
        require(uint256Var2 + uint256Var3 == intent.length, "Invalid intent length");

        // fetch header content (timestamp, relayer address [optional])
        require(uint256(uint64(bytes8(intent[46 : 54]))) >= block.timestamp, "Intent expired");
        if (uint256Var1 == 28) {
            // assigned relayer
            addressVar = address(bytes20(intent[54 : 74]));
            require(tx.origin == addressVar, "Relayer not assigned");
        }

        uint256 uint256Var4 = _validateSignatures(sender, intent, uint256Var2);
        require(!this.checkHash(sender, uint256Var4), "Hash is already executed");

        // begin of instructions
        uint256Var1 = uint256Var1 + 46;
        // total instructions = mark hash + transfer token to relayer + executions
        // the first 36 bytes defines the payment to relayer
        // the next 1 byte defines the number of execution instructions
        uint256Var2 = uint256Var1 + 36;
        uint256Var3 = uint256Var2 + 1;
        unpackedInstructions = new bytes[](2 + uint8(bytes1(intent[uint256Var2 : uint256Var3])));
        // first instruction is mark hash to prevent re-entry attack
        unpackedInstructions[0] = abi.encode(
            address(this), 0, abi.encodeWithSelector(this.markHash.selector, uint256Var4));

        // the first 20 bytes of instructions is the out token address
        uint256Var2 = uint256Var1 + 20;
        addressVar = address(bytes20(intent[uint256Var1 : uint256Var2]));
        // amount
        uint256Var4 = uint256(uint128(bytes16(intent[uint256Var2 : uint256Var2 + 16])));
        // out token instruction
        if (addressVar == address(0)) {
            unpackedInstructions[1] = abi.encode(address(tx.origin), uint256Var4, "");
        } else {
            unpackedInstructions[1] = abi.encode(
                addressVar,
                uint256(0),
                abi.encodeWithSelector(IERC20.transfer.selector, address(tx.origin), uint256Var4));
        }

        // instruction index
        uint256Var1 = 2;
        // uint256Var3, end of outToken instruction
        // uint256Var4, end of instructions section
        uint256Var4 = intent.length - 65;

        while (uint256Var1 < unpackedInstructions.length) {
            // start of next execution instruction
            uint256Var2 = uint256Var3 + 2;
            require(uint256Var2 <= uint256Var4, "Intent too short: instruction length");
            // end of next execution instruction
            uint256Var3 = uint256Var2 + uint256(uint16(bytes2(intent[uint256Var3 : uint256Var2])));
            require(uint256Var3 <= uint256Var4, "Intent too short: single instruction");

            unpackedInstructions[uint256Var1] = intent[uint256Var2 : uint256Var3];

            uint256Var1 += 1;
        }
        require(uint256Var3 == uint256Var4, "Intent length doesn't match");

        return (VALIDATION_APPROVED, unpackedInstructions);
    }

    function _validateSignatures(
        address sender, bytes calldata intent, uint256 sigStartIndex
    ) internal view returns (uint256) {
        bytes32 intentHash = keccak256(abi.encode(intent[46 : sigStartIndex], address(this), block.chainid));
        bytes32 messageHash = MessageHashUtils.toEthSignedMessageHash(intentHash);
        require(sender == messageHash.recover(intent[sigStartIndex : sigStartIndex + 65]), "Invalid sender signature");

        return uint256(intentHash);
    }
}
```

The following `IAccount` implementation uses a `StandardRegistry` to maintain allowlist of standards and just batch execute 
all operations returned from `IStandard.unpackOperations`.

```solidity
contract AccountImplV0 is SelfExecutableAccount {
    string public constant DESCRIPTION = "Account with Batch Execution, Standard Registry";
    string public constant VERSION = "0.0.0";
    string public constant AUTHOR = "hellohanchen";

    StandardRegistry public constant REGISTRY = StandardRegistry(address());
    bytes4 public constant VALIDATION_APPROVED = 0x00000001;
    bytes4 public constant VALIDATION_DENIED = 0x00000000;

    function executeOtherIntent(bytes calldata intent) override internal returns (bytes memory) {
        (address sender, address standard) = PackedIntent.getSenderAndStandard(intent);
        require(sender == address(this), "Intent is not from this account");
        require(REGISTRY.isRegistered(address(this), standard), "Standard not registered");
        // standard validation and unpack
        (bytes4 validationCode, bytes[] memory instructions) = IStandard(standard).unpackOperations(intent);
        require(validationCode == VALIDATION_APPROVED, "Validation failed");

        // batch execute
        for (uint256 i = 0; i < instructions.length; i++) {
            (address dest, uint256 value, bytes memory data) = abi.decode(instructions[i], (address, uint256, bytes));

            (bool success,) = dest.call{value : value, gas : gasleft()}(data);
            if (!success) {
                revert SelfExecutableAccount.ExecutionError();
            }
        }

        return new bytes(0);
    }

    receive() external payable {}
}
```

As shown above, the implementation of `IAccount` is stateless and simple, so that it can be compatible with different `IStandard`. 
While the `IStandard` implementation is complex because it needs to define its own schema. But both contracts will be public 
and audited, to ensure the security of intent execution.

## Security Considerations

This is mainly controlled by the standard and account implementation to make sure the account is safe. Solver needs to
responsible for its own security when executing intents.

More discussion needed.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
