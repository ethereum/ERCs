---
eip: 8160
title: Payer Web Service Capability
description: A way for apps to communicate with wallets about payer web services for EIP-8130 transactions
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: TBD
status: Draft
type: Standards Track
category: ERC
created: 2026-02-19
requires: 5792, 7836, 8130
---

## Abstract

With [EIP-5792](./eip-5792.md), apps can communicate with wallets about advanced features via capabilities. This proposal defines a capability that allows apps to request that [EIP-8130](./eip-8130.md) wallets communicate with a specified payer web service. To support this, we also define a standardized API for payer web services.

## Motivation

[EIP-8130](./eip-8130.md) introduces native account abstraction where payers are first-class protocol participants — they co-sign the transaction with a K1 signature recovered via ecrecover. This is fundamentally different from the [ERC-4337](./eip-4337.md) paymaster model:

- There is no EntryPoint contract or paymaster field injection flow.
- No stub-data/final-data two-phase dance is required — the payer simply co-signs.
- The payer signs the same transaction object that lands onchain.
- The payer can relay the transaction directly to the chain, reducing hops.
- [EIP-8130](./eip-8130.md) transactions have a native `expiry` field, enabling time-bounded sponsorship commitments enforced at the protocol level.

[ERC-7677](./eip-7677.md) defines a paymaster web service capability for [ERC-4337](./eip-4337.md). That specification does not apply to [EIP-8130](./eip-8130.md) because the two-phase `pm_getPaymasterStubData` / `pm_getPaymasterData` flow addresses concerns (gas estimation with paymaster-injected fields, stub data consistency) that do not exist in the [EIP-8130](./eip-8130.md) payer model.

App developers, wallet developers, and payer service providers need a common wire protocol for [EIP-8130](./eip-8130.md) payer communication.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Payer Web Service Interface

We define two JSON-RPC methods to be implemented by payer web services, and one OPTIONAL discovery method.

#### `payer_getTerms`

Returns sponsorship or token-payment terms for a transaction intent. Accepts a chain ID, sender address, intended calls, and optional hints. This method is called *before* the sender signs.

Payer web services SHOULD validate the transaction intent during `payer_getTerms` execution and reject at this stage if they would not sponsor or accept payment for the operation.

This method MAY return a `gasEstimate` with the payer's recommended gas parameters. The wallet MAY use these values or MAY estimate gas independently via `eth_estimateGas`. The payer's `conditions.maxGasLimit` is the binding constraint.

This method MAY also return a `sponsor` object with a `name` field and an optional `icon` field. The `name` field is the name of the party sponsoring the transaction, and the `icon` field is a URI pointing to an image. Wallet developers MAY choose to display sponsor information to users. The `icon` string MUST be a data URI as defined in RFC-2397. The image SHOULD be a square with 96x96px minimum resolution. Since SVG images can execute Javascript, wallets MUST render SVG images using the `<img>` tag to ensure no untrusted Javascript execution can occur.

##### `payer_getTerms` RPC Specification

```typescript
// [params]
type GetTermsParams = {
  chainId: `0x${string}`;
  from: `0x${string}`;
  calls: {
    to: `0x${string}`;
    value?: `0x${string}`;
    data?: `0x${string}`;
  }[];
  gasLimit?: `0x${string}`;
  preferredTokens?: `0x${string}`[];
};

type GetTermsResult = {
  sponsored: boolean;
  gasEstimate?: {
    gasLimit: `0x${string}`;
    maxFeePerGas: `0x${string}`;
    maxPriorityFeePerGas: `0x${string}`;
  };
  tokenOptions?: {
    token: `0x${string}`;
    maxCost: `0x${string}`;
    rate: string;
    rateExpiry: number;
  }[];
  conditions?: {
    maxExpiry?: number;
    minExpiry?: number;
    maxGasLimit?: `0x${string}`;
    requiredChainId?: `0x${string}`;
  };
  payer: `0x${string}`;
  payerType: "permissioned" | "permissionless";
  endpoint: string;
  sponsor?: {
    name: string;
    icon?: string;
  };
};
```

##### `payer_getTerms` Example Parameters

```json
{
  "chainId": "0x2105",
  "from": "0xAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAa",
  "calls": [
    {
      "to": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
      "data": "0xa9059cbb..."
    }
  ],
  "gasLimit": "0xC350",
  "preferredTokens": ["0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"]
}
```

##### `payer_getTerms` Example Return Value (Full Sponsorship)

```json
{
  "sponsored": true,
  "gasEstimate": {
    "gasLimit": "0xC350",
    "maxFeePerGas": "0x59682F00",
    "maxPriorityFeePerGas": "0x59682F00"
  },
  "conditions": {
    "maxExpiry": 1735689720
  },
  "payer": "0xCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCc",
  "payerType": "permissioned",
  "endpoint": "https://payer.example.com/v1",
  "sponsor": {
    "name": "My App"
  }
}
```

##### `payer_getTerms` Example Return Value (Token Payment)

```json
{
  "sponsored": false,
  "gasEstimate": {
    "gasLimit": "0xC350",
    "maxFeePerGas": "0x59682F00",
    "maxPriorityFeePerGas": "0x59682F00"
  },
  "tokenOptions": [
    {
      "token": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
      "maxCost": "0x30D40",
      "rate": "2050 USDC/ETH",
      "rateExpiry": 1735689720
    }
  ],
  "conditions": {
    "maxExpiry": 1735689720
  },
  "payer": "0xCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCcCc",
  "payerType": "permissioned",
  "endpoint": "https://payer.example.com/v1"
}
```

#### `payer_sendTransaction`

Accepts a sender-signed [EIP-8130](./eip-8130.md) transaction for payer co-signing and optional relay. The sender MUST have signed with the `0x00` marker in the `payer_auth` hash position (sponsored mode as defined in [EIP-8130](./eip-8130.md)).

The `mode` parameter determines submission behavior:

- `relay`: The payer co-signs and submits the transaction onchain, then returns the transaction hash.
- `cosign`: The payer co-signs and returns the fully-signed transaction for the caller to submit.

Payers MUST NOT mutate any sender-signed transaction fields. If the payer cannot accept the transaction as-is (e.g., gas limit too low), the payer MUST reject the request and SHOULD return actionable error data.

##### `payer_sendTransaction` RPC Specification

```typescript
type SendTransactionParams = {
  signedTransaction: `0x${string}`;
  mode: "relay" | "cosign";
  context?: Record<string, any>;
};

type SendTransactionResult = {
  transactionHash?: `0x${string}`;
  signedTransaction?: `0x${string}`;
  tokenCharged?: {
    token: `0x${string}`;
    amount: `0x${string}`;
  };
};
```

##### `payer_sendTransaction` Example Parameters

```json
{
  "signedTransaction": "0x...",
  "mode": "relay",
  "context": {
    "appId": "my-app"
  }
}
```

##### `payer_sendTransaction` Example Return Value (Relay)

```json
{
  "transactionHash": "0x1234abcd..."
}
```

##### `payer_sendTransaction` Example Return Value (Cosign)

```json
{
  "signedTransaction": "0x..."
}
```

##### `payer_sendTransaction` Example Return Value (Token Payment, Relay)

```json
{
  "transactionHash": "0x1234abcd...",
  "tokenCharged": {
    "token": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    "amount": "0x2BF20"
  }
}
```

#### `payer_getSponsorshipOptions` (OPTIONAL)

Returns a ranked list of sponsorship and payment options for a transaction intent. This method MAY be implemented by individual payers or by aggregator services.

##### `payer_getSponsorshipOptions` RPC Specification

```typescript
type GetSponsorshipOptionsParams = {
  chainId: `0x${string}`;
  from: `0x${string}`;
  calls: {
    to: `0x${string}`;
    value?: `0x${string}`;
    data?: `0x${string}`;
  }[];
  paymentToken?: `0x${string}`;
  gasLimit?: `0x${string}`;
};

type SponsorshipOption = {
  type: "full_sponsorship" | "token_payment" | "native_payer";
  payer: `0x${string}`;
  payerType: "permissioned" | "permissionless" | "native";
  endpoint: string;
  sponsor?: {
    name: string;
    icon?: string;
    reason?: string;
  };
  tokenPayment?: {
    token: `0x${string}`;
    tokenSymbol: string;
    estimatedCost: `0x${string}`;
    rate: string;
    rateExpiry: number;
  };
  nativePayer?: {
    estimatedCost: `0x${string}`;
    token: `0x${string}`;
    tokenSymbol: string;
  };
  conditions?: {
    maxExpiry?: number;
    minExpiry?: number;
    maxGasLimit?: `0x${string}`;
  };
  priority?: number;
};

type GetSponsorshipOptionsResult = {
  options: SponsorshipOption[];
};
```

##### `payer_getSponsorshipOptions` Example Return Value

```json
{
  "options": [
    {
      "type": "full_sponsorship",
      "payer": "0xabc...",
      "payerType": "permissioned",
      "endpoint": "https://sponsor.example.com/v1",
      "sponsor": {
        "name": "Circle",
        "reason": "USDC transfers are sponsored"
      },
      "priority": 0
    },
    {
      "type": "token_payment",
      "payer": "0xdef...",
      "payerType": "permissionless",
      "endpoint": "https://gas.market/v1",
      "tokenPayment": {
        "token": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
        "tokenSymbol": "USDC",
        "estimatedCost": "0x1F4",
        "rate": "2000.50 USDC/ETH",
        "rateExpiry": 1735689600
      },
      "conditions": {
        "maxExpiry": 1735689720
      },
      "priority": 1
    }
  ]
}
```

### Error Codes

Payer services MUST use the following error codes when rejecting requests. Error responses SHOULD include a `data` field with actionable details (e.g., suggested gas limit, updated terms).

| Code | Message | Description |
|------|---------|-------------|
| -32600 | `INVALID_TRANSACTION` | Malformed or invalid [EIP-8130](./eip-8130.md) transaction |
| -32601 | `UNSUPPORTED_TOKEN` | Token in `fee_token` not accepted by this payer |
| -32602 | `RATE_EXPIRED` | Terms from `payer_getTerms` have expired; re-request |
| -32603 | `MAX_AMOUNT_INSUFFICIENT` | Sender `max_amount` in `fee_token` is below the required cost |
| -32604 | `EXPIRY_OUT_OF_BOUNDS` | Transaction expiry does not satisfy payer conditions |
| -32605 | `POLICY_REJECTED` | Payer policy rejected this transaction |
| -32606 | `PAYER_BALANCE_INSUFFICIENT` | Payer lacks ETH to cover gas |
| -32607 | `SENDER_BLOCKLISTED` | Sender is blocklisted for the specified token |

### `payerService` Capability

The `payerService` capability is implemented by both apps and wallets.

#### App Implementation

Apps provide wallets with a payer service URL using the `payerService` capability as part of an [EIP-5792](./eip-5792.md) `wallet_sendCalls` or [ERC-7836](./eip-7836.md) `wallet_prepareCalls` call.

##### `wallet_sendCalls` / `wallet_prepareCalls` Payer Capability Specification

```typescript
type PayerServiceCapability = {
  url: string;
  context?: Record<string, any>;
};
```

##### `wallet_sendCalls` Example Parameters

```json
[
  {
    "version": "1.0",
    "chainId": "0x2105",
    "from": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
    "calls": [
      {
        "to": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
        "data": "0xa9059cbb..."
      }
    ],
    "capabilities": {
      "payerService": {
        "url": "https://payer.example.com/v1",
        "context": {
          "policyId": "962b252c-a726-4a37-8d86-333ce0a07299"
        }
      }
    }
  }
]
```

The wallet will then make the payer RPC calls to the URL specified in the `payerService` capability field.

#### Wallet Implementation

To conform to this specification, wallets that wish to leverage payer-sponsored [EIP-8130](./eip-8130.md) transactions:

1. MUST indicate to apps that they support payer web services via their response to an [EIP-5792](./eip-5792.md) `wallet_getCapabilities` call.
2. SHOULD make calls to and use the values returned by the payer service specified in the capabilities field. Since there might be cases in which the provided payer is ultimately not used—either due to service failure or due to a user selecting a different payer—applications MUST NOT assume that the payer provided to a wallet is the entity that pays for transaction fees.

##### `wallet_getCapabilities` Response Specification

```typescript
type PayerServiceCapability = {
  supported: boolean;
};
```

##### `wallet_getCapabilities` Example Response

```json
{
  "0x2105": {
    "payerService": {
      "supported": true
    }
  }
}
```

#### `wallet_sendCalls` Flow

When `wallet_sendCalls` is called with the `payerService` capability:

1. Wallet OPTIONALLY calls `payer_getTerms` at the provided URL.
2. Wallet constructs the [EIP-8130](./eip-8130.md) transaction, including `fee_token` and the `0x00` `payer_auth` marker (sponsored mode).
3. Wallet signs the transaction (`sender_auth`).
4. Wallet calls `payer_sendTransaction` at the payer endpoint.
5. Payer co-signs (`payer_auth`) and either relays or returns the co-signed transaction.

#### `wallet_prepareCalls` Flow (ERC-7836)

When `wallet_prepareCalls` is called with the `payerService` capability:

1. Wallet OPTIONALLY calls `payer_getTerms` at the provided URL to negotiate payment terms.
2. Wallet constructs the unsigned [EIP-8130](./eip-8130.md) transaction incorporating negotiated terms (gas parameters, `fee_token`, expiry).
3. Wallet computes the transaction digest and returns it to the app.
4. App signs the digest (e.g., with a session key) and calls `wallet_sendPreparedCalls`.
5. Wallet assembles the signed transaction and calls `payer_sendTransaction`.

This enables apps to use session keys ([ERC-7836](./eip-7836.md)) while leveraging external payers for gas sponsorship or token payment, without the app needing to implement the payer RPC protocol.

### Endpoint Versioning

Payer service endpoints MUST use path-based major versioning (e.g., `/v1`, `/v2`). Method names remain stable across versions. Breaking changes (new required fields, changed semantics) require a new major path version. Additive optional fields in request or response are backwards-compatible within the same version. Clients MUST ignore unknown fields. Payers MUST NOT require new optional fields within an existing version.

## Rationale

### Why Not Adapt ERC-7677?

[ERC-7677](./eip-7677.md) solves a different problem. Its two-phase stub/final flow exists because [ERC-4337](./eip-4337.md) paymasters inject data into the UserOperation *before* gas estimation, and the stub data must produce consistent code paths and byte lengths. In [EIP-8130](./eip-8130.md), the payer simply co-signs the complete transaction — there is no paymaster data injection, no stub values, and no code path consistency concern. Adapting [ERC-7677](./eip-7677.md) would add unnecessary complexity for a problem that does not exist.

### Why `payer_getTerms` Is Optional

For known payers (e.g., an app's own backend), the wallet can skip `payer_getTerms` and call `payer_sendTransaction` directly. The payer rejects with an actionable error code if terms are not met. This optimistic path reduces round trips for the common case. Payer services MUST return sufficient error detail (e.g., `RATE_EXPIRED` with updated terms in error data) to enable recovery without a separate terms call.

### Relay vs Cosign

The `mode` parameter on `payer_sendTransaction` gives wallets explicit control over submission:

- **Relay** minimizes hops — the payer co-signs and submits in one step. This is the common case for app-sponsored transactions.
- **Cosign** gives the wallet submission control — useful for high-value transactions, MEV-sensitive paths, or when the wallet wants to use private mempools.

Wallets SHOULD support both modes. The choice is the wallet's, not the app's.

### Gas Estimation

The wallet estimates gas independently via `eth_estimateGas`. The payer MAY also return a `gasEstimate` in `payer_getTerms` as an advisory value. This is useful when the payer has better visibility into gas conditions or wants to recommend specific limits. The payer's `conditions.maxGasLimit` serves as the binding constraint — the wallet can estimate however it wishes as long as the result satisfies the payer's conditions.

### Chain ID in Requests

Following the rationale from [ERC-7677](./eip-7677.md): requiring `chainId` as a parameter rather than mandating URL-per-chain allows payer services to offer multichain endpoints at no cost to single-chain providers.

### Expiry as a Sponsorship Primitive

[EIP-8130](./eip-8130.md) transactions have a native `expiry` field enforced at the protocol level. Payers can express time-bounded commitments via `conditions.maxExpiry` — the protocol guarantees the transaction cannot land after that time. This is strictly stronger than [ERC-4337](./eip-4337.md) where paymasters must encode and validate time bounds in their own data during execution.

## Backwards Compatibility

This proposal defines a new capability for [EIP-5792](./eip-5792.md) and [ERC-7836](./eip-7836.md). Wallets that do not support [EIP-8130](./eip-8130.md) transactions will not advertise the `payerService` capability and are unaffected. This proposal does not modify [ERC-7677](./eip-7677.md); wallets that support both [ERC-4337](./eip-4337.md) and [EIP-8130](./eip-8130.md) MAY advertise both `paymasterService` and `payerService` capabilities independently.

## Security Considerations

**API key exposure**: Payer service URLs commonly contain API keys. App developers SHOULD proxy payer requests through their own backend to keep keys secret, identical to the recommendation in [ERC-7677](./eip-7677.md). Payer services SHOULD support scoped API keys restricted to specific methods.

**Relay trust**: In relay mode, the wallet trusts the payer to submit the transaction. The transaction's `expiry` field bounds this exposure — if the payer does not submit before expiry, the transaction is dead. Wallets concerned about relay trust SHOULD use cosign mode and submit themselves.

**Payer immutability**: Payers MUST NOT alter any sender-signed fields. The sender's signature covers the exact transaction that lands onchain. Any modification invalidates the signature.

**Token payment caps**: When token payment is used via [EIP-8140](./eip-8140.md), the sender's `max_amount` in `fee_token` is a hard protocol-level cap on token spend. Payers cannot charge more than this amount regardless of exchange rate fluctuations.

**Rate commitment**: Once a payer returns terms with a `rateExpiry`, the payer SHOULD honor those terms until expiry. Wallets can protect against rate changes by setting `max_amount` conservatively and using short expiry windows.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
