---
eip: 7551
title: Crypto Security Token Interface
description: Smart contract interface for representing crypto securities
author: Lars Olsson <lars.olsson@cashlink.de>, Hagen Hübel (@itinance) <hagen@token-forge.io>, Markus Kluge <markus@token-forge.io>, Andreas Berghammer <andreas@tokenforge.io>
discussions-to: https://ethereum-magicians.org/t/erc-7551-crypto-security-token-smart-contract-interface-ewpg-reworked/25477
status: Draft
type: Standards Track
category: ERC
created: 2023-09-05
---

## Abstract

The interface is supposed to work on top of additional standards that cover the actual storage of ownership of shares of a security in the form of a token (e.g. [ERC-20](./eip-20.md) or [ERC-1155](./eip-1155.md)). While the scope of the underlying token standard is to provide an interface for transferring the crypto securities and retrieving individual holder balances, this standard provides the following additional functionality needed by wallet providers and exchanges to handle crypto securities:

### Transfer compliance
In the case of crypto securities the smart contract needs to check if a transfer of tokens is compliant. The specification therefore adds a `canTransfer()` and a `canTransferFrom()` function that can be used to check if a transfer would be successful given the current compliance rules.

### Token supply management
In the case of a crypto security the supply of tokens is managed by an operator. Operators are able to issue new tokens via the `mint()` function and they can destroy tokens from an account via the `burn()` function. These functions reflect both the technical and legal aspects of token issuance and destruction in line with Ethereum standards. No distinction is made between legal and technical terms at the function level.
These functions align with the semantics of [EIP-5679](./eip-5679.md) for contract‑level mint and burn operations. Referencing EIP‑5679 clarifies expectations around emitting transfer events and interacting with existing tooling.

### Forced transfers
As the result of a legal action, an operator must be able to force a transfer without the sender's consent via `forcedTransfer(address account, address to, uint256 value, bytes data) returns (bool)`. If frozen balance is used, the implementation SHOULD emit TokensUnfrozen(account, value, data) in addition to the standard Transfer event.
An `Enforcement(address enforcer, address account, uint256 amount, bytes data)` event SHOULD be emitted for auditing.

### Frozen tokens
An operator is able to freeze a part of an account's token balance via `freezePartialTokens()` and unfreeze via `unfreezePartialTokens()`. Frozen tokens cannot be transferred using standard [ERC-20](./eip-20.md) transfers. Implementations MAY unfreeze automatically when processing forcedTransfer.

### Pausing transfers
The token includes functionality to pause and unpause transfers via the `pause()` and `unpause()` functions.

When paused, all standard holder-to-holder token transfers are disabled. This ensures that the token contract can be temporarily halted in case of emergencies, legal requirements, or governance decisions. Mint, burn, and forcedTransfer operations are not affected.

The paused state can be queried using the `paused()` view function, which returns true if transfers are currently paused.

### Link to off-chain document
A `termsHash` value is stored that deterministically represents the full document content (SHOULD be SHA-256). The hash is exposed as `bytes32`.
A zero `termsHash` has a special meaning: `unpause()` MUST revert while `termsHash == 0x0`.

### Metadata JSON file
A JSON file is stored in the `metaData` variable that describes metadata about the crypto security in the form of key-value pairs. These metadata shall describe the essential properties of the security in a machine-readable format. It MAY be empty.

## Motivation

The compliant representation of securities on a distributed ledger network (“crypto securities”) remains one of the most prominent use cases for distributed ledger systems. Up until recent developments such activities were not always fully recognized by local securities laws. This led to different views on what information and functionality they should provide. Germany, as one of the first countries in the world, has enhanced its legal framework to fully cover the issuance of securities in electronic form on a distributed ledger network. This standard aims to capture these legal requirements and use them as a framework to define a smart contract interface that enables interactions with crypto securities on-ledger. This standard is backed by the Federal Association of Crypto Registrars and a result of its task force for standardization.

While standards like [ERC-20](./eip-20.md) and [ERC-1155](./eip-1155.md) provide complete interfaces to interact with utility tokens, in order to represent securities in the form of a token more advanced features are necessary. This is caused by two main characteristics of crypto securities:

* In contrast to utility tokens where transfers usually only require the sender to have a sufficient balance, for crypto securities more complex rules can apply that use other data to determine the validity of a transfer. In many cases, token holders with their respective addresses need to be eligible, for example, according to KYC/AML regulation or qualification of the investor to receive and hold tokens.
* Crypto securities need a trusted operator that is granted certain permissions such as pausing transfers or managing the token supply. This trusted operator is sometimes even recognized by local securities laws and licensed by the authorities.

This standard should facilitate the interaction of wallet software, exchanges as well as crypto security operators with different implementations of crypto securities. For wallets and exchanges, this eases the listing of crypto securities no matter who their issuer or operator is. It also makes sure that in case of an operator becoming unavailable, other operators can step in and take over control of the token, securing the rights of token holders.

## Specification

The following specification describes events and functions of a token smart contract representing a crypto security.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174).


### General
Tokens MAY be received by externally owned accounts as well as smart contract accounts ("token holders"). An externally owned account or smart contract account MAY be granted special administrative permissions ("operator"). There MAY be more than one operator.

### Functions
#### `getActiveBalanceOf`
This function MUST return the unfrozen balance of an account. This balance can be used by the token holder for transfers to other account addresses.

```solidity
function getActiveBalanceOf(address tokenHolder) external view returns (uint256);
```

#### `getFrozenTokens`
This function MUST return the frozen balance of an account. Frozen tokens cannot be transferred using standard [ERC-20](./eip-20.md) functions. Implementations MAY support transferring frozen tokens via `forcedTransfer`. This function is informational and does not define compliance behavior.

```solidity
function getFrozenTokens(address tokenHolder) external view returns (uint256);
```

#### `paused`
This function MUST return `true` if token transfers are paused and MUST return `false` otherwise. When `true`, standard holder‑to‑holder transfers MUST revert and `canTransfer()` / `canTransferFrom()` MUST return `false`. The functions `mint`, `burn`, and `forcedTransfer` are not affected.

```solidity
function paused() external view returns (bool);
```

#### `termsHash`
The document hash MUST deterministically represent the full document content. The hashing algorithm SHOULD be SHA-256 and MUST be exposed as `bytes32`.
A terms hash with the value `0x0` has a special meaning: As long as it is `0x0`, transfers cannot be unpaused.


```solidity
function termsHash() external view returns (bytes32);
```

#### `metaData`
This function MUST return a JSON object containing metadata about the crypto security in the form of key-value pairs. It MAY be empty.

```solidity
function metaData() external view returns (string memory);
```

#### `canTransfer`
This function MUST return `true` if `from` is able to transfer `value` tokens to `to` respecting all compliance, investor eligibility and other implemented restrictions. Otherwise it MUST return `false`.
If `paused()` returns `true`, the function MUST return `false`. Balance and access-control checks are out of scope for this function.

```solidity
function canTransfer(address from, address to, uint256 value) external view returns (bool);
```

#### `canTransferFrom`
This function MUST return `true` if `spender` can transfer `value` tokens from `from` to `to` respecting all compliance, investor eligibility and other implemented restrictions. Otherwise it MUST return `false`.
If `paused()` returns `true`, the function MUST return `false`. Balance and access-control checks are out of scope for this function.

```solidity
function canTransferFrom(address spender, address from, address to, uint256 value) external view returns (bool);
```

#### `mint`
This function MUST increase the balance of `to` by `amount` without decreasing the amount of tokens from any other holder. This function MUST revert if the sum of `amount` and the amount of already issued tokens is greater than the total supply. It MUST emit a `Transfer` as well as a `Mint` event. Ideally the `Transfer` event is emitted by the underlying token implementation. Paused transfers SHOULD NOT prevent a mint. The `data` parameter MAY be used to further document the action.

```solidity
function mint(address to, uint256 amount, bytes calldata data) external;
```

#### `burn`
This function MUST reduce the balance of `tokenHolder` by `amount` without increasing the amount of tokens of any other holder. It MUST emit a `Burn` as well as a `Transfer` event. The `Transfer` event MUST contain `0x0` as the recipient account address. The function MUST revert if `tokenHolder`'s balance is less than `amount` (including frozen tokens). It MUST NOT be possible to destroy the supply. It MUST NOT be possible to issue destroyed tokens to other accounts. Paused transfers SHOULD NOT prevent destroying tokens. The `data` parameter MAY be used to further document the action.

```solidity
function burn(address tokenHolder, uint256 amount, bytes calldata data) external;
```

#### `forcedTransfer`
This function MUST transfer `value` tokens from `account` to `to` without requiring the consent of `account`. The function MUST revert if `account`'s balance is less than `value` (including frozen tokens). The function MUST emit a standard `Transfer` event. If frozen balance is used, a `TokensUnfrozen` event SHOULD be emitted. The `data` parameter MAY be used to further document the action.

```solidity
function forcedTransfer(address account, address to, uint256 value, bytes calldata data) external returns (bool);
```

#### `freezePartialTokens`
This function MUST freeze `amount` tokens of `account`. Frozen tokens cannot be transferred to other accounts. The function MUST emit a `TokensFrozen` event. The function MUST revert if `account`'s active balance is less than `amount` (excluding already frozen tokens). The `data` parameter MAY be used to further document the action.

```solidity
function freezePartialTokens(address account, uint256 amount, bytes calldata data) external;
```

#### `unfreezePartialTokens`
This function MUST unfreeze `amount` tokens of `account`. The function MUST emit a `TokensUnfrozen` event. The function MUST revert if `account`'s frozen balance is less than `amount`. The `data` parameter MAY be used to further document the action.

```solidity
function unfreezePartialTokens(address account, uint256 amount, bytes calldata data) external;
```

#### `pause`
Calling this function MUST pause all token transfers. The function MUST revert if the contract is already paused.

```solidity
function pause() external;
```

#### `unpause`
Calling this function MUST unpause all token transfers.
The function MUST revert if the contract is not currently paused.
The function MUST also revert if `termsHash()` returns `0x0`. In all cases, `unpause()` MUST fail unless a non-zero document hash is set on-chain.

```solidity
function unpause() external;
```

#### `setTerms`
This function MUST update the `termsHash` value. `_hash` MUST deterministically represent the full document content. The hashing algorithm SHOULD be SHA-256. It SHOULD emit a `Terms(_hash, _uri)` event.

```solidity
function setTerms(bytes32 _hash, string calldata _uri) external;
```

#### `setMetaData`
 This function MUST update the `metaData` value. `_metadata` MUST be a JSON data structure containing metadata about the crypto security in the form of key-value pairs. It MAY be empty.

 ```solidity
 function setMetaData(string calldata _metadata) external;
 ```

### Events
Alternative event names with equivalent semantics (e.g., a dedicated forced-transfer event vs. a generic Transfer) are allowed; however, a Transfer event MUST be emitted on state-changing token movements.

#### `Mint`
This event MUST be triggered when new tokens are issued increasing the `totalSupply`.

```solidity
event Mint(address indexed minter, address indexed account, uint256 value, bytes data);
```

#### `Burn`
This event MUST be triggered when tokens are destroyed of a `tokenHolder`.

```solidity
event Burn(address indexed burner, address indexed account, uint256 value,
 bytes data);
```

#### `Enforcement`
This event SHOULD be triggered when an enforcement (e.g., forced transfer or forced burn) occurs.

```solidity
event Enforcement(address indexed enforcer, address indexed account, uint256 amount, bytes data);
```

#### `TokensFrozen`
This event SHOULD be triggered if tokens are frozen for an account.

```solidity
event TokensFrozen(address indexed account, uint256 value, bytes data);
```

#### `TokensUnfrozen`
This event SHOULD be triggered if tokens are unfrozen for an account.

```solidity
event TokensUnfrozen(address indexed account, uint256 value, bytes data);
```

#### `Terms`
This event SHOULD be triggered when the `termsHash` value (and/or the associated URI) is updated.

```solidity
event Terms(bytes32 hash, string uri);
```

#### `MetaData`
This event SHOULD be triggered when the `metaData` value is updated.

 ```solidity
event MetaData(string newMetaData);
 ```

### Interface
```solidity
interface IERC7551 {
	// Events
	event Mint(address indexed minter, address indexed account, uint256 value, bytes data);
	event Burn(address indexed burner, address indexed account, uint256 value, bytes data);
	event Enforcement(address indexed enforcer, address indexed account, uint256 amount, bytes data);
	event TokensFrozen(address indexed account, uint256 value, bytes data);
	event TokensUnfrozen(address indexed account, uint256 value, bytes data);
	event Terms(bytes32 hash, string uri);
	event MetaData(string newMetaData);

	// View functions
	function getActiveBalanceOf(address tokenHolder) external view returns (uint256);
	function getFrozenTokens(address tokenHolder) external view returns (uint256);
	function paused() external view returns (bool);
	function termsHash() external view returns (bytes32);
	function metaData() external view returns (string memory);
	function canTransfer(address from, address to, uint256 value) external view returns (bool);
	function canTransferFrom(address spender, address from, address to, uint256 value) external view returns (bool);
	// Operator functions
	function mint(address to, uint256 amount, bytes calldata data) external;
	function burn(address tokenHolder, uint256 amount, bytes calldata data) external;
	function forcedTransfer(address account, address to, uint256 value, bytes calldata data) external returns (bool);
	function freezePartialTokens(address account, uint256 amount, bytes calldata data) external;
	function unfreezePartialTokens(address account, uint256 amount, bytes calldata data) external;
	function pause() external;
	function unpause() external;
	function setTerms(bytes32 _hash, string calldata _uri) external;
	function setMetaData(string calldata _metadata) external;
}
```

## Rationale

This standard is the result of the standardization working group of the German Federal Association of Crypto Registrars. It's based on the smart contract implementations of its members. It contains terminology and abstract ideas also published in the 1400-series security-token standards and [ERC-3643](./eip-3643.md). We would like to thank the initiators of these standards for their work. Both proposals were considered as alternatives to drafting this standard, but we decided to propose an alternative standard instead of using them directly. 

The reasons include: 
- Mandatory identity layer (onchainID): [ERC-3643](./eip-3643.md) tightly couples transfer compliance with a specific decentralized identity framework. This limits flexibility and imposes implementation constraints not aligned with the regulatory environment in certain jurisdictions, such as Germany. 

- Access control model: [ERC-3643](./eip-3643.md) introduces constraints through the Agent role, which reduces flexibility for implementing alternative RBAC systems. 

- Completeness: Some of the features of the 1400-series security-token standards and [ERC-3643](./eip-3643.md) address very specific use cases that are not common to all association members. To support compatibility, we deliberately kept the same function names as [ERC-3643](./eip-3643.md) whenever possible. In contrast, this ERC aims to define a minimal and flexible foundational interface that can be combined with the underlying token standard (e.g. [ERC-20](./eip-20.md) or [ERC-1155](./eip-1155.md)), operator permission management, and compliance modules. 

This standard should not be understood to be a guideline for developing security token implementations. For a full security token implementation, we expect this standard to be combined with the underlying token itself (e.g. based on [ERC-20](./eip-20.md) or [ERC-1155](./eip-1155.md)), permission management and authorization logic for operators, different mechanisms to determine the compliance of a specific token transfer, as well as mechanisms to upgrade the token smart contract logic. In contrast, this interface standard describes minimum requirements for the token smart contract representing a crypto security.

These functions follow the standard OpenZeppelin Pausable pattern and are compatible with existing Ethereum infrastructure.

**Informative note:** Some deployments may prefer not to gate `unpause()` on the presence of an on‑chain terms document. This ERC mandates the `termsHash != 0x0` gate to ensure there is a tamper‑evident, immutable reference to the issuance documents before enabling standard transfers. Jurisdictions that do not require an on‑chain linkage can still deploy the interface and delay setting `termsHash`; until then, standard holder‑to‑holder transfers remain paused while `mint`, `burn`, and `forcedTransfer` remain available.

## Security Considerations

The standard specifications don't include requirements for permission management of operators. Implementations SHOULD make sure that the operator functions can only be executed with sufficient authorization. 

In addition, to be able to fix security issues, the token smart contract's logic SHOULD be upgradable by the operator or another account with sufficient authorization.

The specification puts a lot of trust into the operators because they can manage the token supply and even force transfer token amounts. Therefore, entities managing operator accounts must ensure that they use secure off-chain infrastructures to manage and interact with the smart contract implementation.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
