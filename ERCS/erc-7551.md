---
eip: 7551
title: Crypto Security Token Smart Contract Interface
description: Smart contract interface standard for representing crypto securities
author: Lars Olsson <lars.olsson@cashlink.de>, Hagen Hübel (@itinance) <hagen@token-forge.io>, Markus Kluge <markus@token-forge.io>, Andreas Berghammer <andreas@tokenforge.io>
discussions-to: TODO ADD LINK
status: Draft
type: Standards Track
category: ERC
created: 2023-09-05
---

## Abstract

The compliant representation of securities on a distributed ledger network (“crypto securities”) remains one of the most prominent use cases for distributed ledger systems. Up until recent developments such activities were not always fully recognized by local securities laws. This led to different views on what information and functionality they should provide. Germany, as one of the first countries in the world, has enhanced its legal framework to fully cover the issuance of securities in electronic form on a distributed ledger network. This standard aims to capture these legal requirements and use them as a framework to define a smart contract interface that enables interactions with crypto securities on-ledger. This standard is backed by the Federal Association of Crypto Registrars and a result of its task force for standardization.

The interface is supposed to work on top of additional standards that cover the actual storage of ownership of shares of a security in the form of a token (e.g. ERC-20 or ERC-1155). While the scope of the underlying token standard is to provide an interface for transferring the crypto securities and retrieving individual holder balances, this standard provides the following additional functionality needed by wallet providers and exchanges to handle crypto securities:

### Transfer compliance
In the case of crypto securities the smart contract needs to check if a transfer of tokens is compliant. The specification therefore adds a `canTransfer()` and a `canTransferFrom()` function that can be used to check if a transfer would be successful given the current compliance rules.

### Token supply management
In the case of a crypto security the supply of tokens is managed by an operator. Operators are able to issue new tokens via the `mint()` function and they can destroy tokens from an account via the `burn()` function. These functions reflect both the technical and legal aspects of token issuance and destruction in line with Ethereum standards. No distinction is made between legal and technical terms at the function level.

### Forced transfers
As the result of a legal action, an operator of the crypto security needs to be able to force a transfer between accounts without requiring the consent of the sender. For this, the `forceTransferFrom()` function can be used. This function can also be used to recover tokens of an account where the private key has been lost.

### Frozen tokens
An operator of the security token is able to freeze a part of an account's token balance via the `freezeTokens()` function. Implementations MAY additionally provide a function to freeze the entire balance of an address (e.g. `setAddressFrozen(address,bool,bytes)`). As a result, these tokens cannot be transferred until unfrozen again by the operator using the `unfreezeTokens()` function.

### Pausing transfers
The token includes functionality to pause and unpause transfers via the `pause()` and `unpause()` functions.

When paused, all token transfers are disabled. This ensures that the token contract can be temporarily halted in case of emergencies, legal requirements, or governance decisions.

These functions follow the standard OpenZeppelin Pausable pattern and are compatible with existing Ethereum infrastructure.

The paused state can be queried using the `paused()` view function, which returns true if transfers are currently paused.

### Link to off-chain document
A `paperContractHash` value is added to the smart contract's storage that is meant to be the SHA-256 hash digest integer value of the full binary of a PDF file representing all necessary issuance documents.

### Metadata JSON file
A JSON file is stored in the `metadata` variable that describes metadata about the crypto security in the form of key-value pairs. These metadata shall describe the essential properties of the security in a machine-readable format.

## Motivation

The compliant representation of securities on a distributed ledger network (“crypto securities”) remains one of the most prominent use cases for distributed ledger systems. Up until recent developments such activities were not always fully recognized by local securities laws. This led to different views on what information and functionality they should provide. Germany, as one of the first countries in the world, has enhanced its legal framework to fully cover the issuance of securities in electronic form on a distributed ledger network.
While standards like ERC-20 and ERC-1155 provide complete interfaces to interact with utility tokens, in order to represent securities in the form of a token more advanced features are necessary. This is caused by two main characteristics of crypto securities:

* In contrast to utility tokens where transfers usually only require the sender to have a sufficient balance, for crypto securities more complex rules can apply that use other data to determine the validity of a transfer. In many cases, token holders with their respective addresses need to be eligible, for example, according to KYC/AML regulation or qualification of the investor to receive and hold tokens.
* Crypto securities need a trusted operator that is granted certain permissions such as pausing transfers or managing the token supply. This trusted operator is sometimes even recognized by local securities laws and licensed by the authorities.

This standard should facilitate the interaction of wallet software, exchanges as well as crypto security operators with different implementations of crypto securities. For wallets and exchanges, this eases the listing of crypto securities no matter who their issuer or operator is. It also makes sure that in case of an operator becoming unavailable, other operators can step in and take over control of the token, securing the rights of token holders.

## Specification

The following specification describes events and functions of a token smart contract representing a crypto security.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Semantic Equivalence. Implementations MAY expose function names, parameter orders, return values, or types that differ from the signatures listed in this ERC as long as the observable semantics are equivalent (e.g., inclusion of an additional caller parameter equivalent to msg.sender, amount vs. value, presence or absence of a boolean success return, or bytes32 vs. uint256 for document hashes).

### General
Tokens MAY be received by externally owned accounts as well as smart contract accounts ("token holders"). An externally owned account or smart contract account MAY be granted special administrative permissions ("operator"). There MAY be more than one operator.

### Functions
#### getActiveBalanceOf
This function MUST return the unfrozen balance of an account. This balance can be used by the token holder for transfers to other account addresses.

```solidity
function getActiveBalanceOf(address tokenHolder) external view returns (uint256);
```

#### getFrozenTokens
This function MUST return the frozen balance of an account. It MUST NOT be possible to transfer frozen tokens to other accounts. The implementation MAY provide other ways to transfer frozen tokens. If the sender's unfrozen ("active") balance is less than the amount to be transferred, the `canTransfer()` and `canTransferFrom()` MUST return `false`.

```solidity
function getFrozenTokens(address tokenHolder) external view returns (uint256);
```

#### paused
This function MUST return `true` if token transfers are paused and MUST return `false` otherwise. If this function returns `true`, it MUST NOT be possible to transfer tokens to other accounts and the `canTransfer()` and `canTransferFrom()` MUST return `false`.

```solidity
function paused() external view returns (bool);
```

#### paperContractHash
The document hash MUST deterministically represent the full document content. The hashing algorithm SHOULD be SHA-256 and MAY be exposed as uint256 or bytes32. 
A paper contract hash with the value 0 has a special meaning: As long as it is 0, transfers cannot be unpaused.

```solidity
function paperContractHash() external view returns (uint256);
```

#### metadata
This function MUST return a JSON object containing metadata about the crypto security in the form of key-value pairs. It MAY be empty.

```solidity
function metadata() external view returns (string memory);
```

#### canTransfer
This function MUST return `true` if the message sender is able to transfer `amount` tokens to `to` respecting all compliance, investor eligibility and other implemented restrictions. Otherwise it MUST return `false`.
If paused() returns true, the function MUST return false. If the sender’s active balance is less than amount, the function MUST return false.

```solidity
function canTransfer(address to, uint256 amount) external view returns (bool);
```

#### canTransferFrom
This function MUST return `true` if `from` is able to transfer `amount` tokens to `to` respecting all compliance, investor eligibility and other implemented restrictions. Otherwise it MUST return `false`.
If paused() returns true, the function MUST return false. If the sender’s active balance is less than amount, the function MUST return false.

```solidity
function canTransferFrom(address from, address to, uint256 amount) external view returns (bool);
```

#### mint
This function MUST increase the balance of `to` by `amount` without decreasing the amount of tokens from any other holder. This function MUST throw if the sum of `amount` and the amount of already issued tokens is greater than the total supply. It MUST emit a `Transfer` as well as a `Mint` event. Ideally the `Transfer`event is emitted by the underlying token implementation. Paused transfers SHOULD NOT prevent a mint. The `data` parameter MAY be used to further document the action.

```solidity
function mint(address to, uint256 amount, bytes calldata data) external;
```

#### burn
This function MUST reduce the balance of `tokenHolder` by `amount` without increasing the amount of tokens of any other holder. It MUST emit a `Burn` as well as a `Transfer` event. The `Transfer` event MUST contain `0x0` as the recipient account address. The function MUST throw if `tokenHolder`'s balance is less than `amount` (including frozen tokens). It MUST NOT be possible to destroy the supply. It MUST NOT be possible to issue destroyed tokens to other accounts. Paused transfers SHOULD NOT prevent destroying tokens. The `data` parameter MAY be used to further document the action.

```solidity
function burn(address tokenHolder, uint256 amount, bytes calldata data) external;
```

#### forceTransferFrom
This function MUST transfer `amount` tokens to `to` without requiring the consent of `from`. The function MUST throw if `from`'s balance is less than `amount` (including frozen tokens). The function MUST emit a Transfer event.
If the frozen balance of `from` is used for the transfer a `TokensUnfrozen` event SHOULD be emitted. The `data` parameter MAY be used to further document the action.

```solidity
function forceTransferFrom(address from, address to, uint256 amount, bytes calldata data) external;
```

#### freezeTokens
This function MUST freeze `amount` tokens of `tokenHolder`. Frozen tokens cannot be transferred to other accounts. The function MUST emit a `TokensFrozen` event. The function MUST throw if `tokenHolder`'s active balance is less than `amount` (excluding already frozen tokens). The `data` parameter MAY be used to further document the action.

```solidity
function freezeTokens(address tokenHolder, uint256 amount, bytes calldata data) external;
```

#### unfreezeTokens
This function MUST unfreeze `amount` tokens of `tokenHolder`. The function MUST emit a `TokensUnfrozen` event. The function MUST throw if `tokenHolder`'s frozen balance is less than `amount`. The `data` parameter MAY be used to further document the action.

```solidity
function unfreezeTokens(address tokenHolder, uint256 amount, bytes calldata data) external;
```

#### pause
Calling this function MUST pause all token transfers. The function MUST revert if the contract is already paused.

```solidity
function pause() external;
```

#### unpause
Calling this function MUST unpause all token transfers.
The function MUST revert if the contract is not currently paused.
The function MUST also revert if paperContractHash() returns 0. This requirement equally applies if the implementation exposes the document hash under an alternative function or type (e.g. termsHash() bytes32). In all cases, unpause() MUST fail unless a non-zero document hash is set on-chain.

```solidity
function unpause() external;
```

#### setPaperContractHash
This function MUST update the `paperContractHash` value. `_paperContractHash` MUST deterministically represent the full document content. The hashing algorithm SHOULD be SHA-256. Implementations MAY expose/store the hash as uint256 or bytes32. A paper contract hash with the value 0 has a special meaning: As long as it is 0, transfers cannot be unpaused. An implementation MAY store and expose this document hash under an alternative function name or type (e.g., bytes32), provided that a non-zero value gates unpause() as specified.

```solidity
function setPaperContractHash(uint256 _paperContractHash) external;
```

#### setMetadata
This function MUST update the `metadata` value. `_metadata` MUST be a JSON data structure containing metadata about the crypto security in the form of key-value pairs. It MAY be empty.

```solidity
function setMetadata(string calldata _metadata) external;
```

### Events
Alternative event names with equivalent semantics (e.g., a dedicated forced-transfer event vs. a generic Transfer) are allowed; however, a Transfer event MUST be emitted on state-changing token movements.

#### Mint
This event MUST be triggered when new tokens are issued increasing the `totalSupply`.

```solidity
event Mint(address indexed minter, address indexed to, uint256 amount, bytes data);
```

#### Burn
This event MUST be triggered when tokens are destroyed of a `tokenHolder`.

```solidity
event Burn(address indexed burner, address indexed tokenHolder, uint256 amount,
bytes data);
```

#### ForcedTransfer
This event SHOULD be triggered on a successful call of the `forceTransferFrom()` function.

```solidity
event ForcedTransfer(address indexed from, address indexed to, uint256 amount, bytes data);
```

#### TokensFrozen
This event SHOULD be triggered if tokens are frozen for an account.

```solidity
event TokensFrozen(address indexed tokenHolder, uint256 amount, bytes data);
```

#### TokensUnfrozen
This event SHOULD be triggered if tokens are unfrozen for an account.

```solidity
event TokensUnfrozen(address indexed tokenHolder, uint256 amount, bytes data);
```

#### SetPaperContractHash
This event SHOULD be triggered when the `paperContractHash` value is updated.

```solidity
event SetPaperContractHash(uint256 paperContractHash);
```

#### SetMetadata
This event SHOULD be triggered when the `metadata` value is updated.

```solidity
event SetMetadata(string metadata);
```

### Interface
```solidity
interface IERCXXXX {
	// Events
	event Mint(address indexed minter, address indexed to, uint256 amount, bytes data);
	event Burn(address indexed burner, address indexed tokenHolder, uint256 amount, bytes data);
	event ForcedTransfer(address indexed from, address indexed to, uint256 amount, bytes data);
	event TokensFrozen(address indexed tokenHolder, uint256 amount, bytes data);
	event TokensUnfrozen(address indexed tokenHolder, uint256 amount, bytes data);
	event SetPaperContractHash(uint256 paperContractHash);
	event SetMetadata(string metadata);

	// View functions
	function getActiveBalanceOf(address tokenHolder) external view returns (uint256);
	function getFrozenTokens(address tokenHolder) external view returns (uint256);
	function paused() external view returns (bool);
	function paperContractHash() external view returns (uint256);
	function metadata() external view returns (string memory);
	function canTransfer(address to, uint256 amount) external view returns (bool);
	function canTransferFrom(address from, address to, uint256 amount) external view returns (bool);
	// Operator functions
	function mint(address to, uint256 amount, bytes calldata data) external;
	function burn(address tokenHolder, uint256 amount, bytes calldata data) external;
	function forceTransferFrom(address from, address to, uint256 amount, bytes calldata data) external;
	function freezeTokens(address tokenHolder, uint256 amount, bytes calldata data) external;
	function unfreezeTokens(address tokenHolder, uint256 amount, bytes calldata data) external;
	function pause() external;
	function unpause() external;
	function setPaperContractHash(uint256 _paperContractHash) external;
	function setMetadata(string calldata _metadata) external;
}
```

## Rationale

This standard is the result of the standardization working group of the German Federal Association of Crypto Registrars. It’s based on the smart contract implementations of its members. It contains terminology and abstract ideas also published in [ERC-1400](./erc-1400.md) and [ERC-3643](./erc-3643.md). We would like to thank the initiators of these standards for their work. Both proposals were considered as alternatives to drafting this standard, but we decided to propose an alternative standard instead of using them directly. 

The reasons include: 
- Mandatory identity layer (onchainID): ERC-3643 tightly couples transfer compliance with a specific decentralized identity framework. This limits flexibility and imposes implementation constraints not aligned with the regulatory environment in certain jurisdictions, such as Germany. 

- Access control model: ERC-3643 introduces constraints through the Agent role, which reduces flexibility for implementing alternative RBAC systems. 

- Completeness: Some of the features of ERC-1400 and ERC-3643 address very specific use cases that are not common to all association members. To support compatibility, we deliberately kept the same function names as ERC-3643 whenever possible. In contrast, ERC-7551 aims to define a minimal and flexible foundational interface that can be combined with the underlying token standard (e.g. ERC-20 or ERC-1155), operator permission management, and compliance modules. 

This standard should not be understood to be a guideline for developing security token implementations. For a full security token implementation, we expect this standard to be combined with the underlying token itself (e.g. based on [EIP-20](./eip-20.md) or [EIP-1155](./eip-1155.md))), permission management and authorization logic for operators, different mechanisms to determine the compliance of a specific token transfer, as well as mechanisms to upgrade the token smart contract logic. In contrast, this interface standard describes minimum requirements for the token smart contract representing a crypto security.

## Security Considerations

The standard specifications don't include requirements for permission management of operators. Implementations SHOULD make sure that the operator functions can only be executed with sufficient authorization. 

In addition, to be able to fix security issues, the token smart contract's logic SHOULD be upgradable by the operator or another account with sufficient authorization.

The specification puts a lot of trust into the operators because they can manage the token supply and even force transfer token amounts. Therefore, entities managing operator accounts must ensure that they use secure off-chain infrastructures to manage and interact with the smart contract implementation.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
