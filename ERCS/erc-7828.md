---
eip: 7828
title: Interoperable Names using ENS
description: An extension of the Interoperable Name format defined in ERC-7930 to allow for chain discovery using ENS, and address definition using established naming services.
author: Sam Kaufman (@SampkaML), Marco Stronati (@paracetamolo), Yuliya Alexiev (@yuliyaalexiev), Jeff Lau (@jefflau), Sam Wilson (@samwilsn), Vitalik Buterin (@vbuterin), Teddy (@0xteddybear), Joxes (@Joxess), Racu (@0xRacoon), Skeletor Spaceman (@0xskeletor-spaceman), TiTi (@0xtiti), Gori (@0xGorilla), Ardy (@0xArdy), Onizuka (@onizuka-wl), Lumi (@oxlumi), Moebius (@0xmoebius), Thomas Clowes (@clowestab), Prem Makeig (@nxt3d)
discussions-to: https://ethereum-magicians.org/t/erc-7828-chain-specific-addresses-using-ens/21930
status: Draft
type: Standards Track
category: ERC
created: 2024-11-27
requires: 155, 7930
---

## Abstract

This proposal extends the definition of an _Interoperable Name_ outlined in [ERC-7930](./eip-7930.md). 

The `<chain>` component definition is extended to allow for a human-readable chain name to be used. This identifier is resolved to an [ERC-7930] _Interoperable Address_ using the Ethereum Name Service (ENS). This moves chain metadata discovery on-chain.

The `<address>` component definition is extended to allow usage of ENS names as well as names from other naming services.


## Motivation

The mapping from chain names to identifiers has, since [EIP-155](./eip-155.md), been maintained off-chain using a centralized list. 

This solution has a few shortcomings:

- It does not scale with the growing number of L2s
- The list maintainer is a trusted centralized entity
- It does not currently support non-EVM chains

This specification proposes that the `<chain>` component of the _Interoperable Name_ definition outlined in [ERC-7930] be extended to allow for a human-readable chain name resolved on-chain via ENS. This registry would provide a single source of truth for mapping a chain name to an [ERC-7930] _Interoperable Address_ and associated chain metadata.

In the same spirit, we propose that the `<address>` component of the definition allow for a human-readable name to be utilized. By coupling the TLD to the resolution method used, this standard could leverage current and future features of ENS as well as other naming systems.

The flexibility of this specification and the underlying naming systems can be leveraged to allow for different addresses on different chains to be represented by the same human-readable string. This mitigates the risk of sending funds to an address the intended recipient doesn't actually control.

The usage of human-readable names provides additional clarity and confidence to users.

Desired properties:

- Compatibility with [ERC-7930](./eip-7930.md).
- Support for domain names as well as raw addresses within the `<address>` component of the _Interoperable Address_. 
- Independent resolution of the `<address>` and `<chain>` components of the _Interoperable Address_ subject to the underlying naming systems resolution process.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Where not otherwise specified definitions, rules, and expectations are inherited from [ERC-7930].

### Interoperable Name Definition

Recall that [ERC-7930] defines an _Interoperable Name_ as a human readable representation of an underlying _Interoperable Address_.

It's format is `<address> @ <chain> # <checksum>`

These components now have the following extended definitions:

```bnf
<address>     := <raw-address> | <name-service-domain>
<chain>       := <caip-2-chain-id> | <chain-label>
```

These components have the following meanings:

`<raw-address>` is the namespace specific text representation of an address. For example chains within the `eip155` namespace utilize a 20-byte hex-encoded address format, whilst chains within the `bip122` namespace utilize a base58/bech32 encoded address format.

`<name-service-domain>` is a domain name from a known, and supported naming service. For example an Ethereum Name Service (ENS) name like `example.eth`. These names should be resolved to a `<raw-address>` subject to the resolution specifications of the name service in question.

`<caip-2-chain-id>` is the string representation of the [CAIP-2] blockchain identifier. For example, `eip155:1` or `bip122:000000000019d6689c085ae165831e93`. An ERC-7828 _Interoperable Name_ MUST specify both the namespace and reference elements of the CAIP-2 identifier as ENS resolves addresses on a chain specific basis.

`<chain-label>` is a human readable identifier for the chain, defined and registered as a subdomain of the `<namespace>.eth` ENS name. An on-chain registry-resolver maps these labels to their corresponding canonical [ERC-7930] chain identifiers, and exposes additional chain metadata through text records.

`<checksum>` A 4-byte checksum calculated as defined in [ERC-7930]. It is optional and can be used to verify the integrity of the _Interoperable Name_.

This extended definition allows an _Interoperable Name_ to mix and match _resolved_ and _unresolved_ representations of addresses and chains.

#### Checksums

It is not guaranteed that an ENS name defined within the `<address>` component will always resolve to the same address. This is exactly why checksums are useful. 

In some cases resolvers return a new address on each resolution. In this scenario the validation of a previously generated checksum will always fail. 

When checksum validation fails clients MUST alert the user and require explicit user input to continue with the operation.

### Examples

#### Ethereum Mainnet

The address `0x123..789` on Ethereum Mainnet could be represented as either of the following:

```
0x123..789@eip155:1#FFFFFFFF
0x123..789@ethereum#FFFFFFFF
```

The checksum is optional and is calculated as outlined in [ERC-7930].

If the ENS name `example.eth` resolved to `0x123..789` subject to the ENS resolution process outlined in ENSIP-9, then the same information could be represented as:

```
example.eth@eip155:1#FFFFFFFF
example.eth@ethereum#FFFFFFFF
```

While `alice.eth@eip155#FFFFFFFF` is a valid [ERC-7930] _Interoperable Name_, is it not a valid ERC-7828 _Interoperable Name_. It's `<chain>` component must include both a [CAIP-2] namespace and reference as the address to which an ENS name resolves is `ChainReference` dependent. 

#### Non-EVM chains

The address `bc1..23` on Bitcoin Mainnet could be represented as:

```
bc1..23@bip122:000000000019d6689c085ae165831e93#CCCCCCCC
bc1..23@bitcoin#CCCCCCCC
```

If the ENS name `example.eth` resolved to `bc1..23` subject to the ENS resolution process outlined in ENSIP-9, then the same information could be represented as:

```
example.eth@bip122:000000000019d6689c085ae165831e93#CCCCCCCC
example.eth@bitcoin#CCCCCCCC
```

### Resolving chain names

If the `<chain>` component matches the regular expression `[a-z-]+` it is to be interpreted as a label under a reserved ENS second-level domain, `<namespace>.eth`. It should be resolved subject to the ENS resolution process.

If the `<chain>` is `ethereum`, you would resolve the `chain-id` data record for `ethereum.<namespace>.eth` subject to ENSIP-24: Arbitrary Data Resolution.

Behind the scenes an all-in-one Registry-Resolver smart contract acts as a single source of truth for mapping these human-readable chain names to their corresponding chain identifiers encoded in the [ERC-7930] binary format.


### Reverse resolution

In the context of this specification 'Reverse Resolution' refers to the process of discerning the `<chain-label>` of a chain from its _Interoperable Address_.

ENSIP-5: Text Records defines an interface for resolving arbitrary text data for a specific key.

This specification utilizes the [ERC-7930] _Interoperable Address_ prefixed with `chain-name:` as the key for discerning the associated chain name.

The client must query `reverse.<namespace>.eth` to reverse resolve an _Interoperable Address_. This MUST be enforced within the implementation of the Registry-Resolver contract assigned to `<namespace>.eth`


### Discoverability

The `ChainResolver` exposes the public `chainCount` property. The `getChainAtIndex` method allows a client to fetch the label, and name associated with the chain at a specific index. This simple getter allows clients to discern all known chains without any external dependencies. 

## Rationale

Using ENS as an on-chain single source of truth for surfacing chain data is appropriate noting the prominence and reputation of ENS across blockchain ecosystems. ENS has been around since 2017, is well battle tested, and has a simple and well defined architecture that allows for a clean, simple, and accesible implementation of a chain registry.

An _Interoperable Address_ is binary data of arbitrary length. Using ENSIP-5: Text Records would not be appropriate as the data being represented is not.. text. ENSIP-24 allows for the resolution of arbitrary data.

For the inverse reason, surfacing the chain name through the text record standard is appropriate.

## Backwards Compatibility

This specification extends upon the definition of _Interoperable Name_ outlined in [ERC-7930]. There are no breaking changes.

## Reference Implementation

This section is non-normative, as future ENSIPs can modify the way in which ENS text records, and arbitrary data are resolved using ENS. Its purpose is to demonstrate how a human-readable _Interoperable Name_ is resolved to a binary [ERC-7930] _Interoperable Address_ that can be used for protocol level interactions using current ENSIP standards.

The implementation of `ChainResolver` is an all-in-one registry-resolver assigned as the resolver on `<namespace.eth>`. The implementation supports all current ENSIPs relating to resolution, through its implementation of the `IExtendedResolver` interface defined in ENSIP-10: Wildcard Resolution.

### Forward resolution

The example below describes a possible flow for a user facing wallet. Lets assume that the user wants to send funds to a user on Optimism.

#### Step 1: User Input
1. Let the user input an ENS name. For examples, `alice.eth`.
2. Let the user select a chain. In this case, the user would select 'Optimism'.

#### Step 2: Build the _Interoperable Name_
3. The underlying label for 'Optimism' is 'optimism'. Append `<namespace.eth>` to that label => `optimism.<namespace>.eth`

#### Step 3: Resolve the [ERC-7930] _Interoperable Address_
4. Discern the resolver for `optimism.<namespace>.eth` and resolve `data(bytes32 namehash, string key)` (ENSIP-24: Arbitrary Data Resolution) passing in the `namehash` (see ENSIP-1) of `optimism.<namespace>.eth` and the key, `chain-id`. 

#### Step 4: Resolve alice.eth **for** the specified chain
5. Extract the CAIP-2 `ChainReference` from the [ERC-7930] identifier returned in the previous step.
6. Convert the `ChainReference` into an ENS `coinType` (see ENSIP-11).
7. Compute the `namehash` of the name inputted in step 1, `alice.eth` (see ENSIP-1) => `0x787192fc5378cc32aa956ddfdedbf26b24e8d78e40109add0eea2c1a012c3dec`.
8. Query the ENS registry for the appropriate resolver for `alice.eth` (see ENSIP-1 / ENSIP-10).
9. Call `resolve(bytes calldata name, bytes calldata data)` (ENSIP-10) passing the DNS Encoded representation of `alice.eth` (`0x05616c6963650365746800`), and the ABI encoded calldata for `addr(bytes32 node, uint256 coinType)` as arguments. 

#### Step 5: ERC-7930 packaging

At this point we have discerned the 20 bytes address for alice.eth on Optimism. Assume that it is `0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa`.

10. Serialize `ChainType`, `ChainReferenceLength`, `ChainReference`, `AddressLength` and `Address` according to [ERC-7930] => `[ 0002 0000 01 0A 14 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ]`
11. This is your _Interoperable Address_ => `0x00020000010A14AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`
12. Optionally compute the checksum as described in [ERC-7930] (`0xC69BEB13`), and display it to the user.

### Reverse Resolution

It is also possible to discern a chain name from an _Interoperable Address_.

1. We build the key for the relevant text record (ENSIP-5) as outlined in the specification above. This is `chain-name:0x00020000010A14AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`
2. Query the ENS registry for the appropriate resolver for `reverse.<namespace>.eth` (see ENSIP-1 / ENSIP-10).
3. Discern the ABI encoded calldata for `text(bytes32 node, string key)` with the namehash of `reverse.<namespace>.eth` and the key calculated above as arguments.
4. Call `resolve(bytes calldata name, bytes calldata data)` (see ENSIP-10) passing in the DNS encoded representation of `reverse.<namespace>.eth` and the calldata calculated in the previous steps.

## Security Considerations

Consideration should be given to ENSIP-15: Name Normalization so as to avoid homograph attacks. 

Wherever possible clients should utilize the optional checksum outlined in [ERC-7930]. It should be verified when a raw _Interoperable Name_ is pasted, and it should be appended when an _Interoperable Name_ is being generated based on user input.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).

[CAIP-2]: https://github.com/ChainAgnostic/CAIPs/blob/2a7d42aebaffa42d1017c702974395ff5c1b3636/CAIPs/caip-2.md
[EIP-155]: (./eip-155.md)
[ERC-7930]: (./eip-7930.md)
[ERC-2304]: (./eip-2304.md)
[BIP-44]: (https://github.com/bitcoin/bips/blob/1d371a58978fd2f313c9d162762de04d3b697bf5/bip-0044.mediawiki)
