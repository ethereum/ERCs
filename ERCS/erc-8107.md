---
eip: 8107
title: ENS Trust Registry for Agent Coordination
description: Web of trust validation using ENS names for ERC-8001 multi-party coordination
author: Kwame Bryan (@KBryan)
discussions-to: https://ethereum-magicians.org/t/erc-ens-trust-registry-for-agent-coordination/27200
status: Draft
type: Standards Track
category: ERC
created: 2025-12-16
requires: 137, 712, 1271, 8001
---

## Abstract

This ERC defines a **Trust Registry** that enables agents to establish and query transitive trust relationships using ENS names as identifiers. Trust is expressed at four levels (Unknown, None, Marginal, Full) and propagates through signature chains following the GNU Privacy Guard (GnuPG) web of trust model.

The registry serves as the **reputation module** anticipated by [ERC-8001](./eip-8001), enabling coordinators to gate participation based on trust graph proximity. An agent is considered valid from a coordinator's perspective if sufficient trust paths exist between them.

This standard specifies trust attestation structures, the transitive validation algorithm, ENS integration semantics, anchor-based Sybil resistance, gas-efficient path verification, and [ERC-8001](./eip-8001) coordination hooks.

## Motivation

[ERC-8001](./eip-8001) defines minimal primitives for multi-party agent coordination but explicitly defers reputation to modules:

> "Privacy, thresholds, bonding, and cross-chain are left to modules."

And in Security Considerations:

> "Equivocation: A participant can sign conflicting intents. Mitigate with module-level slashing or reputation."

This ERC provides that reputation module. Before coordinating, agents need answers to:

1. **"Should I include this agent in my coordination?"** — Participant selection
2. **"Can I trust this agent's judgment about other agents?"** — Transitive trust
3. **"How do I update trust based on coordination outcomes?"** — Trust maintenance

### Why Web of Trust?

The web of trust model, proven over 25+ years in GnuPG, solves the bootstrap problem: how do you establish trust with unknown agents without a centralised registrar?

| GnuPG Concept | This Standard |
|---------------|---------------|
| Public key | ENS name |
| Key signing | Trust attestation |
| Owner trust levels | `TrustLevel` enum |
| Key validity | Agent validity for coordination |
| Certification path | Trust chain through agents |

### Why ENS?

ENS provides a battle-tested, finalized identity layer:

- **Stable identifiers** that survive key rotation
- **Ownership semantics** via `owner()` and `isApprovedForAll()`
- **Human readable** names (`alice.agents.eth` not `0x742d...`)
- **Subdomain delegation** for protocol-issued agent identities
- **L2 support** via CCIP-Read

Using ENS avoids dependency on draft identity standards while remaining compatible with future standards through adapter patterns.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Overview

This ERC specifies:

* Trust levels and their semantics
* ENS-indexed trust attestation structures
* [EIP-712](./eip-712) typed data for signing attestations
* The `ITrustRegistry` interface
* Web of trust validation algorithm with anchor support
* Gas-efficient path verification
* [ERC-8001](./eip-8001) integration hooks
* Error surface and events

### Trust Levels

Implementations MUST use the canonical enum:

```solidity
enum TrustLevel {
    Unknown,   // 0: No trust relationship established
    None,      // 1: Explicitly distrusted
    Marginal,  // 2: Partial trust — multiple required for validation
    Full       // 3: Complete trust — single attestation sufficient
}
```

**Semantic definitions:**

| Level | Meaning | Validation Contribution |
|-------|---------|------------------------|
| `Unknown` | Default state; no data about agent | Cannot contribute to validation |
| `None` | Agent known to behave improperly | Explicitly excluded; voids trust paths containing this agent |
| `Marginal` | Agent generally trustworthy | Contributes partial weight; multiple required |
| `Full` | Agent's judgment equals own verification | Single attestation sufficient for validation |

### ENS Integration

The Trust Registry uses ENS namehashes as agent identifiers.

```solidity
// ENS namehash computation (per ERC-137)
bytes32 node = keccak256(abi.encodePacked(
    keccak256(abi.encodePacked(bytes32(0), keccak256("eth"))),
    keccak256("alice")
));
// node = namehash("alice.eth")
```

#### Controller Resolution

An address is authorized to act for an ENS name if:

```solidity
function isAuthorized(bytes32 node, address actor) internal view returns (bool) {
    address owner = ens.owner(node);
    return actor == owner || ens.isApprovedForAll(owner, actor);
}
```

Implementations MUST verify authorization before accepting trust attestations.

### EIP-712 Domain

Implementations MUST use the following [EIP-712](./eip-712) domain:

```solidity
EIP712Domain({
    name: "ERC-8107-Trust",
    version: "1",
    chainId: block.chainid,
    verifyingContract: address(this)
})
```

Implementations SHOULD expose the domain via [EIP-5267](./eip-5267).

### Primary Types

```solidity
struct TrustAttestation {
    bytes32 trustorNode;       // ENS namehash of trustor
    bytes32 trusteeNode;       // ENS namehash of trustee
    TrustLevel level;          // Trust level assigned
    bytes32 scope;             // Scope restriction; bytes32(0) = universal
    uint64 expiry;             // Unix timestamp; 0 = no expiry
    uint64 nonce;              // Per-trustor monotonic nonce
}

struct ValidationParams {
    uint8 maxPathLength;       // Maximum trust chain depth (1-10)
    uint8 marginalThreshold;   // Marginal attestations required at terminal depth
    uint8 fullThreshold;       // Full attestations required (typically 1)
    bytes32 scope;             // Required scope; bytes32(0) = any
    bool enforceExpiry;        // Check expiry on all chain elements
    bytes32[] requiredAnchors; // Path MUST traverse at least one anchor; empty = no requirement
}

struct TrustPath {
    bytes32[] nodes;           // [validator, ...intermediaries..., target]
    uint64[] attestedAt;       // Block timestamp when each edge was attested
}
```

#### Default Validation Parameters

When not specified, implementations SHOULD use:

```solidity
ValidationParams({
    maxPathLength: 5,
    marginalThreshold: 3,
    fullThreshold: 1,
    scope: bytes32(0),
    enforceExpiry: true,
    requiredAnchors: new bytes32[](0)
})
```

#### Validation Parameters Constraints

Implementations MUST reject `ValidationParams` where:

* `maxPathLength == 0` or `maxPathLength > 10`
* `marginalThreshold == 0`
* `fullThreshold == 0`
* `requiredAnchors.length > 10`

### Typed Data Hashes

```solidity
bytes32 constant TRUST_ATTESTATION_TYPEHASH = keccak256(
    "TrustAttestation(bytes32 trustorNode,bytes32 trusteeNode,uint8 level,bytes32 scope,uint64 expiry,uint64 nonce)"
);

function hashAttestation(TrustAttestation calldata att) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        TRUST_ATTESTATION_TYPEHASH,
        att.trustorNode,
        att.trusteeNode,
        uint8(att.level),
        att.scope,
        att.expiry,
        att.nonce
    ));
}
```

### Interface

Implementations MUST expose the following interface:

```solidity
interface ITrustRegistry {
    // ═══════════════════════════════════════════════════════════════════
    // Events
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Emitted when trust is set or updated
    event TrustSet(
        bytes32 indexed trustorNode,
        bytes32 indexed trusteeNode,
        TrustLevel level,
        bytes32 indexed scope,
        uint64 expiry
    );

    /// @notice Emitted when trust is explicitly revoked
    event TrustRevoked(
        bytes32 indexed trustorNode,
        bytes32 indexed trusteeNode,
        string reason
    );

    /// @notice Emitted when an identity gate is configured
    event IdentityGateSet(
        bytes32 indexed coordinationType,
        bytes32 indexed gatekeeperNode,
        uint8 maxPathLength,
        uint8 marginalThreshold
    );

    /// @notice Emitted when an identity gate is removed
    event IdentityGateRemoved(bytes32 indexed coordinationType);

    // ═══════════════════════════════════════════════════════════════════
    // Trust Management
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Set trust level for another agent
    /// @param attestation The trust attestation
    /// @param signature EIP-712 signature from trustor's controller
    function setTrust(
        TrustAttestation calldata attestation,
        bytes calldata signature
    ) external;

    /// @notice Batch set multiple trust relationships
    /// @param attestations Array of trust attestations
    /// @param signatures Corresponding signatures
    function setTrustBatch(
        TrustAttestation[] calldata attestations,
        bytes[] calldata signatures
    ) external;

    /// @notice Revoke trust (sets level to None)
    /// @param trustorNode The trustor's ENS namehash (caller must be authorized)
    /// @param trusteeNode The agent to revoke trust from
    /// @param reason Human-readable reason for revocation
    function revokeTrust(
        bytes32 trustorNode,
        bytes32 trusteeNode,
        string calldata reason
    ) external;

    /// @notice Get trust record between two agents
    /// @param trustorNode The trusting agent
    /// @param trusteeNode The trusted agent
    /// @return level Current trust level
    /// @return scope Trust scope
    /// @return expiry Expiration timestamp (0 = never)
    /// @return attestedAt Block timestamp when trust was set
    function getTrust(
        bytes32 trustorNode,
        bytes32 trusteeNode
    ) external view returns (
        TrustLevel level,
        bytes32 scope,
        uint64 expiry,
        uint64 attestedAt
    );

    /// @notice Get current nonce for a trustor
    /// @param trustorNode The agent's ENS namehash
    /// @return Current nonce value
    function getNonce(bytes32 trustorNode) external view returns (uint64);

    /// @notice Get agents trusted by a given agent (paginated)
    /// @param trustorNode The trusting agent
    /// @param minLevel Minimum trust level to include
    /// @param offset Starting index for pagination
    /// @param limit Maximum number of results (capped at 100)
    /// @return trustees Array of trusted agent namehashes
    /// @return total Total count of trustees at or above minLevel
    function getTrustees(
        bytes32 trustorNode,
        TrustLevel minLevel,
        uint256 offset,
        uint256 limit
    ) external view returns (bytes32[] memory trustees, uint256 total);

    /// @notice Get agents that trust a given agent (paginated)
    /// @param trusteeNode The trusted agent
    /// @param minLevel Minimum trust level to include
    /// @param offset Starting index for pagination
    /// @param limit Maximum number of results (capped at 100)
    /// @return trustors Array of trusting agent namehashes
    /// @return total Total count of trustors at or above minLevel
    function getTrustors(
        bytes32 trusteeNode,
        TrustLevel minLevel,
        uint256 offset,
        uint256 limit
    ) external view returns (bytes32[] memory trustors, uint256 total);

    // ═══════════════════════════════════════════════════════════════════
    // Web of Trust Validation
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Validate an agent through the web of trust
    /// @dev For gas efficiency, prefer verifyPath() with pre-computed paths
    /// @param validatorNode The validating agent's perspective
    /// @param targetNode The agent to validate
    /// @param params Validation parameters
    /// @return isValid Whether the target is valid
    /// @return pathLength Shortest path found (0 = direct trust)
    /// @return marginalCount Marginal attestations contributing
    /// @return fullCount Full attestations contributing
    function validateAgent(
        bytes32 validatorNode,
        bytes32 targetNode,
        ValidationParams calldata params
    ) external view returns (
        bool isValid,
        uint8 pathLength,
        uint8 marginalCount,
        uint8 fullCount
    );

    /// @notice Verify a pre-computed trust path
    /// @dev Gas-efficient alternative to validateAgent for known paths
    /// @param path The trust path to verify
    /// @param params Validation parameters
    /// @return valid Whether the path satisfies validation requirements
    /// @return anchorSatisfied Whether requiredAnchors constraint is met
    function verifyPath(
        TrustPath calldata path,
        ValidationParams calldata params
    ) external view returns (bool valid, bool anchorSatisfied);

    /// @notice Batch validate multiple agents
    /// @param validatorNode The validating agent's perspective
    /// @param targetNodes Agents to validate
    /// @param params Validation parameters
    /// @return results Validation result for each target
    function validateAgentBatch(
        bytes32 validatorNode,
        bytes32[] calldata targetNodes,
        ValidationParams calldata params
    ) external view returns (bool[] memory results);

    /// @notice Check if any trust path exists (without full validation)
    /// @param fromNode Starting agent
    /// @param toNode Ending agent
    /// @param maxDepth Maximum path length to search
    /// @return exists Whether any path exists
    /// @return depth Length of shortest path found
    function pathExists(
        bytes32 fromNode,
        bytes32 toNode,
        uint8 maxDepth
    ) external view returns (bool exists, uint8 depth);

    // ═══════════════════════════════════════════════════════════════════
    // ERC-8001 Integration
    // ═══════════════════════════════════════════════════════════════════

    /// @notice Set identity gate for a coordination type
    /// @param coordinationType The ERC-8001 coordination type
    /// @param gatekeeperNode Agent whose trust graph gates entry
    /// @param params Validation parameters for the gate
    function setIdentityGate(
        bytes32 coordinationType,
        bytes32 gatekeeperNode,
        ValidationParams calldata params
    ) external;

    /// @notice Remove identity gate for a coordination type
    /// @param coordinationType The ERC-8001 coordination type
    function removeIdentityGate(bytes32 coordinationType) external;

    /// @notice Get identity gate configuration
    /// @param coordinationType The ERC-8001 coordination type
    /// @return gatekeeperNode The gatekeeper agent
    /// @return params Validation parameters
    /// @return enabled Whether the gate is active
    function getIdentityGate(
        bytes32 coordinationType
    ) external view returns (
        bytes32 gatekeeperNode,
        ValidationParams memory params,
        bool enabled
    );

    /// @notice Validate participant for ERC-8001 coordination
    /// @param coordinationType The ERC-8001 coordination type
    /// @param participantNode Agent seeking to participate
    /// @return isValid Whether participant passes the gate
    function validateParticipant(
        bytes32 coordinationType,
        bytes32 participantNode
    ) external view returns (bool isValid);

    /// @notice Validate participant using pre-computed path
    /// @param coordinationType The ERC-8001 coordination type
    /// @param path Pre-computed trust path from gatekeeper to participant
    /// @return isValid Whether participant passes the gate
    function validateParticipantWithPath(
        bytes32 coordinationType,
        TrustPath calldata path
    ) external view returns (bool isValid);

    /// @notice Batch validate participants for coordination
    /// @param coordinationType The ERC-8001 coordination type
    /// @param participantNodes Agents seeking to participate
    /// @return results Validation result for each participant
    function validateParticipantBatch(
        bytes32 coordinationType,
        bytes32[] calldata participantNodes
    ) external view returns (bool[] memory results);
}
```

### Semantics

#### `setTrust`

`setTrust` MUST revert if:

* `attestation.trustorNode == attestation.trusteeNode` (self-trust prohibited)
* `attestation.nonce <= getNonce(attestation.trustorNode)`
* `attestation.expiry != 0 && attestation.expiry <= block.timestamp`
* The signature does not recover to an address authorized for `trustorNode`
* The ENS name for `trustorNode` does not exist (owner is zero address)

If valid:

* The trust record MUST be stored with `attestedAt = block.timestamp`
* `getNonce(trustorNode)` MUST return the attestation's nonce
* `TrustSet` MUST be emitted
* If this is a new relationship (previous level was `Unknown`), the trustee MUST be added to the trustor's trustee list and vice versa

#### `revokeTrust`

`revokeTrust` MUST revert if:

* Caller is not authorized for `trustorNode`
* No existing trust relationship exists (level is `Unknown`)

If valid:

* Trust level MUST be set to `None`
* `attestedAt` MUST be updated to `block.timestamp`
* `TrustRevoked` MUST be emitted
* The relationship MUST remain in storage (not deleted) to preserve the explicit distrust

#### `validateAgent` — Web of Trust Algorithm

The validation algorithm determines if `targetNode` is valid from `validatorNode`'s perspective.

**Validation succeeds if ANY of the following conditions are met:**

1. **Self-validation**: `validatorNode == targetNode`

2. **Direct trust**: `getTrust(validatorNode, targetNode).level >= Marginal` and scope/expiry constraints are satisfied

3. **Full-trust delegation**: There exists an agent F where:
   * `getTrust(validatorNode, F).level == Full`
   * `getTrust(F, targetNode).level >= Marginal`
   * Both edges satisfy scope/expiry constraints
   * Path length is 1

4. **Marginal accumulation**: There exist distinct agents M₁, M₂, ..., Mₙ where:
   * `n >= params.marginalThreshold`
   * `getTrust(validatorNode, Mᵢ).level >= Marginal` for all i
   * `getTrust(Mᵢ, targetNode).level >= Marginal` for all i
   * All edges satisfy scope/expiry constraints
   * All Mᵢ are distinct (same agent cannot contribute multiple times)
   * Path length is 1

5. **Transitive validation**: There exists a path `[validatorNode → A₁ → A₂ → ... → Aₖ → targetNode]` where:
   * `k < params.maxPathLength`
   * Each edge represents trust at level `>= Marginal`
   * All edges satisfy scope/expiry constraints
   * The terminal validation (Aₖ validates targetNode) satisfies conditions 2-4

**Path voiding:**

A trust level of `None` anywhere in a path voids the entire path. Specifically:

* If any `getTrust(Aᵢ, Aᵢ₊₁).level == None`, the path through that edge is invalid
* If `getTrust(validatorNode, X).level == None`, agent X cannot appear in any valid path

**Scope filtering:**

If `params.scope != bytes32(0)`, only trust records where `scope == bytes32(0)` (universal) or `scope == params.scope` contribute to validation.

**Expiry enforcement:**

If `params.enforceExpiry == true`, trust records where `expiry != 0 && expiry <= block.timestamp` MUST NOT contribute to validation.

**Anchor requirement:**

If `params.requiredAnchors` is non-empty, at least one node in the path (excluding validator and target) MUST be present in `requiredAnchors`. This provides Sybil resistance by requiring paths to traverse established community nodes.

**Marginal accumulation scope:**

Marginal attestations only accumulate at the same path depth. An agent providing marginal trust at depth 1 and another at depth 2 do not combine.

**Cycle prevention:**

The algorithm MUST NOT revisit nodes already in the current path.

#### `verifyPath`

`verifyPath` provides gas-efficient validation for pre-computed paths.

```solidity
function verifyPath(
    TrustPath calldata path,
    ValidationParams calldata params
) external view returns (bool valid, bool anchorSatisfied) {
    // Path must have at least 2 nodes (validator and target)
    if (path.nodes.length < 2) return (false, false);
    
    // Path length constraint
    if (path.nodes.length - 1 > params.maxPathLength) return (false, false);
    
    // Check each edge
    bool foundAnchor = params.requiredAnchors.length == 0;
    for (uint256 i = 0; i < path.nodes.length - 1; i++) {
        (TrustLevel level, bytes32 scope, uint64 expiry, ) = 
            getTrust(path.nodes[i], path.nodes[i + 1]);
        
        // Must have at least Marginal trust
        if (level < TrustLevel.Marginal) return (false, foundAnchor);
        
        // None explicitly voids
        if (level == TrustLevel.None) return (false, foundAnchor);
        
        // Scope check
        if (params.scope != bytes32(0) && scope != bytes32(0) && scope != params.scope) {
            return (false, foundAnchor);
        }
        
        // Expiry check
        if (params.enforceExpiry && expiry != 0 && expiry <= block.timestamp) {
            return (false, foundAnchor);
        }
        
        // Anchor check (intermediate nodes only)
        if (!foundAnchor && i > 0 && i < path.nodes.length - 1) {
            for (uint256 j = 0; j < params.requiredAnchors.length; j++) {
                if (path.nodes[i] == params.requiredAnchors[j]) {
                    foundAnchor = true;
                    break;
                }
            }
        }
    }
    
    return (true, foundAnchor);
}
```

Implementations MAY optimize this further but MUST maintain equivalent semantics.

#### `validateParticipant`

This function gates [ERC-8001](./eip-8001) coordination participation.

```solidity
function validateParticipant(
    bytes32 coordinationType,
    bytes32 participantNode
) external view returns (bool isValid) {
    (bytes32 gatekeeperNode, ValidationParams memory params, bool enabled) = 
        getIdentityGate(coordinationType);
    
    if (!enabled) return true; // No gate = open participation
    
    (isValid, , , ) = validateAgent(gatekeeperNode, participantNode, params);
}
```

### Errors

Implementations MUST revert with these errors:

```solidity
error SelfTrustProhibited();
error NonceTooLow(uint64 provided, uint64 required);
error AttestationExpired(uint64 expiry, uint64 currentTime);
error InvalidSignature();
error NotAuthorized(bytes32 node, address actor);
error ENSNameNotFound(bytes32 node);
error TrustNotFound(bytes32 trustorNode, bytes32 trusteeNode);
error GateNotFound(bytes32 coordinationType);
error InvalidValidationParams(string reason);
error PathTooLong(uint8 provided, uint8 maximum);
error PaginationOutOfBounds(uint256 offset, uint256 total);
```

### Recommended Scopes

For interoperability, the following scope values are RECOMMENDED:

| Scope | Value | Use Case |
|-------|-------|----------|
| Universal | `bytes32(0)` | Trust applies to all contexts |
| DeFi | `keccak256("DEFI")` | DeFi coordination |
| Gaming | `keccak256("GAMING")` | Gaming/metaverse |
| MEV | `keccak256("MEV")` | MEV protection |
| Commerce | `keccak256("COMMERCE")` | Agentic commerce |
| Validation | `keccak256("VALIDATION")` | Trust for validation judgments |

### Recommended Coordination Types

For [ERC-8001](./eip-8001) identity gates:

| Coordination Type | Value |
|-------------------|-------|
| MEV Coordination | `keccak256("MEV_COORDINATION")` |
| DeFi Yield | `keccak256("DEFI_YIELD")` |
| Gaming Match | `keccak256("GAMING_MATCH")` |
| Commerce Escrow | `keccak256("COMMERCE_ESCROW")` |

## Rationale

### Why ENS Instead of a New Identity System?

ENS is finalised [EIP-137](./eip-137), battle-tested, and widely adopted. Creating a new identity system would:

* Add dependency on draft standards
* Fragment the identity ecosystem
* Require new adoption efforts

ENS provides everything needed: stable identifiers, ownership semantics, and extensibility.

### Why Separate Trust from Reputation Scores?

Trust ("how much do I trust this agent's judgment?") differs from reputation ("how well did this agent perform?"). An agent can:

* Have excellent performance but poor judgment in vouching
* Have limited history but excellent judgment

Separating these concerns enables richer trust semantics.

### Why Four Trust Levels?

The four-level model (Unknown, None, Marginal, Full) is proven by GnuPG's 25+ years of use. Finer granularity adds complexity without clear benefit; coarser granularity loses important distinctions (especially Marginal vs Full).

### Why Configurable Validation Parameters?

Different contexts require different security thresholds:

| Context | Recommended Parameters |
|---------|------------------------|
| High-value DeFi | `maxPathLength: 2, marginalThreshold: 5, requiredAnchors: [dao.eth]` |
| Standard coordination | `maxPathLength: 5, marginalThreshold: 3, requiredAnchors: []` |
| Casual gaming | `maxPathLength: 7, marginalThreshold: 2, requiredAnchors: []` |

### Why Required Anchors?

Sybil attacks are the primary threat to web of trust systems. An attacker can create many ENS names and establish mutual trust between them, creating artificial trust paths.

Required anchors force trust paths to traverse established community nodes (DAOs, protocols, auditors). This transforms Sybil resistance from application-layer advice into protocol-level enforcement.

Anchors SHOULD be:

* Long-established ENS names with significant registration history
* Controlled by reputable entities (DAOs, protocols, auditors)
* Selective in their trust attestations

### Why Separate validateAgent and verifyPath?

Full path computation is expensive. `validateAgent` performs on-chain graph traversal suitable for low-stakes validation. `verifyPath` accepts pre-computed paths for gas-efficient verification, enabling:

* Off-chain indexers to compute optimal paths
* On-chain verification of pre-computed paths
* Hybrid approaches with cached results

For high-value coordination, applications SHOULD use off-chain path computation with `verifyPath` verification.

### Why On-Chain Trust Storage?

On-chain storage enables:

* Composability with other contracts
* Trustless verification
* Censorship resistance
* No reliance on off-chain infrastructure

The gas cost is acceptable given trust relationships change infrequently.

### Why Pagination?

Trust graphs can grow arbitrarily large. Unbounded array returns would:

* Hit block gas limits for popular agents
* Create DoS vectors
* Cause unpredictable gas costs

Pagination with explicit limits ensures predictable gas costs and prevents these issues.

### Privacy Scope

Privacy-preserving validation is explicitly out of scope for this version. Trust relationships are public by design, enabling:

* Composability with other contracts
* Auditability of trust graphs
* Transparency in coordination gating

Agents requiring privacy SHOULD:

* Use pseudonymous ENS names
* Establish trust through intermediate agents
* Use scoped trust to limit exposure

Future extensions MAY add privacy-preserving validation using zero-knowledge proofs, but this is not part of the current specification.

## Backwards Compatibility

This ERC introduces new functionality and does not modify existing standards.

**ENS Compatibility**: Uses standard ENS interfaces (`owner`, `isApprovedForAll`). Works with any ENS deployment.

**ERC-8001 Compatibility**: Designed as a module. ERC-8001 coordinators can optionally integrate identity gates.

**Wallet Compatibility**: Uses [EIP-712](./eip-712) signatures, compatible with all major wallets.

## Reference Implementation

### ITrustRegistry.sol

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

enum TrustLevel {
    Unknown,
    None,
    Marginal,
    Full
}

struct TrustAttestation {
    bytes32 trustorNode;
    bytes32 trusteeNode;
    TrustLevel level;
    bytes32 scope;
    uint64 expiry;
    uint64 nonce;
}

struct ValidationParams {
    uint8 maxPathLength;
    uint8 marginalThreshold;
    uint8 fullThreshold;
    bytes32 scope;
    bool enforceExpiry;
    bytes32[] requiredAnchors;
}

struct TrustPath {
    bytes32[] nodes;
    uint64[] attestedAt;
}

interface ITrustRegistry {
    event TrustSet(
        bytes32 indexed trustorNode,
        bytes32 indexed trusteeNode,
        TrustLevel level,
        bytes32 indexed scope,
        uint64 expiry
    );

    event TrustRevoked(
        bytes32 indexed trustorNode,
        bytes32 indexed trusteeNode,
        string reason
    );

    event IdentityGateSet(
        bytes32 indexed coordinationType,
        bytes32 indexed gatekeeperNode,
        uint8 maxPathLength,
        uint8 marginalThreshold
    );

    event IdentityGateRemoved(bytes32 indexed coordinationType);

    error SelfTrustProhibited();
    error NonceTooLow(uint64 provided, uint64 required);
    error AttestationExpired(uint64 expiry, uint64 currentTime);
    error InvalidSignature();
    error NotAuthorized(bytes32 node, address actor);
    error ENSNameNotFound(bytes32 node);
    error TrustNotFound(bytes32 trustorNode, bytes32 trusteeNode);
    error GateNotFound(bytes32 coordinationType);
    error InvalidValidationParams(string reason);
    error PathTooLong(uint8 provided, uint8 maximum);
    error PaginationOutOfBounds(uint256 offset, uint256 total);

    function setTrust(
        TrustAttestation calldata attestation,
        bytes calldata signature
    ) external;

    function setTrustBatch(
        TrustAttestation[] calldata attestations,
        bytes[] calldata signatures
    ) external;

    function revokeTrust(
        bytes32 trustorNode,
        bytes32 trusteeNode,
        string calldata reason
    ) external;

    function getTrust(
        bytes32 trustorNode,
        bytes32 trusteeNode
    ) external view returns (
        TrustLevel level,
        bytes32 scope,
        uint64 expiry,
        uint64 attestedAt
    );

    function getNonce(bytes32 trustorNode) external view returns (uint64);

    function getTrustees(
        bytes32 trustorNode,
        TrustLevel minLevel,
        uint256 offset,
        uint256 limit
    ) external view returns (bytes32[] memory trustees, uint256 total);

    function getTrustors(
        bytes32 trusteeNode,
        TrustLevel minLevel,
        uint256 offset,
        uint256 limit
    ) external view returns (bytes32[] memory trustors, uint256 total);

    function validateAgent(
        bytes32 validatorNode,
        bytes32 targetNode,
        ValidationParams calldata params
    ) external view returns (
        bool isValid,
        uint8 pathLength,
        uint8 marginalCount,
        uint8 fullCount
    );

    function verifyPath(
        TrustPath calldata path,
        ValidationParams calldata params
    ) external view returns (bool valid, bool anchorSatisfied);

    function validateAgentBatch(
        bytes32 validatorNode,
        bytes32[] calldata targetNodes,
        ValidationParams calldata params
    ) external view returns (bool[] memory);

    function pathExists(
        bytes32 fromNode,
        bytes32 toNode,
        uint8 maxDepth
    ) external view returns (bool exists, uint8 depth);

    function setIdentityGate(
        bytes32 coordinationType,
        bytes32 gatekeeperNode,
        ValidationParams calldata params
    ) external;

    function removeIdentityGate(bytes32 coordinationType) external;

    function getIdentityGate(
        bytes32 coordinationType
    ) external view returns (
        bytes32 gatekeeperNode,
        ValidationParams memory params,
        bool enabled
    );

    function validateParticipant(
        bytes32 coordinationType,
        bytes32 participantNode
    ) external view returns (bool isValid);

    function validateParticipantWithPath(
        bytes32 coordinationType,
        TrustPath calldata path
    ) external view returns (bool isValid);

    function validateParticipantBatch(
        bytes32 coordinationType,
        bytes32[] calldata participantNodes
    ) external view returns (bool[] memory);
}
```

### TrustRegistry.sol

See [`contracts/TrustRegistry.sol`](../assets/eip-8107/contracts/TrustRegistry.sol) for the complete implementation.

## Security Considerations

### Sybil Attacks

An attacker can create many ENS names and establish mutual trust between them.

**Protocol-level mitigations:**

* **Required anchors**: `ValidationParams.requiredAnchors` forces paths through established community nodes, preventing pure Sybil clusters from validating each other
* **Short path limits**: `maxPathLength: 2` requires close proximity to validators

**Application-level mitigations:**

* Weight trust by ENS name age or registration cost
* Implement additional stake requirements
* Monitor trust graphs for anomalous patterns off-chain

### Trust Graph Manipulation

Attackers may attempt to position themselves in many trust paths.

**Mitigations:**

* Require multiple independent paths (not just multiple attestations from same cluster)
* Monitor trust graphs for anomalous patterns off-chain
* Cap per-agent influence in validation algorithms
* Use `fullThreshold > 1` for high-value coordination

### Key Compromise

If an ENS name's controller is compromised:

**Mitigations:**

* Agents SHOULD monitor for unexpected trust changes via `TrustSet` events
* Implementations MAY support time-delayed trust changes
* ENS name owners can rotate controllers
* Affected agents can issue `TrustRevoked` to quarantine compromised nodes

### Replay Protection

[EIP-712](./eip-712) domain binding prevents cross-contract replay. Monotonic nonces prevent replay within the same contract. The `chainId` in the domain prevents cross-chain replay.

### Stale Trust

Trust relationships may become stale if agents don't update them.

**Mitigations:**

* Use `enforceExpiry: true` in validation parameters
* Set reasonable `expiry` values on attestations (RECOMMENDED: 1 year maximum)
* Implementations SHOULD emit warnings for trust > 1 year old
* Consider trust decay in off-chain reputation systems

### Path Computation DoS

On-chain path computation via `validateAgent` can be expensive for large graphs.

**Mitigations:**

* `maxPathLength` caps traversal depth (maximum 10)
* Use `verifyPath` with pre-computed paths for gas-sensitive operations
* Off-chain indexers can compute and cache optimal paths

### ENS Dependency

This standard depends on ENS availability. If ENS becomes unavailable:

* Existing trust relationships remain in storage
* New attestations cannot be verified
* Implementations SHOULD handle ENS failures gracefully by caching owner addresses

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
