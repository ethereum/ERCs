---
eip: 8161
title: Skill Registry with Proof-of-Work Endorsements
description: Register agent skills on-chain by hash and accumulate PoW-gated endorsements
author: José Blockchain (@jose-blockchain)
discussions-to: https://ethereum-magicians.org/t/erc-8161-skill-registry-with-proof-of-work-endorsements/TODO
status: Draft
type: Standards Track
category: ERC
created: 2026-02-12
requires: 8004, 721
---

## Abstract

This standard extends [ERC-8004](./eip-8004.md) with a **Skill Registry** that allows agents to register discrete, verifiable skills on-chain and accumulate **Proof-of-Work gated endorsements** from users and other agents.

Each skill is identified by the `keccak256` hash of its canonical description text, committed on-chain alongside a URI to the full off-chain content. To endorse a skill, the endorser MUST mine a nonce satisfying a difficulty target — verified entirely on-chain — making each endorsement provably costly in compute. The challenge is bound to both the skill and the endorser address, so mined nonces are non-transferable.

## Motivation

[ERC-8004](./eip-8004.md) gives agents portable identities and a general-purpose Reputation Registry for posting feedback signals. However, the Reputation Registry operates at the **agent level** — feedback is given to the agent as a whole, optionally scoped by `tag1`/`tag2`. There is no native mechanism to:

1. **Register discrete, verifiable skills** — A code-review agent may also do translation; these capabilities deserve distinct reputations.
2. **Anchor skill descriptions with integrity** — An on-chain hash commitment guarantees the skill text cannot be silently modified after endorsements have accumulated.
3. **Rate-limit endorsements with unforgeable cost** — Without a cost gate, Sybil accounts can flood the endorsement graph with worthless signals. Proof-of-Work mining creates a per-endorsement computational cost that cannot be faked, borrowed, or transferred.

By requiring endorsers to mine `keccak256(skillId ‖ endorserAddress ‖ nonce) <= difficultyTarget`, each endorsement carries a provable minimum cost. No tokens, staking, or oracles are needed — only a CPU and time.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119) and [RFC 8174](https://www.rfc-editor.org/rfc/rfc8174).

### Skill Registry

When the Skill Registry is deployed, the *identityRegistry* address is set via `initialize(address identityRegistry_, uint8 initialDifficultyBits)` and publicly visible by calling:

```solidity
function getIdentityRegistry() external view returns (address identityRegistry)
```

The registry is linked to a single [ERC-8004](./eip-8004.md) Identity Registry. It SHOULD be deployed as a **singleton per chain**, consistent with [ERC-8004](./eip-8004.md)'s deployment model.

### Proof-of-Work Challenge

To endorse a skill, the endorser MUST find a nonce `N` such that:

```
h = keccak256(abi.encodePacked(skillId, endorserAddress, N))
uint256(h) <= difficultyTarget
```

Where:

```
difficultyTarget = (2^256 - 1) >> difficultyBits
```

The contract verifies this with a single `keccak256` plus a `uint256` comparison. Mining happens off-chain.

#### Difficulty Reference

| `difficultyBits` | Leading Zero Bits | Expected Hashes | Approx. Time (single-threaded JS) |
| --- | --- | --- | --- |
| 12 | 12 | ~4,096 | < 1s |
| 16 | 16 | ~65,536 | ~3–5s |
| 20 | 20 | ~1,048,576 | ~30–60s |
| 24 | 24 | ~16,777,216 | ~10–15 min |
| 28 | 28 | ~268,435,456 | ~3–4 hours |

Difficulty is adjustable via:

```solidity
function setDifficulty(uint8 newDifficultyBits) external
```

This function MUST be restricted to the contract admin or governance. When difficulty changes, the following event is emitted:

```solidity
event DifficultyUpdated(uint8 oldBits, uint8 newBits, uint256 newTarget)
```

The current difficulty is readable via:

```solidity
function difficultyTarget() external view returns (uint256)
function difficultyBits() external view returns (uint8)
```

#### Challenge Binding Properties

* The challenge input includes the endorser's `address`, so a nonce mined by one address CANNOT be submitted by another.
* The challenge input includes the `skillId`, so a nonce mined for one skill CANNOT be reused on another.
* Each `(skillId, endorser, nonce)` triple can only be used once. Consumed nonces are tracked on-chain and remain consumed even if the endorsement is later revoked.

### Skill Identification

A skill is globally and deterministically identified by:

* *skillId*: `keccak256(abi.encodePacked(agentId, skillHash))` where:
  * *agentId*: The [ERC-8004](./eip-8004.md) Identity Registry tokenId of the agent
  * *skillHash*: The `keccak256` hash of the canonical, UTF-8 encoded skill description text

```solidity
function computeSkillId(uint256 agentId, bytes32 skillHash) external pure returns (bytes32)
```

### Skill Registration

New skills can be registered by the agent owner or an approved operator by calling:

```solidity
function registerSkill(uint256 agentId, bytes32 skillHash, string calldata skillURI, string calldata tag) external returns (bytes32 skillId)
```

The *agentId* MUST be a validly registered agent in the linked Identity Registry. The caller MUST be the owner or an approved operator of *agentId*. The *skillHash* MUST NOT be `bytes32(0)`. The same `(agentId, skillHash)` pair MUST NOT be registered twice.

The *skillURI* SHOULD resolve to the full skill description text, verifiable as `keccak256(text) == skillHash`. It MAY use any URI scheme such as `ipfs://`, `https://`, or a base64-encoded `data:` URI.

The *tag* is a free-form category string (e.g., `"code-review"`, `"solidity-audit"`, `"medical-triage"`).

If the procedure succeeds, an event is emitted:

```solidity
event SkillRegistered(bytes32 indexed skillId, uint256 indexed agentId, bytes32 indexed skillHash, string skillURI, string tag)
```

#### Update Skill

The skill URI, tag, and active status can be updated by calling:

```solidity
function updateSkill(bytes32 skillId, string calldata newSkillURI, string calldata newTag, bool active) external
```

This function MUST be called by the owner or operator of the skill's *agentId*. Setting `active = false` soft-deletes the skill; no new endorsements are accepted for inactive skills. Updating *skillURI* does NOT change *skillHash*. If the underlying skill text changes materially, a new skill SHOULD be registered with a new hash.

```solidity
event SkillUpdated(bytes32 indexed skillId, string newSkillURI, string newTag, bool active)
```

### Endorsement (PoW-Gated)

New endorsements can be added by any address calling:

```solidity
function endorse(bytes32 skillId, uint256 nonce, int128 weight, uint8 weightDecimals, string calldata tag, string calldata proofURI, bytes32 proofHash) external returns (uint64 endorsementIndex)
```

The *skillId* MUST reference an active, registered skill. The *weightDecimals* MUST be between 0 and 18. The endorsement submitter MUST NOT be the agent owner or an approved operator for the skill's *agentId*. The *nonce* MUST satisfy the PoW challenge: `uint256(keccak256(abi.encodePacked(skillId, msg.sender, nonce))) <= difficultyTarget`. The *nonce* MUST NOT have been previously used for this `(skillId, msg.sender)` pair.

The *weight* is a signed fixed-point value (`int128`). Positive values represent endorsements; negative values represent disputes. The *tag*, *proofURI*, and *proofHash* are OPTIONAL.

Where provided, *proofURI* points to off-chain evidence of actual skill usage (e.g., a transaction receipt, audit report, or attestation). *proofHash* is the `keccak256` hash of the content referenced by *proofURI*, enabling verifiable integrity for non-content-addressed URIs. For IPFS (or other content-addressed URIs), *proofHash* is OPTIONAL and can be omitted (e.g., set to `bytes32(0)`).

The fields *weight*, *weightDecimals*, *tag*, *nonce*, *powHash*, and *isRevoked* are stored in the contract storage along with the *endorsementIndex* (a 1-indexed counter of endorsements that *msg.sender* has given to *skillId*). The fields *proofURI* and *proofHash* are emitted but are not stored. This exposes endorsement signals to any smart contract, enabling on-chain composability.

Running aggregates (*endorsementCount* and *endorsementSum*) are updated on the skill's storage entry for gas-efficient unfiltered reads.

If the procedure succeeds, an event is emitted:

```solidity
event SkillEndorsed(bytes32 indexed skillId, address indexed endorser, uint64 endorsementIndex, uint256 nonce, bytes32 powHash, int128 weight, uint8 weightDecimals, string tag, string proofURI, bytes32 proofHash)
```

#### Examples of `weight` / `weightDecimals`

| tag | What it measures | Example human value | `weight` | `weightDecimals` |
| --- | --- | --- | --- | --- |
| `quality` | Quality rating (0-100) | `92/100` | `92` | `0` |
| `used` | Binary — endorser used the skill | `true` | `1` | `0` |
| `accuracy` | Accuracy rate (%) | `97.3%` | `973` | `1` |
| `gasEfficiency` | Gas savings vs baseline (%) | `34%` | `34` | `0` |
| `dispute` | Skill did not perform as described | `false` | `-1` | `0` |

#### Off-Chain Proof-of-Work Evidence File Structure

The OPTIONAL file at the *proofURI* could look like:

```json
{
  "type": "https://eips.ethereum.org/EIPS/eip-8161#endorsement-proof-v1",
  "skillId": "0xabc123...",
  "endorser": "0x742d35Cc...",
  "nonce": 92819,
  "powHash": "0x00002e22...",
  "createdAt": "2026-02-10T14:30:00Z",

  "evidence": {
    "chainId": 1,
    "txHash": "0xdef456...",
    "description": "Used this audit skill on contract 0x... — found 3 critical vulnerabilities that were confirmed and fixed."
  },

  "proofOfPayment": {
    "fromAddress": "0x00...",
    "toAddress": "0x00...",
    "chainId": "1",
    "txHash": "0x00..."
  }
}
```

### Revoking Endorsements

The endorser can revoke their own endorsement by calling:

```solidity
function revokeEndorsement(bytes32 skillId, uint64 endorsementIndex) external
```

Running aggregates are adjusted. The consumed nonce remains consumed — the computational cost has already been spent. This prevents mine-once-endorse-forever attack cycles.

This emits:

```solidity
event EndorsementRevoked(bytes32 indexed skillId, address indexed endorser, uint64 indexed endorsementIndex)
```

### Verification Helpers

A read-only function allows off-chain miners to dry-run verification before submitting a transaction:

```solidity
function verifyPoW(bytes32 skillId, address endorser, uint256 nonce) external view returns (bool valid, bytes32 h)
```

To check whether a nonce has already been consumed:

```solidity
function nonceUsed(bytes32 skillId, address endorser, uint256 nonce) external view returns (bool)
```

### Read Functions

```solidity
function getSkill(bytes32 skillId) external view returns (Skill memory)

function getAgentSkills(uint256 agentId) external view returns (bytes32[] memory)

function readEndorsement(bytes32 skillId, address endorser, uint64 endorsementIndex) external view returns (Endorsement memory)

function getLastEndorsementIndex(bytes32 skillId, address endorser) external view returns (uint64)

function getEndorsers(bytes32 skillId) external view returns (address[] memory)

function getSummary(bytes32 skillId, address[] calldata endorserAddresses, string calldata tag) external view returns (uint64 count, int128 sumWeight, uint8 weightDecimals)
// skillId is the only mandatory parameter; endorserAddresses and tag are optional filters.
// endorserAddresses SHOULD be provided; results without filtering by endorser are subject to Sybil/spam. See Security Considerations for details.
```

We expect reputation systems around endorsers to emerge. **While simple filtering by endorser (useful to mitigate spam) and by tag are enabled on-chain, more complex endorsement aggregation will happen off-chain**.

### Off-Chain Skill Description File Structure

The content at *skillURI* SHOULD be a UTF-8 file whose `keccak256` equals the on-chain *skillHash*. Recommended structure:

```json
{
  "type": "https://eips.ethereum.org/EIPS/eip-8161#skill-v1",
  "name": "Solidity Smart Contract Audit",
  "description": "Comprehensive security audit of Solidity smart contracts including reentrancy, access control, gas optimization, and upgrade safety analysis.",
  "version": "1.0.0",
  "category": "security-audit",
  "inputSchema": {
    "type": "object",
    "properties": {
      "contractSource": { "type": "string", "description": "Solidity source code or verified contract address" },
      "scope": { "type": "string", "enum": ["full", "focused", "gas-only"] }
    }
  },
  "outputSchema": {
    "type": "object",
    "properties": {
      "findings": { "type": "array" },
      "severityBreakdown": { "type": "object" },
      "gasReport": { "type": "object" }
    }
  },
  "pricing": {
    "model": "per-contract",
    "currency": "USDC",
    "estimate": "50-500"
  },
  "protocols": ["MCP", "A2A"],
  "tags": ["solidity", "security", "audit", "evm"]
}
```

### Integration with Agent Registration File

Agents SHOULD list their registered skills in their [ERC-8004](./eip-8004.md) registration file:

```json
{
  "type": "https://eips.ethereum.org/EIPS/eip-8004#registration-v1",
  "name": "AuditBot",
  "skills": [
    {
      "skillId": "0xabc123...",
      "skillHash": "0xdef456...",
      "name": "Solidity Audit",
      "skillURI": "ipfs://Qm..."
    }
  ],
  "services": []
}
```

## Rationale

* **Hash-on-chain, text-off-chain**: Storing full skill descriptions on-chain is gas-prohibitive. The hash commitment ensures integrity — once endorsements accumulate against a *skillHash*, the description cannot be silently changed.
* **PoW instead of staking**: PoW requires no tokens, no capital lockup, no oracle. It is universally accessible — anyone with a CPU can mine a nonce. The cost is pure computation, which cannot be faked or borrowed. It also creates a natural rate-limit: endorsing 1,000 skills at difficulty-20 costs ~10^9 hashes, requiring hours of compute even on fast hardware.
* **Challenge bound to endorser address**: Prevents nonce marketplaces. If the challenge were `keccak256(skillId ‖ nonce)`, a single mining farm could sell valid nonces to anyone. Including the endorser's address makes every nonce non-transferable.
* **Nonces stay consumed after revocation**: Prevents the cycle: mine → endorse → revoke → re-endorse with the same nonce. The computational cost must be paid fresh for each new endorsement.
* **Signed weights**: Negative endorsements (disputes) are as important as positive ones. An auditor discovering a skill doesn't perform as advertised should be able to record that signal on-chain.
* **Separate registry from Reputation**: The [ERC-8004](./eip-8004.md) Reputation Registry serves agent-level feedback. Skills are a fundamentally different entity with their own lifecycle (register, update, deactivate) and endorsement graph. Separating concerns keeps both registries clean and composable.
* **Per-(skillId, endorser) indexing**: The same endorser may use a skill multiple times. Each interaction deserves its own endorsement signal, and the endorser can selectively revoke any of them.
* **Gas sponsorship**: Since endorsers don't need to be registered agents, any application can implement frictionless endorsement leveraging [EIP-7702](./eip-7702.md).

## Security Considerations

* **Sybil attacks**: PoW raises the cost of creating fake endorsements. At difficulty-20, each endorsement costs ~1M hashes. However, sophisticated miners have an advantage. Downstream reputation systems SHOULD weight endorsements by endorser reputation. `getSummary` accepts a curated endorser list for this purpose.
* **ASIC/GPU advantage**: Specialized hardware can mine faster. This is acceptable — the goal is minimum cost per endorsement, not equal cost. Governance can increase difficulty if the bar becomes too low.
* **Front-running**: A mined nonce visible in the mempool could theoretically be intercepted, but the challenge includes `msg.sender`, so the nonce is worthless to any other address.
* **Difficulty changes**: Nonces mined under old difficulty are checked against the *current* difficulty at submission time. A sudden difficulty increase may invalidate in-progress mining. Applications SHOULD check the current difficulty before mining.
* **Self-endorsement**: Blocked at the contract level — agent owners and approved operators MUST NOT endorse their own agent's skills, mirroring the constraint in the [ERC-8004](./eip-8004.md) Reputation Registry.
* **Proof-of-work evidence spoofing**: The contract does not validate *proofURI* contents on-chain. Validation of proof quality is left to off-chain aggregators, subgraphs, or the [ERC-8004](./eip-8004.md) Validation Registry.
* **Skill text integrity**: The *skillHash* commitment prevents silent modification. Clients SHOULD verify `keccak256(fetchedText) == skillHash` before trusting a skill description.
* **Nonce storage growth**: Consumed nonces are stored as `mapping(bytes32 => mapping(address => mapping(uint256 => bool)))`. Storage grows linearly with endorsements, but each entry occupies a single storage slot.
* **On-chain pointers and hashes cannot be deleted**, ensuring audit trail integrity.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
