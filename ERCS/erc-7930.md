---
eip: 7930
title: Interoperable Addresses
description: An extensible binary format to refer to an address specific to one chain.
author: Teddy (@0xteddybear), Joxes (@0xJoxess), Nick Johnson (@Arachnid), Francisco Giordano (@frangio), Skeletor Spaceman (@skeletor-spaceman), Racu (@0xRacoon), TiTi (@0xtiti), Gori (@0xGorilla), Ardy (@0xArdy), Onizuka (@onizuka-wl), Sam Kaufman (@SampkaML), Marco Stronati (@paracetamolo), Yuliya Alexiev (@yuliyaalexiev), Jeff Lau (@jefflau), Sam Wilson (@samwilsn), Vitalik Buterin (@vbuterin), Thomas Clowes (@clowestab), Mono (@0xMonoAx)
discussions-to: https://ethereum-magicians.org/t/erc-7930-interoperable-addresses/23365
status: Draft
type: Standards Track
category: ERC
created: 2025-02-02
---

## Abstract
This proposal introduces a **binary format** to describe a chain specific address. Additionally, it defines a human-readable version of that identifier, which improves the user experience in user-facing interactions.

This is achieved through a versioned, length-prefixed binary envelope that supports arbitrary-length data. The interpretation and serialization rules for the data within this envelope are defined by companion standards ([CAIP-350]), which provide profiles for each chain type.

## Motivation
The address format utilized on Ethereum mainnet ([ERC-55]) is shared by a large number of other blockchains. The format does not include details of the chain on which an interaction should occur. This introduces risk if, for example, a transaction is mistakenly executed on a chain where the address is inaccesible. This risk is particularly pronounced for addresses that represent smart contracts or smart accounts.

This proposal builds on insights from [CAIP-10] and [CAIP-50]. It offers both a binary canonical _Interoperable Address_ format and a human readable _Interoperable Name_ format which:

- Binds together chain identification and the raw address.
- Is compact for usage with cross-chain message passing and intent declaration.
- Includes short, easily verififiable checksums to protect users.
- Extends beyond EVM blockchains.

These features can not be added to existing standards as they are not easily extensible - this one is.

### Comparisons with other standards

#### CAIP-10

[CAIP-10] proposes a standard text format to represent an address on a specific chain (referenced by its [CAIP-2] identifier).

The standard **does not** concern itself with the serialization/deserialization of the target address. It assumes knowledge of the native address format for each chain and does not enforce any serialization or canonicalization rules.

While it is trivial to add support for chains to [CAIP-10], the format is not optimized for usage within smart contracts as strings are an inefficient way to store data on-chain.

[CAIP-10] depends on [CAIP-2], which limits the chain reference to 32 characters. This constraint means that [CAIP-2] can not losslessy represent a chain. e.g. Solana chains utilize the leading 32 characters of the base58btc-encoded genesis blockhash, which is not a uniquely deterministic way of representing a chain. 

An _Interoperable Name_ contains all of the components of the [CAIP-10] identifier. As such it is easy to interchange between the two in cases where the [CAIP-10] standard is still used.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Terminology
**Target Address**
: The address itself, independent of chain context. Serialized per the [CAIP-350] rules for the applicable namespace. In the context of the _Interoperable Name_ and _Interoperable Address_ examples below, the target address is `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`.

**Chain Specific Address**
: An address representation that includes both the _target address_ **and** the chain being targeted. The following are examples of chain specific addresses:

- The _Interoperable Address_ definition outlined in this specification
- The _Interoperable Name_ definition outlined in this specification
- The addressing format outlined in [ERC-3770], e.g. `arb:0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`

**Interoperable Address**
: A binary payload which unambiguously identifies a target address on a target chain. e.g. `0x00010000010114D8DA6BF26964AF9D7EED9E03E53415D37AA96045`

**Interoperable Name**
: A string representation of an _Interoperable Address_, meant to be used by humans. e.g. `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045@eip155:1#4CA88C9C`


### _Interoperable Address_ Definition

An _Interoperable Address_ as defined by this standard MUST have the following binary format:

```
┌─────────┬───────────┬──────────────────────┬────────────────┬───────────────┬─────────┐
│ Version │ ChainType │ ChainReferenceLength │ ChainReference │ AddressLength │ Address │
└─────────┴───────────┴──────────────────────┴────────────────┴───────────────┴─────────┘
```

The components outlined above have the following meanings:

**Version**
: A 2-byte version identifier. For version 1 (this specification), this must be `0x0001` (big-endian). Future versions SHOULD be standardized in separate ERCs.

**ChainType**
: A 2-byte value as defined in [CAIP-350], corresponding to a [CAIP-2] namespace, which allows users to know how to interpret and display the _ChainReference_ and the _Address_.

**ChainReferenceLength**
: A 1-byte integer encoding the length of _ChainReference_ in bytes. Note that it MAY be zero, in which case the _Interoperable Address_ MUST NOT include a chain reference.

**ChainReference**
: Variable length, binary representation of the [CAIP-2] chain ID. To discern how to serialize the _ChainReference_ for a specific chain type, implementors MUST reference the respective [CAIP-350] profile. Chain profiles are maintained by the Chain-Agnostic Standards Alliance (CASA).

**AddressLength**
: 1-byte integer encoding the length of Address in bytes. Note that it MAY be zero, in which case the _Interoperable Address_ MUST NOT include an address. It MUST NOT be zero if the _ChainReferenceLength_ is also zero.

**Address**
: Variable length field containing the binary encoding of the address. The serialization for a specific _ChainType_ MUST follow the rules of its corresponding [CAIP-350] profile.

### Interoperable Name format definition

#### Syntax
```bnf
<human readable name> ::= <address> @ <chain> # <checksum>
<address>             ::= [.-:_%a-zA-Z0-9]*
<chain>               ::= [.-:_a-zA-Z0-9]*
<checksum>            ::= [0-9A-F]{8}
```

Where:

Chain
: String representation of [CAIP-2] blockchain identifier, recovered from the binary representation described in the [CAIP-350] profile for the chain type. In the case where `ChainReferenceLength` is zero, it should be the CAIP namespace alone, and no trailing colon. Note that it's not possible to specify a reference without a namespace.

Address
: Chain namespace specific text representation of the address from the binary representation. Mapping between the two described in the [CAIP-350] profile for the chain type. In the case where `AddressLength` is zero, it should be the empty string.

Checksum
: 4-byte checksum calculated by computing the keccak256 hash of the concatenated `ChainType`, `ChainReferenceLength`, `ChainReference`, `AddressLength` and `Address` fields of the binary representation (that is, the v1 binary representation skipping the `Version` field), and truncating all but the first 4 bytes of the output. Represented as a base16 string as defined in [RFC 4648].

### Versioning

These rules ensure that future standards that build upon this one maintain backwards compatibility.

Future versions:

- MUST be trivially convertible to the _Interoperable Address_ format defined in this specification
- MUST set the most significant bit of the version field to 1 if the _Interoperable Address_ format is not backward-compatible with the parsing rules outlined herein
- MUST support defining an address, a chain, or both
- MAY add fields but MUST NOT alter or omit any data required to reconstruct the Version 1 _Interoperable Address_ exactly, bit for bit
- MUST use the checksum algorithm outlined in this standard
- MAY only be able to represent a subset of the CAIP namespaces
- MAY introduce stricter syntactic rules for the _Interoperable Name_ (thereby narrowing the set of valid strings), but MUST NOT introduce new syntactic forms that enlarge the grammar.
- MUST allow for the appropriate binary data to be derived from the _Interoperable Name_ to allow for the construction of an _Interoperable Address_ encoded as defined in this specification

## Test Cases

### Example 1: Ethereum mainnet address
Chain: Ethereum Mainnet
Address: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`

Interoperable Name: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045@eip155:1#4CA88C9C`

Interoperable Address:
```
0x00010000010114D8DA6BF26964AF9D7EED9E03E53415D37AA96045
  ^^^^-------------------------------------------------- Version:              decimal 1
      ^^^^---------------------------------------------- ChainType:            2 bytes of CAIP namespace
          ^^-------------------------------------------- ChainReferenceLength: decimal 1
            ^^------------------------------------------ ChainReference:       1 byte to store uint8(1)
              ^^---------------------------------------- AddressLength:        decimal 20
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Address:              20 bytes of ethereum address
```
keccak256 input for checksum: `0x0000010114D8DA6BF26964AF9D7EED9E03E53415D37AA96045`
note the version field is removed before hashing

### Example 2: Solana mainnet address
Chain: Solana Mainnet

Address: `MJKqp326RZCHnAAbew9MDdui3iCKWco7fsK9sVuZTX2`

Interoperable Name: `MJKqp326RZCHnAAbew9MDdui3iCKWco7fsK9sVuZTX2@solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d#88835C11`

Interoperable Address:
```
0x000100022045296998a6f8e2a784db5d9f95e18fc23f70441a1039446801089879b08c7ef02005333498d5aea4ae009585c43f7b8c30df8e70187d4a713d134f977fc8dfe0b5
  ^^^^---------------------------------------------------------------------------------------------------------------------------------------- Version:              decimal 1
      ^^^^------------------------------------------------------------------------------------------------------------------------------------ ChainType:            2 bytes of CAIP namespace
          ^^---------------------------------------------------------------------------------------------------------------------------------- ChainReferenceLength: decimal 32
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^------------------------------------------------------------------ ChainReference:       32 bytes of solana genesis block
                                                                            ^^---------------------------------------------------------------- AddressLength:        decimal 32
                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--- Address:              32 bytes of solana address
```
keccak256 input for checksum: `0x00022045296998a6f8e2a784db5d9f95e18fc23f70441a1039446801089879b08c7ef02005333498d5aea4ae009585c43f7b8c30df8e70187d4a713d134f977fc8dfe0b5`.
Note the version field is removed before hashing.

### Example 3: EVM address without chainid
Chain: `eip155` namespace, chainid not specified.
Address: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`
Interoperable Name: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045@eip155#B26DB7CB`

Interoperable Address:
```
0x000100000014D8DA6BF26964AF9D7EED9E03E53415D37AA96045
  ^^^^------------------------------------------------ Version:              decimal 1
      ^^^^-------------------------------------------- ChainType:            2 bytes of CAIP namespace
          ^^------------------------------------------ ChainReferenceLength: zero, indicating no chainid
            ^^---------------------------------------- AddressLength:        decimal 20
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Address:              20 bytes of ethereum address
```
keccak256 input for checksum: `0x00000014D8DA6BF26964AF9D7EED9E03E53415D37AA96045`
Note the version field is removed before hashing.

### Example 4: Solana mainnet network, no address
Chain: Solana Mainnet.

Address: Not specified.

Interoperable Name: `@solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d#2EB18670`

Interoperable Address:
```
0x000100022045296998a6f8e2a784db5d9f95e18fc23f70441a1039446801089879b08c7ef000
  ^^^^------------------------------------------------------------------------ Version:              decimal 1
      ^^^^-------------------------------------------------------------------- ChainType:            2 bytes of CAIP namespace
          ^^------------------------------------------------------------------ ChainReferenceLength: decimal 32
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-- ChainReference:       32 bytes of solana genesis block
                                                                            ^^ AddressLength:        zero, indicating no address
```
keccak256 input for checksum: `0x00022045296998a6f8e2a784db5d9f95e18fc23f70441a1039446801089879b08c7ef000`.
Note the version field is removed before hashing.

## Rationale

The interoperability roadmap benefits significantly from first having a standardized binary format for addresses, which allows the message passing and intents verticals to move forward on a consistent common interface.

The rationale for some of the low level specification decisions are outlined below:

- The `@` symbol is used as a separator as it provides visual clarity to humans, is easy for software to parse, and avoids confusion with the colon (`:`) symbol utilized in [CAIP-2], and [CAIP-10] identifiers. 
- No length restriction is placed on addresses, allowing for chains with longer address formats to be represented.
- The address field includes `%` as a valid character to allow for URL-encoding of any other characters that are not explicitly allowed. This allows backward compatibility with [CAIP-10].
- We chose to support zero-length addresses and chain IDs to make this standard flexible and to allow developers to use a single, uniform standard for many different jobs. For example if a user wants to represent an address on any compatible chain, or if the user simply wants to represent the chain itself.
- We chose *not* to use alternate encoding formats (e.g., `base58` or `base64`) in order to make it easier for wallets and dApps to work with, and convert between, addresses that both use and do not use this addressing standard. Whilst utilizing alternate formats could have reduced the size of the _Interoperable Name_ we decided that user and developer experience should be prioritized.
- Checksums are short enough to be visually comparable by the human eye, allowing for easy differentiation.

## Security Considerations
While this standard aims to be a foundation to be able to canonically refer to addresses on different chains, that guarantee is going to be a leaky abstraction in the real world, given that e.g. a particular chain namespace might define a serialization scheme that can't guarantee canonicity of addresses, or a given network might have two valid [CAIP-2] ids referring to it.

It is therefore advised for implementers requiring canonicity of addresses (e.g by using them as keys in smart contract mappings or other key-value stores), to thoroughly review the [CAIP-350] profile of a chain namespace for the possibility of a lack of canonicity of addresses (which should be noted in the profile's 'Extra Considerations' section) as well as collisions with other already-supported namespaces.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).

<!-- TODO:

[ERC-7828]: ./eip-7828.md

-->

[ERC-55]: ./eip-55.md
[ERC-3770]: ./erc-3770.md
[ERC-7785]: ./eip-7785.md
[CAIP-2]: https://github.com/ChainAgnostic/CAIPs/blob/2a7d42aebaffa42d1017c702974395ff5c1b3636/CAIPs/caip-2.md
[CAIP-10]: https://github.com/ChainAgnostic/CAIPs/blob/2a7d42aebaffa42d1017c702974395ff5c1b3636/CAIPs/caip-10.md
[CAIP-50]: https://github.com/ChainAgnostic/CAIPs/blob/2a7d42aebaffa42d1017c702974395ff5c1b3636/CAIPs/caip-50.md
[CAIP-350]: https://github.com/ChainAgnostic/CAIPs/blob/29762ef99a6ffea1e07e3f796c0d1a5a95e89b88/CAIPs/caip-350.md
[RFC 4648]: https://www.rfc-editor.org/rfc/rfc4648