---
eip: 8087
title: Encrypted Hashed Arguments and Calls
description: A Protocol for Encrypted Hashed Function Call and Encrypted Hashed Function Argument Execution via Decryption Oracle
author: Christian Fries (@cfries), Peter Kohl-Landgraf (@pekola)
discussions-to: (ethereum-magicians post pending)
status: Draft
type: Standards Track
category: ERC
created: 2025-11-14
requires: 7573
---

## Simple Summary

This ERC standardizes how smart contracts can request a **function execution with encrypted arguments**,
optionally with an **encrypted call descriptor**, using a stateless decryption oracle (a *Call Decryption Oracle*).

It separates

1. a reusable, verifiable container for **encrypted arguments**, and
2. a **call descriptor** (what to call, and any validity constraints),

and defines how an off-chain oracle decrypts and executes such calls.

## Abstract

This ERC defines a data format and contract interface for executing smart contract calls where:

1. The **arguments** are encrypted and reusable (`EncryptedHashedArguments`), and
2. The **call descriptor** (target contract, selector, validity) is either
    - encrypted (`EncryptedCallDescriptor`), or
    - plain (`CallDescriptor`).

The encrypted arguments and the call descriptor are *not* directly bound on-chain. Instead, an on-chain
contract (the target or an orchestration contract) stores a hash commitment to the plaintext arguments
and later verifies that the decrypted argument payload matches the stored commitment.

An on-chain *call decryption oracle* contract offers a request*/fulfill* pattern to request a call
with encrypted arguments, which is fulfilled if admissible.

An off-chain *call decryption oracle* listens to standardized events, decrypts payloads, enforces any
off-chain access-control policy, and calls back into the on-chain oracle to perform the requested call.

The ERC is compatible with existing decryption-oracle designs such as [ERC-7573](../EIPS/eip-7573.html) and can be implemented
as an extension of such oracles.

The contract receiving the decrypted arguments can pass these on to other contracts, which can, if necessary,
validate the arguments against the previously stored **hash commitment**.

## Motivation

Privacy- and conditionality-preserving protocols often need to:

- Keep **arguments** confidential until some condition is met (e.g. order books).
- Optionally keep the **target address and function** itself confidential.
- Allow **reusable encrypted argument blobs** that can be passed between contracts and stored on-chain.
- Allow the **receiver** of a call to verify that the decrypted arguments used in the call are exactly those that were committed to earlier.

Existing work like [ERC-7573](../EIPS/eip-7573.html) focuses on a specific decryption-oracle use-case with fixed callbacks (e.g. DvP).
This ERC generalizes that pattern to a **generic function execution** mechanism, designed around:

- a clear separation of **argument encryption** and **call encryption**, and
- an explicit hash commitment enabling verification of the arguments by the receiving contract.

### Exemplary Use-Cases

#### Order Book Build Process avoiding Front Running

A possible use-case is the construction of an auction / order book preventing front-running, where
the proposals can be made during a predefined phase.
Here participants submit their proposals as encrypted hashed arguments, which are stored inside a smart
contract. Once the order phase is closed, the smart contract calls the *call decryption oracle* (passing
itself as the callback target) to receive the decrypted arguments in a call that will build the order book.

## Specification

### 1. Encrypted arguments

Encrypted arguments are independent of any particular call descriptor and can be reused.

Upon (off-chain) encryption (initialization) a hash of the (plain) arguments is generated
accompanying the encrypted arguments to allow later verification.

```solidity
struct EncryptedHashedArguments {
    /**
     * Commitment to the plaintext argument payload.
     * The target contract should check keccak256(argsPlain) == argsHash.
     */
    bytes32 argsHash;

    /**
     * Identifier of the public key used for encryption (e.g. keccak256 of key material).
     */
    bytes32 publicKeyId;

    /**
     * Ciphertext of abi.encode(ArgsDescriptor), encrypted under publicKeyId.
     */
    bytes ciphertext;
}
```

#### Normative requirements (EncryptedHashedArguments)

For producers of `EncryptedHashedArguments`:

- The producer **MUST** compute

```solidity
  argsHash = keccak256(argsPlain);
```

where `argsPlain` is the exact byte sequence that will be passed to the oracle later.

- The producer **MUST** set `ciphertext` to the encryption of exactly

  ```solidity
  abi.encode(argsDescriptor)
  ```

  under the key identified by `publicKeyId`, where `argsDescriptor` is an `ArgsDescriptor` as defined below.

- The producer **MUST** set `argsHash` to the value computed above.

A *call decryption oracle* implementation **MAY** provide a command line tool or endpoint
to generate `EncryptedHashedArguments` from plaintext arguments.

This ERC does not standardize the encryption algorithm or key management; those are implementation-specific (similar to [ERC-7573](../EIPS/eip-7573.html)).
Implementations **SHOULD** document how `publicKeyId` is derived from the underlying key material.

#### Argument Descriptor structure (normative for eligibility)

To allow a *Call Decryption Oracle* to enforce eligibility of the requester in a consistent way,
this ERC standardizes the layout of the decrypted payload as:

```solidity
struct ArgsDescriptor {
    /**
     * List of addresses allowed to request decryption.
     * If empty, any requester is allowed. This is enforced off-chain by the oracle operator.
     */
    address[] eligibleCaller;

    /**
     * Plain argument payload, may be abi.encode(args...) (see router).
     */
    bytes argsPlain;
}
```

Prior to encryption, the arguments are bundled with an (optional)
list of `eligibleCaller`s.

This prevents decryption by other contracts through observing
encrypted arguments and requesting a call to the call decryption oracle.

In this case, producers set

```solidity
bytes32 argsHash = keccak256(argsDescriptor.argsPlain);
bytes   ciphertext = ENC_publicKeyId(abi.encode(argsDescriptor));
```

The `eligibleCaller` list is not visible to on-chain contracts; it is only used off-chain by the
oracle operator to decide whether to honor a decryption request.

### 2. Call descriptor

A **call descriptor** defines:

- which contract and function will be called, and
- any validity constraint (e.g. expiry block).

```solidity
struct CallDescriptor {
    /**
     * Contract that will be called by the oracle.
     */
    address targetContract;

    /**
     * Function that will be called by the oracle.
     * 4-byte function selector for the targetContract.
     */
    bytes4 selector;

    /**
     * Optional expiry (block number). 0 means "no explicit expiry".
     */
    uint256 validUntilBlock;
}
```

#### Plain vs. Encrypted Call Descriptors

A call descriptor can be:

- **Plain**: `CallDescriptor` is passed in clear on-chain.
- **Encrypted**: `CallDescriptor` is wrapped into:

```solidity
struct EncryptedCallDescriptor {
    /**
     * Identifier of the public key used for encryption.
     */
    bytes32 publicKeyId;

    /**
     * Ciphertext of abi.encode(CallDescriptor), encrypted under publicKeyId.
     */
    bytes ciphertext;
}
```

#### Normative requirements (CallDescriptor and EncryptedCallDescriptor)

- When using `EncryptedCallDescriptor`, the ciphertext **MUST** be the encryption
  of exactly `abi.encode(CallDescriptor)` under the key identified by `publicKeyId`.

### 3. Oracle interface

The oracle exposes a **request/fulfill** pattern. Requests are cheap and do not require on-chain decryption; fulfillment is called by an off-chain operator after decryption.

```solidity
interface ICallDecryptionOracle {
    /// Raised when a request with encrypted call descriptor + encrypted args is registered.
    event EncryptedCallRequested(
        uint256 indexed requestId,
        address indexed requester,
        bytes32 callPublicKeyId,
        bytes   callCiphertext,
        bytes32 argsPublicKeyId,
        bytes   argsCiphertext,
        bytes32 argsHash
    );

    /// Raised when a request with plain call descriptor + encrypted args is registered.
    event CallRequested(
        uint256 indexed requestId,
        address indexed requester,
        address   targetContract,
        bytes4    selector,
        uint256   validUntilBlock,
        bytes32   argsPublicKeyId,
        bytes     argsCiphertext,
        bytes32   argsHash
    );

    /// Raised when an execution attempt has been fulfilled by the oracle operator.
    event CallFulfilled(
        uint256 indexed requestId,
        bool    success,
        bytes   returnData
    );

    /**
     * @notice Request execution with encrypted call descriptor + encrypted arguments.
     *
     * @dev MUST:
     * - register a unique requestId,
     * - store (requestId â†’ requester, argsHash, and auxiliary metadata),
     * - emit EncryptedCallRequested.
     */
    function requestEncryptedCall(
        EncryptedCallDescriptor   calldata encCall,
        EncryptedHashedArguments  calldata encArgs
    ) external returns (uint256 requestId);

    /**
     * @notice Request execution with plain call descriptor + encrypted arguments.
     *
     * @dev MUST:
     * - require encArgs.argsHash to be consistent with any application-level commitments,
     * - register a unique requestId and store callDescriptor data + requester,
     * - emit CallRequested.
     */
    function requestCall(
        CallDescriptor            calldata callDescriptor,
        EncryptedHashedArguments  calldata encArgs
    ) external returns (uint256 requestId);

    /**
     * @notice Fulfill an encrypted-call request after off-chain decryption.
     *
     * @param requestId      The id obtained from requestEncryptedCall.
     * @param callDescriptor The decrypted CallDescriptor.
     * @param argsPlain      The decrypted argument payload bytes.
     *
     * @dev MUST:
     * - verify that requestId exists and was created with requestEncryptedCall,
     * - verify callDescriptor.validUntilBlock is zero or >= current block.number,
     * - verify that keccak256(argsPlain) equals the stored argsHash,
     * - perform low-level call:
     *     callDescriptor.targetContract.call(abi.encodePacked(callDescriptor.selector, argsPlain))
     * - emit CallFulfilled(requestId, success, returnData),
     * - clean up stored state for this requestId.
     */
    function fulfillEncryptedCall(
        uint256          requestId,
        CallDescriptor   calldata callDescriptor,
        bytes            calldata argsPlain
    ) external;

    /**
     * @notice Fulfill a plain-call request after off-chain decryption of the arguments.
     *
     * @param requestId The id obtained from requestCall.
     * @param argsPlain The decrypted argument payload bytes.
     *
     * @dev MUST:
     * - verify that requestId exists and was created with requestCall,
     * - load stored CallDescriptor from state,
     * - verify storedCall.validUntilBlock is zero or >= current block.number,
     * - verify that keccak256(argsPlain) equals the stored argsHash,
     * - perform low-level call:
     *     storedCall.targetContract.call(abi.encodePacked(storedCall.selector, argsPlain))
     * - emit CallFulfilled(requestId, success, returnData),
     * - clean up stored state for this requestId.
     */
    function fulfillCall(
        uint256          requestId,
        bytes            calldata argsPlain
    ) external;
}
```

> **Note:** This ERC does not standardize the exact storage layout of pending requests or the internal access control for `fulfill*` (e.g. `onlyOwner`). Implementations MUST ensure that only the intended oracle operator can call the `fulfill*` functions.

### 4. Target contract

A common pattern is that the target (or orchestration) contract

1. In an initialization phase, receives and stores an encrypted argument `encArg` together with its hash `argsHash`,
   where `argsHash` is the hash of the plaintext argument payload.

2. In the execution phase, calls the decryption oracle contract with a (generated) application-level identifier
   (e.g. `clientId`) and the corresponding `encArg`. The target contract then receives the decrypted argument payload
   `argsPlain` (under a callback selector) from the *call decryption oracle*, recomputes the hash and compares it to
   the stored value using that application-level identifier.

For example, the producer of `EncryptedHashedArguments` may choose

```solidity
bytes memory argsPlain = abi.encode(amount, beneficiary);
bytes32 argsHash = keccak256(argsPlain);
```

No `clientId` is included in `argsPlain`. The target (or client) contract can then do:

```solidity
mapping(uint256 => bytes32) public argsHashByClientId;

function registerArguments(uint256 clientId, bytes32 argsHash) external {
    // In the init phase, store the commitment for this clientId.
    argsHashByClientId[clientId] = argsHash;
}

/// @dev Called by the Call Decryption Oracle (or a router/adapter) with decrypted arguments.
function executeWithVerification(
    uint256 clientId,
    bytes   calldata argsPlain
) external {
    // Lookup the pre-committed hash from the init phase.
    bytes32 stored = argsHashByClientId[clientId];
    require(stored != bytes32(0), "Unknown clientId");

    // Recompute the hash from the received bytes.
    bytes32 computed = keccak256(argsPlain);
    require(computed == stored, "Encrypted args mismatch");

    // Optional: decode argsPlain to use it, e.g.
    // (uint256 amount, address beneficiary) = abi.decode(argsPlain, (uint256, address));
}
```

In this pattern:

- `clientId` is any application-level identifier (analogous to the `id` / consumerId in [ERC-7573](../EIPS/eip-7573.html))
  that links the pre-committed `argsHash` to a later execution.
- The `argsPlain` field passed to `fulfill*` is the exact byte payload used to compute `argsHash`.
- A router/adapter contract can implement the `executeWithVerification(uint256 clientId, bytes argsPlain)` callback,
  perform the verification and decoding, and then call an already deployed target contract with its original typed
  function signature.

### 5. Security considerations

This section is non-normative.

#### Oracle trust

The on-chain contract cannot verify correctness of decryption; it can only check that `keccak256(argsPlain) == argsHash`.
Parties must trust the oracle operator (or design an incentive/penalty mechanism) to decrypt correctly and call `fulfill*`
faithfully.

#### Replay

Implementations SHOULD mitigate replay by:

- using `validUntilBlock` in `CallDescriptor`, and/or
- including nonces or sequence numbers in higher-level protocols.

#### Access control

Access control is an application-level concern. A common pattern is to embed an access-control list such as
`address[] eligibleCaller` inside the encrypted payload (in `ArgsDescriptor`) and have the off-chain oracle
operator enforce that the original requester is contained in that list (unless the list is empty, meaning
"any requester"). The standard does not prescribe a particular access-control mechanism beyond this guidance.

#### Fees

Fee mechanisms are out of scope. Implementations MAY charge fees in ETH or ERC-20 tokens as part of their specific deployment.

#### Traceability and non-mixing

This ERC is **not** intended to act as a mixer or general-purpose anonymization service for payments or calls.
Its purpose is to **defer** the disclosure of arguments (and optionally the call descriptor) until fulfillment.

Implementations SHOULD preserve the ability for off-chain indexers and observers to correlate
`CallFulfilled` events with the corresponding `CallRequested` / `EncryptedCallRequested` events,
for example by strictly adhering to the `requestId` linkage defined in this ERC.

Once a request is fulfilled, an observer can always reconstruct which `requester` initiated the request
and which call and arguments were eventually used. Protocols that deliberately try to break this
correlation or to hide value flows are out of scope of this ERC.

## Rationale

- The **two-stage design** (arguments vs. call) allows encrypted arguments to be reusable and independent of any particular call descriptor.
- The explicit **hash commitment** (`argsHash`) binds arguments to a commitment stored by the receiving contract, while still allowing the arguments to be stored and passed separately as opaque bytes.
- The **request/fulfill pattern** reflects that decryption is off-chain. Requests are cheap; fulfill is initiated when decryption is ready.
- The use of `abi.encodePacked(selector, argsPlain)` makes the on-chain oracle generic and able to support arbitrary function signatures, while keeping the correlation identifier (`clientId`) and any higher-level semantics out of the core interface.
- **Router/adapter pattern:** when integrating with already deployed contracts whose function signatures cannot be changed, a small router contract can serve as the callback. The router implements a function like `executeWithVerification(uint256 clientId, bytes argsPlain)`, verifies `clientId` and `argsHash` as above, decodes `argsPlain` into typed arguments, and then calls the pre-existing target contract with its original typed function. This preserves compatibility with existing deployments while still using the standard *call decryption oracle*.

## Backwards Compatibility

This ERC is designed to coexist with [ERC-7573](../EIPS/eip-7573.html) decryption oracles. An existing [ERC-7573](../EIPS/eip-7573.html) implementation can be extended to implement `ICallDecryptionOracle` without breaking existing interfaces.

If earlier drafts used a different interface name (e.g. `IEncryptedExecutionOracle`) or a different `CallDescriptor` layout, only the type names and struct fields have changed; the semantics and function signatures remain equivalent.

## Reference Implementation

A non-normative reference implementation (Solidity) and a matching Java/off-chain implementation are provided separately. They illustrate:

- storage of pending requests,
- event emission for both encrypted and plain call descriptors,
- validation of hash bindings, and
- low-level call execution.

These implementations are work-in-progress and may evolve independently of the ERC text.

## Copyright

Copyright and related rights waived via
[CC0](https://creativecommons.org/publicdomain/zero/1.0/).
