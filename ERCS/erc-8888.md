---
eip: 8888
title: WeissChannels - Cross-Chain Execution for ERC-4337 Accounts
description: A protocol enabling single-signature, atomic, cross-chain execution for Smart Accounts via ephemeral state channels secured optimistically by Ethereum L1
author: Yoav Weiss (@yoavw), Shahaf Nacson (@shahafn), Marissa Posner (@marissaposner), Dror Tirosh (@drortirosh), Alex Forshtat (@forshtat), Tom Teman (@tomteman), eil-docbot (@eil-docbot)
discussions-to: https://ethereum-magicians.org/t/erc-8888-trustless-cross-chain-execution-for-erc-4337-accounts/27577
status: Draft
type: Standards Track
category: ERC
created: 2026-01-24
requires: 4337
---

## Abstract

This ERC defines WeissChannels, a protocol extension for ERC-4337 Smart Accounts that enables single-signature, atomic, cross-chain execution without custodial intermediaries. The protocol introduces ephemeral, "just-in-time" state channels secured optimistically by Ethereum Layer 1, allowing users to control assets and execute transactions across multiple L2 chains with a single Merkle root signature.

WeissChannels restore the seamless experience of a single chain while preserving Ethereum's core guarantees: censorship resistance, self-custody, and disintermediation. Unlike intent-based systems where users delegate execution to third parties, WeissChannels enable users to execute their own transactions on destination chains, using Crosschain Liquidity Providers (XLPs) only for liquidity and gas fronting.

## Motivation

Ethereum's rollup-centric roadmap has successfully scaled throughput but has severely fragmented the user experience. Each Layer 2 functions as an isolated island with its own gas market, liquidity, and bridging delays. Users are effectively "chain-bound," forced to choose between:

1. **Trust-minimized canonical bridges** with prohibitive latency (7+ days for Optimistic Rollups)
2. **Third-party intent solvers** with centralized trust assumptions

Current cross-chain solutions compromise Ethereum's core values:

- **Censorship Resistance:** Transacting through permissioned intermediaries or gatekeepers
- **Security:** Trusting third parties with funds or state attestation (e.g., Multi-Sig bridges)
- **Privacy:** Exposing user IP addresses and intentions to centralized servers before execution
- **Openness:** Relying on opaque, proprietary off-chain solving logic

### Why General Purpose Intents Fail

At first glance, intent solvers seem like the path of least resistance. However, permissionless and decentralized solvers face structural Denial of Service (DoS) and griefing risks:

1. **The "Salmonella" Risk:** A malicious user could deploy a contract on the destination chain that reverts only when a specific solver attempts to fulfill an intent. This causes the solver to burn gas without compensation.
2. **The Whitelist Response:** To mitigate this, solvers inevitably create whitelists of "safe" contracts (e.g., only USDC and WETH). This degrades censorship resistance and hinders permissionless innovation.
3. **Verification Complexity:** General purpose intents can be arbitrarily complex. If a solver executes an intent with marginal gas, causing an internal revert while the outer transaction succeeds, the user pays but receives nothing.

### The Privacy/Safety/UX Trilemma

Submitting an intent reveals the user's desired outcome ahead of time. This creates a fundamental trilemma:

| Optimization | Example Approach | What is Lost |
|-------------|------------------|--------------|
| Privacy + UX | On-chain intent protocols (public mempool) | **Safety** - Transactions observed and exploited/sandwiched before inclusion |
| Safety + UX | Reputable off-chain solver networks | **Privacy** - User IP and intent metadata revealed to centralized solver |
| Safety + Privacy | Split flow: Bridge then execute | **UX** - High latency, multiple signatures, fragmented flow |

### The WeissChannel Solution

WeissChannels solve this trilemma by putting the user in control. By enabling the user to execute their own transactions on the destination chain (using the XLP only for liquidity/gas), we remove the need for a third party to understand or simulate the transaction logic.

The system follows an **Optimistic Rollup security model** with a 1-of-N honest assumption: the system is secure as long as *one* honest actor (a watcher, the user, or a rival XLP) is online to submit a fraud proof. Unlike custodial bridges (which require honest majority) or intent networks (which require honest federation), WeissChannels derive security directly from Ethereum L1.

The vision is simple: **Multichain should feel like a single chain.** If Alice on Arbitrum wants to send ETH to Bob on Base, she should paste the address and click send. Her wallet abstracts the complexity, paying fees in any asset, signing once, and settling within seconds—all without trusting a third party.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Definitions

- **WeissChannel**: An ephemeral, one-shot state channel designed for cross-chain atomicity, secured by an optimistic dispute mechanism on Ethereum L1. Unlike traditional state channels (e.g., Lightning Network) which are long-lived and require pre-funding, a WeissChannel is spun up for exactly one transaction sequence and immediately dissolves.

- **XLP (Crosschain Liquidity Provider)**: A permissionless market maker who fronts liquidity and gas on destination chains. XLPs MUST stake on L1 via the `L1StakeManager` and MAY register liquidity on individual L2s via the `CrossChainPaymaster`.

- **Voucher**: A cryptographic commitment from an XLP to provide specified funds and/or gas on a destination chain. The voucher is issued off-chain and consumed on-chain during UserOp validation.

- **VoucherRequest**: An on-chain commitment from a user locking funds on a source chain, specifying the terms under which an XLP may claim those funds in exchange for providing a voucher.

- **Multichain UserOp**: A set of ERC-4337 UserOperations across multiple chains, authorized by a single signature over a Merkle root. Each chain receives only the leaf relevant to it, along with a Merkle proof and the root signature.

- **CrossChainPaymaster**: A contract deployed on each supported chain that manages voucher requests (on source chains) and voucher consumption (on destination chains).

- **L1StakeManager**: The singleton contract on Ethereum Mainnet that holds XLP security stakes and processes fraud proofs.

### Protocol Overview

#### The "Just-In-Time" Paradigm

Unlike traditional state channels (e.g., the Lightning Network) which are long-lived, bilateral, and require pre-funding, a WeissChannel is multilateral and ad-hoc. It is spun up for exactly one block to settle one specific transaction sequence, and then immediately dissolves.

This avoids the capital inefficiency of locking funds in channels that may sit idle. Instead, liquidity is sourced dynamically from a permissionless pool of Crosschain Liquidity Providers (XLPs).

#### Layer 1 as the "Supreme Court"

The protocol adheres to the Optimistic security model. Ethereum Mainnet (L1) is never used for transaction execution, which would be too slow and expensive. Instead, L1 acts strictly as the judiciary:

- It holds security stakes from XLPs
- It processes dispute proofs only when a counterparty acts maliciously
- The normal case operates at L2 speed
- The worst case retains L1 security

This is analogous to how Optimistic Rollups work: transactions execute quickly on L2, with L1 serving as the court of last resort.

#### Account-Based vs. Messaging-Based

WeissChannels are explicitly **account-based**, not messaging-based:

- **Account-Based (WeissChannels):** Enables a *user* to control assets and execute calls on multiple chains. The user initiates every action. This removes the "mid-state" dependency where a relaying bridge holds custody.
- **Messaging-Based (Bridges):** Enables a *contract* on Chain A to call a *contract* on Chain B.

WeissChannels do not attempt to enable generic contract-to-contract composability. For use cases where a contract needs to trigger an action remotely without a user present, trust-minimized messaging bridges are still required. WeissChannels are optimized specifically for the user-centric wallet experience.

#### Protocol Participants

1. **User (Alice):** The initiator of the transaction who signs a Merkle root authorizing operations across multiple chains.

2. **XLP (Crosschain Liquidity Provider):** A permissionless market maker who fronts liquidity and gas on the destination chain, earning fees in return.

3. **CrossChainPaymaster (Hubs):** Modular contracts deployed on every supported L2 that manage asset locking, voucher verification, and atomic swapping.

4. **L1 Stake Manager:** The "Judge" contract on Ethereum Mainnet holding XLP penalty stakes and processing disputes.

### Data Structures

#### Multichain UserOp (Account-Level)

To enable single-signature cross-chain execution, the user signs a Merkle root of a tree containing operations for multiple chains. This validation occurs at the Smart Account level, not the paymaster level.

Each leaf in the Merkle tree represents a chain-specific operation:

```solidity
struct ChainUserOp {
    address sender;       // Smart Account address
    uint256 nonce;        // Account nonce on this specific chain
    bytes callData;       // Encoded call to execute
    uint256 callGasLimit; // Gas limit for the call execution
    uint256 chainId;      // Target chain identifier
}
```

The leaf hash MUST be computed as:

```solidity
bytes32 leaf = keccak256(abi.encode(
    chainUserOp.sender,
    chainUserOp.nonce,
    chainUserOp.callData,
    chainUserOp.callGasLimit,
    chainUserOp.chainId
));
```

The user signs the Merkle root `R`. For each chain, the Smart Account's `validateUserOp` function:
1. Extracts the Merkle root, proof, and signature from `userOp.signature`
2. Verifies the signature over the Merkle root
3. Verifies the Merkle proof for the chain-specific operation

> **Note:** The Merkle tree validation is implemented in the Smart Account, not the CrossChainPaymaster. The paymaster only validates vouchers.

#### Asset

An `Asset` represents a token and amount pair. Native ETH is represented using the ERC-7528 sentinel address.

```solidity
/// @dev ERC-7528 sentinel address for native ETH
address constant NATIVE_ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

struct Asset {
    address erc20Token;  // Token address (NATIVE_ETH for native ETH)
    uint256 amount;      // Amount of tokens
}
```

#### AtomicSwapFeeRule

Defines the fee schedule for the reverse Dutch auction. All fee values are denominated as percentage numerators with 4 decimal places of precision (10000 = 100%).

```solidity
struct AtomicSwapFeeRule {
    uint256 startFeePercentNumerator;   // Starting fee percentage (1 = 0.01%, 100 = 1%)
    uint256 maxFeePercentNumerator;     // Maximum fee percentage cap
    uint256 feeIncreasePerSecond;       // Fee increase per second (in numerator units)
    uint256 unspentVoucherFee;          // Fee charged if voucher is not consumed
}
```

#### SourceSwapComponent

Describes the source chain side of an atomic swap request.

```solidity
struct SourceSwapComponent {
    uint256 chainId;              // Source chain identifier
    address paymaster;            // CrossChainPaymaster address on source chain
    address payable sender;       // User's account address
    Asset[] assets;               // Assets being locked on source chain
    AtomicSwapFeeRule feeRule;    // Fee schedule for XLP compensation
    uint256 senderNonce;          // User's nonce for replay protection
    address[] allowedXlps;        // Whitelist of permitted XLPs (empty = any registered XLP)
}
```

#### DestinationSwapComponent

Describes the destination chain side of an atomic swap request.

```solidity
struct DestinationSwapComponent {
    uint256 chainId;              // Destination chain identifier
    address paymaster;            // CrossChainPaymaster address on destination chain
    address payable sender;       // User's account address (MUST match source)
    Asset[] assets;               // Assets requested on destination chain
    uint256 maxUserOpCost;        // Maximum gas cost the user is willing to pay
    uint256 expiresAt;            // Timestamp after which the request expires
}
```

#### AtomicSwapVoucherRequest

The complete voucher request combining source and destination components. This is created when a user locks funds on the source chain.

```solidity
struct AtomicSwapVoucherRequest {
    SourceSwapComponent origination;     // Source chain parameters
    DestinationSwapComponent destination; // Destination chain parameters
}
```

The request ID MUST be computed as:

```solidity
bytes32 requestId = keccak256(abi.encode(voucherRequest));
```

#### VoucherType

Specifies the type of voucher being issued.

```solidity
enum VoucherType {
    STANDARD,      // Normal voucher fulfillment
    OVERRIDE,      // Override a previous voucher (higher priority)
    ALT,           // Alternative XLP fulfillment
    ALT_OVERRIDE   // Alternative XLP override
}
```

#### AtomicSwapVoucher

An XLP's signed commitment to provide funds on the destination chain.

```solidity
struct AtomicSwapVoucher {
    bytes32 requestId;                        // Hash of the AtomicSwapVoucherRequest
    address payable originationXlpAddress;    // XLP address providing the voucher
    DestinationSwapComponent voucherRequestDest; // Destination parameters (may differ from original request)
    uint256 expiresAt;                        // Timestamp after which voucher expires
    VoucherType voucherType;                  // Type of voucher
    bytes xlpSignature;                       // XLP's EIP-191 signature
}
```

#### SessionData

Session data carries ephemeral authorization for a voucher bundle, preventing front-running attacks.

```solidity
struct SessionData {
    bytes data;                 // Optional application-specific session data
    bytes ephemeralSignature;   // Signature from ephemeral signer over voucher bundle
}
```

The `ephemeralSignature` is produced by the ephemeral private key (known only to the user's client) signing over the hash of the selected vouchers. This binds the user's transaction to specific vouchers, preventing substitution.

#### DestinationVoucherRequestsData

Paymaster data structure specifying expected vouchers and ephemeral authorization.

```solidity
struct DestinationVoucherRequestsData {
    Asset[][] vouchersAssetsMinimums;  // Per-voucher minimum asset requirements
    address ephemeralSigner;            // Address authorized to sign voucher bundles
}
```

- `vouchersAssetsMinimums[i]`: The minimum assets the user requires for voucher `i`. If an XLP's voucher provides less, the paymaster MUST reject it.
- `ephemeralSigner`: A freshly-generated address for this batch. The paymaster verifies that the voucher bundle is signed by this address.

#### Voucher Signing (EIP-191)

Vouchers MUST be signed using EIP-191 personal sign format. The message to sign is constructed as:

```solidity
bytes memory message = abi.encode(
    voucherRequestDest,           // Full DestinationSwapComponent struct
    requestId,                    // Request ID being fulfilled
    originationXlpAddress,        // XLP's address
    expiresAt,                    // Voucher expiration
    uint8(voucherType)            // Voucher type as uint8
);

bytes32 messageHash = keccak256(abi.encodePacked(
    "\x19Ethereum Signed Message:\n32",
    keccak256(message)
));
```

The XLP signs `messageHash` using ECDSA, producing the `xlpSignature` field. Verification recovers the signer and compares against `originationXlpAddress`.

#### Paymaster Data Encoding

The `paymasterData` field in a UserOp MUST be encoded according to the following specification. This encoding enables the paymaster to verify voucher requests and ephemeral authorization.

The base paymaster data is the ABI-encoded `DestinationVoucherRequestsData` struct (defined above), which specifies the user's minimum asset requirements and ephemeral signer commitment.

##### Encoding Format

The paymaster data is constructed in layers:

```
paymasterData = basePaymasterData || paymasterSignature || lengthTrailer || magic
```

Where:
- `basePaymasterData`: ABI-encoded `DestinationVoucherRequestsData`
- `paymasterSignature`: The voucher bundle with ephemeral signature (initially `0x01` placeholder)
- `lengthTrailer`: `uint16` encoding the length of `paymasterSignature`
- `magic`: Constant `0x22e325a297439656` (8 bytes) marking the signature boundary

```solidity
/// @dev Magic constant marking the paymaster signature trailer
bytes8 constant PAYMASTER_SIG_MAGIC = 0x22e325a297439656;

function appendPaymasterSignature(
    bytes memory basePaymasterData,
    bytes memory paymasterSignature
) internal pure returns (bytes memory) {
    uint16 sigLen = uint16(paymasterSignature.length);
    return abi.encodePacked(
        basePaymasterData,
        paymasterSignature,
        sigLen,
        PAYMASTER_SIG_MAGIC
    );
}
```

##### Voucher Bundle Encoding

Once XLP vouchers are received, the `paymasterSignature` portion is replaced with the full voucher bundle containing the vouchers and `SessionData` (defined above):

```solidity
/// @notice Encode vouchers with session data for paymaster signature
function encodeVoucherBundle(
    AtomicSwapVoucher[] memory vouchers,
    SessionData memory sessionData
) internal pure returns (bytes memory);
```

The ephemeral signature within `SessionData` is computed over the hash of the voucher bundle, preventing substitution attacks.

##### Ephemeral Signer Mechanism

The ephemeral signer provides front-running protection for the voucher selection process:

1. **Generation**: When building a cross-chain batch, the SDK generates a fresh random private key
2. **Commitment**: The corresponding address is included in `DestinationVoucherRequestsData`
3. **Authorization**: After receiving vouchers from XLPs, the ephemeral key signs the selected voucher bundle
4. **Verification**: The paymaster verifies the ephemeral signature matches the committed address

This prevents attacks where:
- A malicious bundler substitutes worse vouchers after seeing the user's transaction
- A competing XLP front-runs with their own voucher after seeing the user's preference

**Security Note**: The ephemeral private key MUST be kept confidential until the transaction is submitted. Implementations SHOULD generate the key client-side and never transmit it.

##### Paymaster Data Lifecycle

```
1. Initial (unsigned):
   paymasterData = encode(vouchersAssetsMinimums, ephemeralSigner) || 0x01 || 0x0001 || MAGIC

2. After voucher selection:
   voucherBundle = encode(vouchers[], sessionData{data, ephemeralSig})
   paymasterData = encode(vouchersAssetsMinimums, ephemeralSigner) || voucherBundle || len || MAGIC

3. Paymaster validates:
   - Decode and verify ephemeral signature
   - Verify each voucher's XLP signature
   - Verify assets meet minimums
   - Verify vouchers not expired
```

### Protocol Lifecycle

The WeissChannel protocol replaces the traditional Hash Time Locked Contract (HTLC) with an optimistic design. Traditional HTLCs require a secret preimage and multiple transactions on both chains. WeissChannels leverage the existence of L1 as a slow-but-trustless messaging layer to remove the need for a secret, reducing the number of transactions on the destination chain to zero (via piggybacking on the user's UserOp).

#### Step 1: Registration & Staking

XLPs register by depositing funds in the `CrossChainPaymaster` on various L2s. Crucially, they must also lock a security stake in the `L1AtomicSwapStakeManager` on Ethereum Mainnet.

- **Unstake Delay:** 8 days. This period is strictly longer than the maximum L2 finality time (typically 7 days for Optimistic Rollups).
- **Immediate Unregistration:** If an XLP initiates the unstake process, they are immediately unregistered from the active set to prevent "exit scams."

#### Step 2: Commitment (Source Chain)

The user broadcasts a `UserOp` on the Source Chain (Chain A). This operation locks their assets (e.g., 100 USDC) in the `CrossChainPaymaster` via `lockUserDeposit()`.

- **Fee Schedule:** The user specifies a list of XLPs they are willing to use and a fee schedule (reverse Dutch auction).
- **Short-Lived Lock:** The request has a short expiration. If no voucher is provided promptly, the user's funds automatically unlock via `cancelVoucherRequest()`, preventing "limbo" states.

#### Step 3: Voucher Issuance (Off-Chain)

An XLP observes the lock event. If the parameters meet their profitability criteria, they sign a **Voucher**—a cryptographic commitment to provide the requested funds/gas on the Destination Chain (Chain B). The XLP calls `issueVouchers()` to advertise their voucher on-chain.

Multiple XLPs can issue vouchers simultaneously for the same request. This creates competition and ensures users get the best rates.

#### Step 4: Execution (Destination Chain)

The user appends the XLP's voucher to their Chain B `UserOp` signature and submits it to Chain B.

- **Zero-Overhead Claiming:** The XLP does not submit a separate transaction. The Chain B `CrossChainPaymaster` verifies the voucher *during* the validation phase of the user's transaction.
- **Atomic Swap:** If the voucher is valid, the Paymaster pays for the user's gas and credits the specified assets to their execution context.
- **Execution:** The user's transaction executes (e.g., buying an NFT, sending to a recipient).

#### Step 5: Settlement (Source Chain)

The XLP claims the user's locked funds on Chain A by calling `withdrawFromUserDeposit()` with the signed voucher.

- **Anti-Rugpull Lock:** Upon settlement, the funds on Chain A remain locked for a brief period before being credited to the XLP's deposit. This window allows for dispute resolution if the XLP attempts to double-spend or exploit a Chain A reorg.

#### Step 6: Completion Call (Optional)

The protocol flow can continue to traverse any number of L2s using the same signature. It can also perform a **Completion Call** back on Chain A. This enables round-trip workflows, such as:

- Bridging assets out to perform a yield farming strategy and bridging the receipt tokens back
- Executing a swap on a remote DEX and returning the swapped tokens
- Aggregating liquidity from multiple chains into a single destination transaction

### Contracts

#### AtomicSwapStatus

Tracks the lifecycle state of a voucher request.

```solidity
enum AtomicSwapStatus {
    NONE,           // Request does not exist
    NEW,            // Request created, awaiting voucher
    VOUCHER_ISSUED, // Voucher has been issued by an XLP
    CANCELLED,      // Request cancelled by user (funds returned)
    DISPUTE,        // Request is under dispute
    PENALIZED,      // XLP was slashed for this request
    SUCCESSFUL,     // Swap completed successfully
    UNSPENT         // Voucher was not consumed on destination
}
```

#### CrossChainPaymaster

The `CrossChainPaymaster` MUST be deployed on every supported chain. It serves as the central hub for WeissChannel operations, combining four distinct roles:

1. **Origin Swap Manager:** On the source chain, it locks user funds, tracks voucher requests, and releases funds to XLPs after successful execution.

2. **Destination Swap Manager:** On the destination chain, it validates vouchers during UserOp validation and releases XLP funds to users.

3. **XLP Registry:** Maintains the list of registered XLPs for this chain, synchronized with L1 stake status.

4. **Dispute Manager:** Initiates and processes disputes when XLPs misbehave, coordinating with the L1StakeManager for slashing.

The paymaster architecture enables **zero-overhead claiming**: the XLP does not submit a separate transaction on the destination chain. Instead, voucher validation happens during the ERC-4337 validation phase of the user's own transaction, piggybacking on the user's gas payment.

##### Origin Chain Functions

```solidity
interface IOriginSwapManager {
    /// @notice Lock user funds and create a voucher request
    /// @param voucherRequest The complete swap request parameters
    function lockUserDeposit(AtomicSwapVoucherRequest calldata voucherRequest) external payable;

    /// @notice XLP issues vouchers for pending requests
    /// @dev Multiple XLPs can issue vouchers simultaneously; first consumed wins
    /// @param vouchers Array of voucher-request pairs
    function issueVouchers(VoucherWithRequest[] calldata vouchers) external;

    /// @notice XLP issues alternative vouchers during a dispute
    /// @dev Valid only when swap is in DISPUTE status
    /// @param vouchers Array of alternative voucher-request pairs
    function issueAltVouchers(VoucherWithRequest[] calldata vouchers) external;

    /// @notice XLP overrides a previously issued voucher
    /// @dev Used when XLP claims they provided liquidity instead of original issuer
    /// @param voucherRequest The original request
    /// @param voucherOverride The override voucher
    function overrideVoucher(
        AtomicSwapVoucherRequest calldata voucherRequest,
        AtomicSwapVoucher calldata voucherOverride
    ) external payable;

    /// @notice XLP withdraws user's locked funds after voucher execution
    /// @param voucherRequests Requests to withdraw from
    function withdrawFromUserDeposit(AtomicSwapVoucherRequest[] calldata voucherRequests) external;

    /// @notice User cancels a request and retrieves locked funds
    /// @dev Only valid if no voucher has been consumed
    /// @param voucherRequest The request to cancel
    function cancelVoucherRequest(AtomicSwapVoucherRequest calldata voucherRequest) external;

    /// @notice Claim fee for voucher that was issued but not consumed
    /// @param voucherRequest The request with unspent voucher
    function claimUnspentVoucherFee(AtomicSwapVoucherRequest calldata voucherRequest) external;

    /// @notice Withdraw the unspent voucher fee after dispute window
    /// @param voucherRequest The request to withdraw fee from
    function withdrawUnspentVoucherFee(AtomicSwapVoucherRequest calldata voucherRequest) external;

    /// @notice Get metadata for an atomic swap
    /// @param requestId The request identifier
    /// @return metadata The swap metadata
    function getAtomicSwapMetadata(bytes32 requestId) external view returns (AtomicSwapMetadata memory);

    /// @notice Get the current nonce for a sender
    /// @param sender The sender address
    /// @return The current nonce
    function getSenderNonce(address sender) external view returns (uint256);

    /// @notice Get timestamp when XLP made an override
    /// @param requestId The request identifier
    /// @param l2XlpAddress The XLP address
    /// @return The override timestamp
    function getVoucherOverrideTimestamp(bytes32 requestId, address l2XlpAddress) external view returns (uint256);
}
```

##### Origin Chain Events

```solidity
event VoucherRequestCreated(
    bytes32 indexed requestId,
    address indexed sender,
    AtomicSwapVoucherRequest voucherRequest
);

event VoucherIssued(
    bytes32 indexed requestId,
    address indexed sender,
    uint256 indexed senderNonce,
    AtomicSwapVoucher voucher
);

event UserDepositWithdrawn(
    bytes32 indexed requestId,
    address indexed sender,
    address indexed voucherIssuer
);

event VoucherRequestCancelled(
    bytes32 indexed requestId,
    address indexed sender
);

event UnspentVoucherFeeClaimed(
    bytes32 indexed requestId,
    address indexed sender,
    address indexed withdrawer,
    address voucherIssuer
);

event UnspentVoucherFeeWithdrawn(
    bytes32 indexed requestId,
    address indexed sender,
    address indexed withdrawer
);
```

##### Destination Chain Functions

```solidity
interface IDestinationSwapManager {
    /// @notice Withdraw funds from a voucher (called during UserOp execution)
    /// @dev Typically called via paymaster validation, not directly
    /// @param voucherRequest The original request
    /// @param voucher The voucher to consume
    function withdrawFromVoucher(
        AtomicSwapVoucherRequest memory voucherRequest,
        AtomicSwapVoucher memory voucher
    ) external;

    /// @notice Get status of an incoming atomic swap
    /// @param requestId The request identifier
    /// @return The destination-side metadata
    function getIncomingAtomicSwap(bytes32 requestId) external view returns (AtomicSwapMetadataDestination memory);
}
```

##### Destination Chain Events

```solidity
event VoucherSpent(
    bytes32 indexed requestId,
    address indexed sender,
    address payable indexed originationXlpAddress,
    uint256 expiresAt,
    VoucherType voucherType
);
```

##### XLP Registry Functions

```solidity
interface IL2XlpRegistry {
    /// @notice Called by L1StakeManager when XLP stakes for this chain
    /// @param l1XlpAddress The XLP's L1 address
    /// @param l2XlpAddress The XLP's L2 address
    function onL1XlpChainInfoAdded(address l1XlpAddress, address l2XlpAddress) external;

    /// @notice Called by L1StakeManager when XLP's stake is unlocked
    /// @param l1XlpAddress The XLP's L1 address
    function onL1XlpStakeUnlocked(address l1XlpAddress) external;

    /// @notice Check if an L1 XLP address is registered
    /// @param l1XlpAddress The L1 address to check
    /// @return True if registered
    function isL1XlpRegistered(address l1XlpAddress) external view returns (bool);

    /// @notice Check if an L2 XLP address is registered
    /// @param l2XlpAddress The L2 address to check
    /// @return True if registered
    function isL2XlpRegistered(address l2XlpAddress) external view returns (bool);

    /// @notice Get XLP info by L1 address
    /// @param l1XlpAddress The L1 address
    /// @return The XLP entry
    function getXlpByL1Address(address l1XlpAddress) external view returns (XlpEntry memory);

    /// @notice Get XLP info by L2 address
    /// @param l2XlpAddress The L2 address
    /// @return The XLP entry
    function getXlpByL2Address(address l2XlpAddress) external view returns (XlpEntry memory);

    /// @notice Get paginated list of registered XLPs
    /// @param offset Starting position
    /// @param length Maximum entries to return
    /// @return Array of XLP entries
    function getXlps(uint256 offset, uint256 length) external view returns (XlpEntry[] memory);
}
```

##### Dispute Functions

```solidity
interface IL2XlpDisputeManager {
    /// @notice Initiate dispute against insolvent XLP
    /// @param disputeVouchers Per-request dispute descriptors
    /// @param altVouchers Alternative vouchers from a different XLP
    /// @param l2XlpAddressToSlash XLP to slash
    /// @param l1Beneficiary Beneficiary of slashed funds
    /// @param chunkIndex Index of this chunk in multi-chunk report
    /// @param numberOfChunks Total chunks in report
    /// @param nonce Dispute nonce
    /// @param committedRequestIdsHash Hash of all request IDs
    /// @param committedVoucherCount Total voucher count
    function disputeInsolventXlp(
        DisputeVoucher[] calldata disputeVouchers,
        VoucherWithRequest[] calldata altVouchers,
        address l2XlpAddressToSlash,
        address payable l1Beneficiary,
        uint256 chunkIndex,
        uint256 numberOfChunks,
        uint256 nonce,
        bytes32 committedRequestIdsHash,
        uint256 committedVoucherCount
    ) external payable;

    /// @notice Dispute a fraudulent voucher override
    /// @param disputeVouchers Per-request dispute descriptors
    /// @param l2XlpAddressToSlash XLP to slash
    /// @param l1Beneficiary Beneficiary of slashed funds
    function disputeVoucherOverride(
        DisputeVoucher[] calldata disputeVouchers,
        address l2XlpAddressToSlash,
        address payable l1Beneficiary
    ) external payable;

    /// @notice Dispute a fraudulent unspent voucher fee claim
    /// @param disputeVouchers Per-request dispute descriptors
    /// @param l1Beneficiary Beneficiary of slashed funds
    function disputeXlpUnspentVoucherClaim(
        DisputeVoucher[] calldata disputeVouchers,
        address payable l1Beneficiary
    ) external payable;

    /// @notice Withdraw dispute bonds after resolution
    /// @param requestIds Requests to withdraw bonds for
    function withdrawDisputeBonds(bytes32[] calldata requestIds) external;

    /// @notice Called by L1StakeManager after slash is confirmed
    /// @param slashOutput The slash information
    function onXlpSlashedMessage(SlashOutput calldata slashOutput) external;
}
```

##### Dispute Events

```solidity
event DisputeInitiated(
    bytes32 indexed requestId,
    address indexed l2XlpAddressToSlash,
    address indexed disputer,
    address l1Beneficiary
);

event InsolvencyReportStarted(
    bytes32 indexed reportId,
    address indexed reporter,
    address indexed l2XlpAddressToSlash,
    address l1Beneficiary,
    uint256 originationChainId,
    uint256 destinationChainId,
    uint256 numberOfChunks,
    bytes32 committedRequestIdsHash,
    uint256 committedVoucherCount,
    uint256 firstChunkTimestamp
);

event InsolvencyReportChunk(
    bytes32 indexed reportId,
    uint256 indexed chunkIndex,
    uint256 indexed numberOfChunks,
    uint256 chunkSize,
    uint256 chunkTimestamp
);

event JustifiedDisputeRequestsReported(
    bytes32 indexed reportId,
    bytes32 indexed reportRequestIdsHash,
    address indexed reporter,
    bytes32 chunkRequestIdsHash,
    uint256 providedCount,
    uint256 penalizedCount
);
```

##### Supporting Structs

```solidity
struct VoucherWithRequest {
    AtomicSwapVoucherRequest voucherRequest;
    AtomicSwapVoucher voucher;
}

struct XlpEntry {
    address l1XlpAddress;
    address l2XlpAddress;
}

struct AtomicSwapMetadata {
    AtomicSwapMetadataCore core;
    uint256[] amountsAfterFee;
    address payable unspentFeeXlpRecipient;
    address overrideBondToken;
    uint256 overrideBondAmount;
    address disputeBondToken;
    uint256 disputeBondAmount;
    address payable disputeBondOwner;
}

struct AtomicSwapMetadataCore {
    AtomicSwapStatus status;
    uint40 createdAt;
    uint40 voucherIssuedAt;
    uint40 voucherExpiresAt;
    VoucherType voucherType;
    address payable voucherIssuerL2XlpAddress;
}

struct AtomicSwapMetadataDestination {
    AtomicSwapStatus status;
    address paidByL2XlpAddress;
}

struct DisputeVoucher {
    AtomicSwapVoucherRequest voucherRequest;
    BondType bondType;
}

struct SlashOutput {
    address l2XlpAddressToSlash;
    bytes32 requestIdsHash;
    uint256 originationChainId;
    uint256 destinationChainId;
    DisputeType disputeType;
}

enum DisputeType {
    INSOLVENT_XLP,
    VOUCHER_OVERRIDE,
    UNSPENT_VOUCHER_FEE_CLAIM
}

enum BondType {
    PERCENT,
    NATIVE
}
```

#### L1AtomicSwapStakeManager

The `L1AtomicSwapStakeManager` MUST be deployed on Ethereum Mainnet. It serves as the "Supreme Court" of the WeissChannel system—the ultimate arbiter of disputes that ensures XLPs cannot steal funds or grief users without consequence.

**Capital Efficiency: O(Networks) Staking**

In custodial bridges, relayers often must lock collateral proportional to the value they are moving (e.g., $1M locked to move $1M). WeissChannels operate on a **Performance Bond** model:

- The XLP's L1 stake is a penalty bond, not a liquidity backing
- Therefore, the stake scales with the number of networks supported (O(Networks)), not the volume of transactions (O(Volume))
- A single 10 ETH stake can secure unlimited volume, provided the XLP maintains liquid float on the L2s to fulfill vouchers

**The Security Inequality**

The system remains secure against griefing attacks as long as the slashed stake exceeds the utility gained from griefing:

```
S_XLP > U_grief
```

Crucially, since the XLP must provide the voucher (value) *before* claiming the user's funds, they cannot steal funds (U_theft = 0). Therefore, the stake does not need to cover the transaction value, allowing for high capital efficiency:

```
S_XLP << V_tx
```

##### Configuration Constants

```solidity
struct Config {
    uint256 claimDelay;            // Delay before slashed funds can be claimed
    uint256 destBeforeOriginMinGap; // Minimum time gap between destination proof and origin dispute
    uint256 minStakePerChain;      // Minimum stake required per supported chain
    uint256 unstakeDelay;          // Delay before unlocked stake can be withdrawn
    uint256 maxChainsPerXlp;       // Maximum chains an XLP can support
    uint256 l2SlashedGasLimit;     // Gas limit for L2 slash notifications
    uint256 l2StakedGasLimit;      // Gas limit for L2 stake notifications
    address owner;                 // Contract owner
}
```

| Parameter | Recommended Value | Rationale |
|-----------|-------------------|-----------|
| `unstakeDelay` | 8 days | Longer than maximum L2 finality (7 days for Optimistic Rollups) |
| `claimDelay` | 1 hour | Window for additional dispute evidence |
| `destBeforeOriginMinGap` | 1 hour | Ensures destination proof precedes origin dispute |
| `minStakePerChain` | Configurable | Must exceed maximum griefing utility |

##### Staking Functions

```solidity
interface IL1AtomicSwapStakeManager {
    /// @notice Register as XLP and stake for specified chains
    /// @dev msg.value MUST equal chainIds.length * MIN_STAKE_PER_CHAIN
    /// @param chainIds Chain IDs to support
    /// @param chainsInfo Configuration for each chain
    function addChainsInfo(
        uint256[] calldata chainIds,
        ChainInfo[] calldata chainsInfo
    ) external payable;

    /// @notice Initiate stake unlock (begins unstake delay)
    /// @dev XLP is immediately unregistered from active set
    /// @param chainIds Chains to unlock stake for
    function unlockStake(uint256[] calldata chainIds) external;

    /// @notice Withdraw stake after unstake delay has passed
    /// @param withdrawAddress Address to receive withdrawn funds
    /// @param chainIds Chains to withdraw stake from
    function withdrawStake(
        address payable withdrawAddress,
        uint256[] calldata chainIds
    ) external;

    /// @notice Get stake info for an XLP
    /// @param xlp XLP address
    /// @param chainIds Chains to query
    /// @return info Array of stake information
    function getStakeInfo(
        address xlp,
        uint256[] calldata chainIds
    ) external view returns (StakeInfo[] memory info);

    /// @notice Get all chain configurations for an XLP
    /// @param xlp XLP address
    /// @return info Array of chain configurations
    function getChainInfos(address xlp) external view returns (ChainInfoReturnStruct[] memory info);

    /// @notice Get all chain IDs supported by an XLP
    /// @param xlp XLP address
    /// @return Array of chain IDs
    function getXlpChainIds(address xlp) external view returns (uint256[] memory);
}
```

##### Dispute Resolution Functions

```solidity
interface IL1AtomicSwapStakeManager {
    /// @notice Pull and process dispute messages from L2 bridges
    /// @dev Atomically matches origin disputes with destination proofs
    /// @param bridges Array of L1 bridge connectors
    /// @param bridgeMessagesPerBridge Calldata for each bridge
    function pullMessagesFromBridges(
        IL1Bridge[] calldata bridges,
        bytes[][] calldata bridgeMessagesPerBridge
    ) external;

    /// @notice Receive origin-side dispute report from L2
    /// @dev Called via trusted L1 connector
    /// @param originLeg The dispute report data
    function reportOriginDispute(ReportDisputeLeg calldata originLeg) external;

    /// @notice Receive destination-side proof report from L2
    /// @dev Called via trusted L1 connector
    /// @param proofLeg The proof report data
    function reportDestinationProof(ReportProofLeg calldata proofLeg) external;

    /// @notice Claim share of slashed stake (for insolvency disputes)
    /// @dev Uses longest-array algorithm to determine winners
    /// @param l1XlpAddress Slashed XLP's L1 address
    /// @param originationChainId Origin chain
    /// @param destinationChainId Destination chain
    /// @param disputeType Type of dispute
    /// @param role Claimant's role in the dispute
    function claimSlashShare(
        address l1XlpAddress,
        uint256 originationChainId,
        uint256 destinationChainId,
        DisputeType disputeType,
        SlashShareRole role
    ) external;

    /// @notice Claim slashed stake for single-beneficiary disputes
    /// @dev Used for VOUCHER_OVERRIDE and UNSPENT_VOUCHER_FEE_CLAIM
    /// @param l1XlpAddress Slashed XLP's L1 address
    /// @param originationChainId Origin chain
    /// @param destinationChainId Destination chain
    /// @param disputeType Type of dispute
    function claimSlashSingle(
        address l1XlpAddress,
        uint256 originationChainId,
        uint256 destinationChainId,
        DisputeType disputeType
    ) external;
}
```

##### Staking Events

```solidity
/// @notice Emitted when XLP locks stake for chains
event StakeLocked(
    address indexed xlp,
    uint256[] chainIds,
    uint256 stake
);

/// @notice Emitted when stake unlock is initiated
event StakeUnlocked(
    address indexed account,
    uint256[] chainIds,
    uint256 withdrawTime
);

/// @notice Emitted when stake is withdrawn
event StakeWithdrawn(
    address indexed account,
    uint256[] chainIds,
    address withdrawAddress,
    uint256 amount
);

/// @notice Emitted when chain info is added for XLP
event ChainInfoAdded(
    address indexed l1Xlp,
    address indexed l2Xlp,
    uint256 chainId,
    address paymaster,
    address l1Connector,
    address l2Connector
);

/// @notice Emitted when message is sent to L2
event MessageSentToL2(
    address indexed to,
    string functionName,
    bytes data,
    uint256 gasLimit
);
```

##### Dispute Events

```solidity
/// @notice Emitted when stake slash is scheduled
event StakeSlashScheduled(
    address indexed l1XlpAddress,
    uint256 originationChainId,
    uint256 destinationChainId,
    DisputeType disputeType,
    bytes32 requestIdsHash,
    uint256 amount,
    uint256 claimableAt
);

/// @notice Emitted when slash is recorded
event SlashRecorded(
    address indexed l1XlpAddress,
    bytes32 indexed id,
    DisputeType disputeType,
    uint256 amount,
    address beneficiary,
    uint256 claimableAt
);

/// @notice Emitted when slashed stake is claimed
event SlashedStakeClaimed(
    address indexed l1XlpAddress,
    bytes32 indexed id,
    DisputeType disputeType,
    uint256 amount,
    address beneficiary
);

/// @notice Emitted when origin dispute is reported
event OriginDisputeReported(
    address indexed l1XlpAddress,
    bytes32 indexed requestIdsHash,
    uint256 originationChainId,
    uint256 destinationChainId,
    uint256 count,
    uint256 firstRequestedAt,
    uint256 lastRequestedAt,
    uint256 disputeTimestamp,
    address l1Beneficiary,
    address indexed l2XlpAddressToSlash,
    DisputeType disputeType,
    address l1Connector,
    address l2Connector,
    address paymaster
);

/// @notice Emitted when destination proof is reported
event DestinationProofReported(
    address indexed l1XlpAddress,
    bytes32 indexed requestIdsHash,
    uint256 originationChainId,
    uint256 destinationChainId,
    uint256 count,
    uint256 proofTimestamp,
    uint256 firstProveTimestamp,
    address l1Beneficiary,
    address indexed l2XlpAddressToSlash,
    DisputeType disputeType,
    address l1Connector,
    address l2Connector,
    address paymaster
);
```

##### Supporting Structs

```solidity
struct ChainInfo {
    address paymaster;      // CrossChainPaymaster address on this chain
    address l1Connector;    // L1 bridge connector for this chain
    address l2Connector;    // L2 bridge connector for this chain
    address l2XlpAddress;   // XLP's address on this L2
}

struct ChainInfoReturnStruct {
    uint256 chainId;
    address paymaster;
    address l1Connector;
    address l2Connector;
    address l2XlpAddress;
}

struct StakeInfo {
    uint256 stake;          // Current stake amount
    uint256 withdrawTime;   // Timestamp when withdrawal is available (0 if locked)
}

/// @notice Origin-side dispute report (L2 -> L1)
struct ReportDisputeLeg {
    bytes32 requestIdsHash;       // Hash of all request IDs in this report
    uint256 originationChainId;
    uint256 destinationChainId;
    uint256 count;                // Number of vouchers in the group
    uint256 firstRequestedAt;     // Earliest request timestamp
    uint256 lastRequestedAt;      // Latest request timestamp
    uint256 disputeTimestamp;     // When dispute was initiated
    address payable l1Beneficiary; // Receives origin winner share
    address l2XlpAddressToSlash;
    DisputeType disputeType;
}

/// @notice Destination-side proof report (L2 -> L1)
struct ReportProofLeg {
    bytes32 requestIdsHash;       // Must match origin leg
    uint256 originationChainId;
    uint256 destinationChainId;
    uint256 count;                // Number of vouchers in the group
    uint256 proofTimestamp;       // When proof was produced (for tie-break)
    uint256 firstProveTimestamp;  // Earliest proof timestamp (for pre/post window)
    address payable l1Beneficiary; // Receives destination winner share
    address l2XlpAddressToSlash;
    DisputeType disputeType;
}

/// @notice Roles for claiming slashed stake shares
enum SlashShareRole {
    PRE_ORIGIN,       // Origin reporter in pre-window
    PRE_DESTINATION,  // Destination prover in pre-window
    POST_ORIGIN,      // Origin reporter in post-window
    POST_DESTINATION, // Destination prover in post-window
    L1_PULL           // Entity that pulled messages to L1
}
```

##### Slashing Mechanics

**The Optimistic Security Guarantee**

The system relies on a **1-of-N** honest assumption:

- **The Threat:** An XLP issues a Voucher but is insolvent on the Destination Chain (the check bounces).
- **The Defense:** Any watcher (a rival XLP, user, or automated bot) can submit a fraud proof to the L1 Stake Manager.
- **The Penalty:** The malicious XLP is slashed on L1. The penalty is set higher than the potential griefing gain.
- **User Safety:** Even in this worst-case scenario, the user never loses funds. Their funds on Chain A simply unlock after the expiration time because the XLP cannot produce a valid proof of execution.

**Dispute Types**

Three types of misbehavior can trigger slashing:

1. **INSOLVENT_XLP:** The XLP issued a voucher but didn't have sufficient funds on the destination chain to honor it.
2. **VOUCHER_OVERRIDE:** An XLP falsely claimed to have provided liquidity when another XLP actually did.
3. **UNSPENT_VOUCHER_FEE_CLAIM:** An XLP claimed fees for a voucher that was never consumed.

**Longest-Array Algorithm (Insolvency Disputes)**

For insolvency disputes, multiple watchers may report the same misbehavior. To incentivize comprehensive reporting and prevent racing, the slashing system uses a **longest-array algorithm**:

1. **Pre/Post Windows:** Disputes are classified based on whether the origin dispute was submitted before or after the destination proof
2. **Longest Array Wins:** The reporter with the most request IDs in their report wins the share for their role
3. **Tie-Breaking:** On equal counts, the earliest destination proof timestamp wins
4. **Five Roles:** Pre-origin, pre-destination, post-origin, post-destination, and L1-pull
5. **Distribution:** 90% of slashed stake is distributed; the split depends on which windows have winners

For non-insolvency disputes (VOUCHER_OVERRIDE, UNSPENT_VOUCHER_FEE_CLAIM), a single beneficiary receives the slashed funds.

### Fee Mechanism

This section specifies the economic model for XLP compensation, including the reverse Dutch auction, cost accounting, and MEV considerations.

#### Reverse Dutch Auction

To ensure users receive the best price without latency, the protocol utilizes a fee discovery mechanism based on a **reverse Dutch auction**.

**How It Works:**

1. **Start Fee:** The user sets a starting fee percentage, ideally close to the current market rate
2. **Ramping:** The fee increases over time according to the `feeIncreasePerSecond` parameter
3. **Competition:** Multiple XLPs monitor for requests; the first to issue a voucher locks in the current fee
4. **Cap:** The fee never exceeds `maxFeePercentNumerator`

**Fee Calculation:**

```solidity
function calculateFee(
    AtomicSwapFeeRule memory feeRule,
    uint256 requestCreatedAt,
    uint256 currentTime,
    uint256 assetAmount
) internal pure returns (uint256 fee) {
    uint256 elapsed = currentTime - requestCreatedAt;
    uint256 currentFeePercent = feeRule.startFeePercentNumerator +
        (feeRule.feeIncreasePerSecond * elapsed);

    if (currentFeePercent > feeRule.maxFeePercentNumerator) {
        currentFeePercent = feeRule.maxFeePercentNumerator;
    }

    // Fee denominator is 10000 (100% = 10000, 1% = 100, 0.01% = 1)
    fee = (assetAmount * currentFeePercent) / 10000;
}
```

**Example Timeline:**

```
Time    Fee%    Behavior
─────────────────────────────────────────────────────
t+0s    0.10%   Request created. Aggressive XLPs may fulfill immediately
t+10s   0.15%   Fee increases. More XLPs become profitable
t+30s   0.25%   Typical fulfillment window for liquid pairs
t+60s   0.40%   Higher fee attracts slower/smaller XLPs
t+120s  0.50%   Max fee reached (capped)
t+300s  ----    Request expires if unfulfilled
```

#### XLP Rationality Condition

A rational XLP will issue a voucher if and only if their expected profit exceeds zero:

```
Expected Profit = F(t) - C_gas - C_capital - C_risk > 0
```

**Cost Components:**

| Cost | Description | Typical Range |
|------|-------------|---------------|
| `C_gas` | Gas on source (claim) + destination (UserOp validation) | $0.01 - $1.00 |
| `C_capital` | Opportunity cost of locked liquidity | ~5-15% APY prorated |
| `C_risk` | Expected loss from disputes, reorgs, failed txns | ~0.01% of volume |
| `C_inventory` | Cost of rebalancing across chains | Variable |

**Gas Cost Accounting:**

The XLP incurs gas costs on multiple chains:

```solidity
struct GasCosts {
    // Destination chain (paid by XLP during UserOp validation)
    uint256 destValidationGas;     // ~50,000 gas for voucher verification
    uint256 destExecutionGas;      // Variable based on user's callData

    // Source chain (paid by XLP when claiming)
    uint256 sourceClaimGas;        // ~80,000 gas for withdrawFromUserDeposit
    uint256 sourceOverrideGas;     // ~100,000 gas if override needed
}
```

XLPs SHOULD monitor gas prices on all supported chains and factor current prices into their voucher issuance decisions.

**Capital Cost Accounting:**

The XLP's capital is locked from voucher issuance until source chain claim:

```
Lock Duration = T_source_claim - T_voucher_issued
             ≈ T_dest_execution + T_source_finality + T_claim_delay
             ≈ 2 seconds + 15 minutes + variable
             ≈ 15-30 minutes typical
```

For a 10% APY opportunity cost:
```
C_capital = Principal × 0.10 × (LockDuration / 365 days)
         = $10,000 × 0.10 × (30 min / 525,600 min)
         = $0.057 per $10,000 for 30 minutes
```

Capital costs are typically negligible for small transactions but become significant for large volumes.

#### Unspent Voucher Fee

If an XLP issues a voucher but the user never consumes it (e.g., user's destination transaction fails), the XLP can claim the `unspentVoucherFee`:

```solidity
// In AtomicSwapFeeRule
uint256 unspentVoucherFee;  // Flat fee in basis points
```

This compensates XLPs for:
- Gas spent issuing the voucher on-chain
- Opportunity cost of reserving liquidity
- Risk of the user griefing by requesting vouchers they never use

**Anti-Griefing Properties:**

The unspent voucher fee creates a cost for users who request vouchers without intent to use them:

```
User Cost of Griefing = unspentVoucherFee × requestedAmount
XLP Cost of Being Griefed = C_gas(issue) + C_capital(reservation)
```

For the system to be griefing-resistant: `unspentVoucherFee ≥ XLP Cost of Being Griefed`

#### MEV Dynamics

Voucher requests create MEV (Maximal Extractable Value) opportunities that sophisticated actors can capture:

**XLP-Bundler Integration:**

An XLP that also operates a Bundler (or partners with one) can:

1. Observe user's `lockUserDeposit` transaction in mempool
2. Issue voucher
3. Bundle user's destination UserOp with voucher in same block
4. Achieve "1-block cross-chain swap"

```
Block N (Source Chain)          Block M (Dest Chain, ~same time)
┌─────────────────────────┐     ┌─────────────────────────────┐
│ 1. User lockUserDeposit │     │ 1. User's UserOp            │
│ 2. XLP issueVouchers    │     │    (with voucher attached)  │
│                         │     │ 2. Voucher validated        │
│                         │     │ 3. User execution           │
└─────────────────────────┘     └─────────────────────────────┘
         │                                    │
         └──────────── Same real-world ───────┘
                       time window
```

**Sandwich Attack Resistance:**

Unlike AMM swaps, WeissChannel transactions are resistant to sandwich attacks:

1. **No Price Impact:** The user specifies exact amounts, not a swap through a liquidity pool
2. **Private Execution:** The user's destination callData is only revealed when executed
3. **XLP Commitment:** The XLP commits to exact terms before seeing execution

However, the user's *intent* (e.g., wanting to buy a specific NFT) may be inferred from the destination chain and amount, enabling front-running of the underlying action.

**Priority Gas Auctions (PGA):**

Multiple XLPs competing for the same request may engage in PGA:

```
XLP_A sees request, bids gas price G
XLP_B sees XLP_A's bid, bids G + δ
XLP_A responds with G + 2δ
...continues until one XLP's profit margin is exhausted
```

This competition benefits users (faster fulfillment) but erodes XLP margins. Sophisticated XLPs use private mempools or Flashbots-style infrastructure to avoid PGA.

#### Fee Parameter Recommendations

**For Users (Wallet Implementations):**

| Parameter | Conservative | Balanced | Aggressive |
|-----------|-------------|----------|------------|
| `startFeePercentNumerator` | 50 (0.5%) | 20 (0.2%) | 5 (0.05%) |
| `feeIncreasePerSecond` | 1 | 2 | 5 |
| `maxFeePercentNumerator` | 100 (1%) | 75 (0.75%) | 50 (0.5%) |
| `expiresAt` | +10 min | +5 min | +2 min |

- **Conservative:** Higher starting fee, filled quickly, pays premium
- **Balanced:** Market rate start, typical fill in 10-30 seconds
- **Aggressive:** Low start, may wait or fail, best price if filled

**For XLPs:**

XLPs SHOULD implement dynamic fee thresholds based on:

1. Current gas prices on source and destination chains
2. Available liquidity in their pools
3. Inventory balance (prefer routes that rebalance)
4. Historical dispute rates for the user/route
5. Current utilization of their capital

### Account Validation Module

Smart Accounts supporting WeissChannels MUST implement Merkle proof verification in their validation logic. This section specifies how accounts validate multichain UserOps.

#### Motivation: Hardware Wallet Compatibility

The primary driver for the Merkle-based approach is hardware wallet compatibility. Devices like Ledger or Trezor generally do not support functionality for simultaneously generating N distinct signatures for different chains in a single user flow. By aggregating operations into a single Merkle root, the user performs one trusted signature on the device, which authorizes the entire cross-chain bundle.

#### Signature Encoding

The `userOp.signature` field MUST be encoded as follows for WeissChannel operations:

```solidity
userOp.signature = abi.encode(
    bytes32 merkleRoot,      // Root of the Multichain UserOp tree
    bytes32[] merkleProof,   // Sibling path proving this operation is in the tree
    bytes rootSignature      // User's signature over the Merkle root
);
```

#### Validation Logic

Smart Accounts MUST implement the following validation logic in their `validateUserOp` function:

```solidity
function validateUserOp(
    PackedUserOperation calldata userOp,
    bytes32 userOpHash,
    uint256 missingAccountFunds
) external returns (uint256 validationData) {
    // 1. Decode the signature components
    (bytes32 merkleRoot, bytes32[] memory proof, bytes memory rootSig) =
        abi.decode(userOp.signature, (bytes32, bytes32[], bytes));

    // 2. Reconstruct the leaf for this chain's operation
    bytes32 leaf = keccak256(abi.encode(
        userOp.sender,
        userOp.nonce,
        userOp.callData,
        unpackCallGasLimit(userOp.accountGasLimits),
        block.chainid
    ));

    // 3. Verify the Merkle proof
    require(
        MerkleProof.verify(proof, merkleRoot, leaf),
        "Invalid Merkle proof"
    );

    // 4. Verify signature over Merkle root
    require(
        _validateSignature(merkleRoot, rootSig),
        "Invalid signature"
    );

    // 5. Continue with standard validation...
    return _packValidationData(false, 0, 0);
}
```

#### Merkle Proof Verification

The Merkle proof verification MUST use the standard binary Merkle tree algorithm:

```solidity
library MerkleProof {
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }

        return computedHash == root;
    }
}
```

> **Note:** OpenZeppelin's `MerkleProof` library provides a well-audited implementation.

#### Heterogeneous Account Support

Because the validation logic is standardized around Merkle proof verification, the underlying signature scheme can vary. A user might use:

- **ECDSA (secp256k1):** Traditional Ethereum signatures
- **Passkeys (WebAuthn/P-256):** Browser-native authentication on chains like Base
- **BLS signatures:** For aggregation-friendly schemes
- **Multisig:** Multiple signers authorizing the same root

The account's `_validateSignature` function handles the scheme-specific verification:

```solidity
function _validateSignature(
    bytes32 merkleRoot,
    bytes memory signature
) internal view returns (bool) {
    // ECDSA example:
    bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(merkleRoot);
    address recovered = ECDSA.recover(ethSignedHash, signature);
    return recovered == owner;

    // Or for WebAuthn, BLS, multisig, etc.
}
```

This enables a unified cross-chain identity even when different chains support different signature schemes.

#### Nonce Management

Each chain maintains its own nonce for the user's account. The Merkle tree includes the chain-specific nonce in each leaf:

```
Leaf_i = hash(sender, nonce_i, callData_i, gasLimit_i, chainId_i)
```

**Key properties:**

1. **Per-Chain Nonces:** The nonce in each leaf is the account's nonce on that specific chain, not a global nonce.

2. **Independent Execution:** Operations on different chains can execute in any order. Chain A's operation doesn't block Chain B's operation.

3. **Replay Protection:** The nonce prevents replay of the same operation on the same chain. The chainId prevents replay across chains.

4. **Partial Execution:** If some operations fail (e.g., insufficient gas, reverted calls), others can still succeed. The atomicity is at the voucher level, not the Merkle tree level.

#### Replay Attack Prevention

The protocol prevents several classes of replay attacks:

**1. Same-Chain Replay**

Prevented by the account nonce. Once an operation with nonce N executes on chain C, it cannot execute again.

**2. Cross-Chain Replay**

Prevented by including `chainId` in the leaf hash. An operation for Chain A cannot be replayed on Chain B because the leaf verification will fail.

**3. Expired Voucher Replay**

Prevented by the `expiresAt` field in vouchers. Even if an attacker obtains an old voucher, it cannot be used after expiration.

**4. Merkle Root Replay**

Prevented by the combination of per-chain nonces. Once any leaf in the tree executes on its target chain, that specific (nonce, chainId) combination is consumed.

**5. Reorg Attack Prevention**

If the source chain reorgs after the user commits funds but before the XLP claims:

- The XLP holds a valid UserOp signed by the user with a specific nonce
- The XLP can resubmit the user's original UserOp to the new chain tip
- The user cannot "double spend" unless they execute a different transaction with the same nonce faster than the XLP

This creates a race condition usually won by the XLP who is monitoring the mempool.

#### Validation Module Pattern

For accounts using the ERC-6900 modular account standard, WeissChannel support can be implemented as a validation module:

```solidity
interface IWeissValidationModule {
    /// @notice Validate a multichain UserOp using Merkle proof
    /// @param userOp The packed user operation
    /// @param userOpHash The hash of the user operation
    /// @return validationData Packed validation result
    function validateUserOp(
        PackedUserOperation calldata userOp,
        bytes32 userOpHash
    ) external returns (uint256 validationData);

    /// @notice Check if this module supports the given signature format
    /// @param signature The signature to check
    /// @return True if this is a WeissChannel Merkle signature
    function isWeissSignature(bytes calldata signature) external pure returns (bool);
}
```

This allows existing accounts to add WeissChannel support without modifying their core validation logic.

### Protocol Flow Specification

This section provides detailed timing requirements, failure handling, and ordering guarantees for WeissChannel operations.

#### Timing Parameters

The protocol requires careful coordination of timing parameters to ensure safety while maximizing UX:

| Parameter | Location | Value | Rationale |
|-----------|----------|-------|-----------|
| `expiresAt` (request) | DestinationSwapComponent | ~5-30 minutes | Short enough to prevent capital lockup; long enough for XLP response |
| `expiresAt` (voucher) | AtomicSwapVoucher | ≤ request expiration | XLP's commitment window; typically matches request |
| `unstakeDelay` | L1StakeManager | 8 days | > maximum L2 finality (7 days for Optimistic Rollups) |
| `claimDelay` | L1StakeManager | 1 hour | Window for additional dispute evidence |
| `destBeforeOriginMinGap` | L1StakeManager | 1 hour | Ensures destination proof precedes origin dispute |
| Anti-rugpull lock | CrossChainPaymaster | ~1 hour | Window to detect reorg attacks before XLP claims |

#### State Machine

Each voucher request transitions through the following states:

```
                                    ┌──────────────┐
                                    │              │
              ┌─────────────────────►   CANCELLED  │
              │                     │              │
              │ cancelVoucherRequest└──────────────┘
              │
         ┌────┴────┐   issueVouchers   ┌─────────────────┐
         │         ├──────────────────►│                 │
  ──────►│   NEW   │                   │ VOUCHER_ISSUED  │
         │         │◄──────────────────┤                 │
         └─────────┘   (expiration)    └────────┬────────┘
                                                │
                    ┌───────────────────────────┼───────────────────────────┐
                    │                           │                           │
                    ▼                           ▼                           ▼
           ┌────────────────┐         ┌─────────────────┐         ┌─────────────────┐
           │                │         │                 │         │                 │
           │    DISPUTE     │         │   SUCCESSFUL    │         │    UNSPENT      │
           │                │         │                 │         │                 │
           └───────┬────────┘         └─────────────────┘         └─────────────────┘
                   │
                   ▼
           ┌────────────────┐
           │                │
           │   PENALIZED    │
           │                │
           └────────────────┘
```

**State Transitions:**

| From | To | Trigger | Condition |
|------|----|---------|-----------|
| - | NEW | `lockUserDeposit()` | User locks funds |
| NEW | VOUCHER_ISSUED | `issueVouchers()` | XLP provides valid voucher |
| NEW | CANCELLED | `cancelVoucherRequest()` | Request expired, no voucher consumed |
| VOUCHER_ISSUED | SUCCESSFUL | `withdrawFromUserDeposit()` | Voucher was consumed on destination |
| VOUCHER_ISSUED | UNSPENT | `claimUnspentVoucherFee()` | Voucher expired unconsumed |
| VOUCHER_ISSUED | DISPUTE | `disputeInsolventXlp()` | XLP failed to honor voucher |
| DISPUTE | PENALIZED | L1 slash confirmed | Fraud proof validated |

#### Multi-Leg Transactions

WeissChannels support transactions spanning more than two chains. A user can:

1. **Sequential Legs:** Chain A → Chain B → Chain C
2. **Fan-Out:** Chain A → (Chain B, Chain C, Chain D) simultaneously
3. **Round-Trip:** Chain A → Chain B → Chain A (completion call)

**Example: Three-Chain Sequential**

```
Alice wants to:
1. Lock USDC on Arbitrum (Chain A)
2. Receive ETH on Optimism (Chain B), swap for USDT
3. Bridge USDT to Base (Chain C) for final use

Merkle Tree:
        Root (signed by Alice)
       /    \
    Leaf_A   Node
            /    \
        Leaf_B  Leaf_C

- Leaf_A: Lock 1000 USDC on Arbitrum, request voucher for 0.5 ETH on Optimism
- Leaf_B: Receive ETH, swap to USDT, request voucher for USDT on Base
- Leaf_C: Receive USDT on Base, execute final action
```

Each leg operates independently but is authorized by the same signature.

#### Completion Calls (Round-Trip Workflows)

A **completion call** is an operation that returns to the origin chain after executing on one or more destination chains. This enables sophisticated DeFi workflows:

**Use Cases:**

1. **Yield Farming:** Bridge to high-yield chain, deposit, receive receipt token, bridge receipt back
2. **Arbitrage:** Buy asset on Chain B, sell on Chain A in same atomic bundle
3. **Cross-Chain Aggregation:** Collect assets from multiple chains into one destination

**Implementation:**

The completion call is simply another leaf in the Merkle tree targeting the original chain:

```solidity
// Leaf for completion call back to Chain A
ChainUserOp completionOp = ChainUserOp({
    sender: aliceAccount,
    nonce: aliceNonceOnChainA + 1,  // Next nonce after initial lock
    callData: abi.encodeCall(processReturnedAssets, (returnData)),
    callGasLimit: 200000,
    chainId: CHAIN_A_ID
});
```

**Ordering Guarantee:**

The protocol does NOT enforce ordering between legs. If Leaf_B depends on Leaf_A completing first, the dependency must be encoded in the smart contract logic (e.g., checking that funds arrived before proceeding).

#### Partial Failure Handling

When a multi-leg transaction partially fails, the protocol handles each leg independently:

**Scenario: A → B → C where B succeeds but C fails**

| Component | Outcome |
|-----------|---------|
| Chain A funds | Claimed by XLP (B's voucher was consumed) |
| Chain B execution | Completed successfully |
| Chain B → C voucher | Never consumed (expires) |
| Chain C execution | Never occurs |
| XLP for B→C leg | Can claim unspent voucher fee |
| User | Has assets on Chain B, nothing on Chain C |

**User Protection:**

- Users are never worse off than their starting position
- If a voucher isn't consumed, funds remain locked until expiration, then unlock
- The Merkle signature doesn't force execution—it only authorizes it

**XLP Protection:**

- XLPs only commit capital when they observe a lock
- If destination execution fails, XLP can still claim origin funds (they honored their voucher)
- Unspent voucher fees compensate for vouchers that were issued but never used

#### Causal Ordering

The protocol provides **eventual consistency** but not strict causal ordering across chains. This has important implications:

**What IS guaranteed:**

1. A voucher can only be consumed if it references a valid, unexpired request
2. An XLP can only claim origin funds if they provided a valid voucher that was consumed
3. Disputes can only be raised within the validity window

**What is NOT guaranteed:**

1. Execution order across chains
2. Atomic all-or-nothing execution of multi-leg transactions
3. That dependent operations will see each other's state changes

**Handling Dependencies:**

For operations with causal dependencies, implementations SHOULD use one of:

1. **Pessimistic Verification:** The receiving contract checks that prerequisite state exists before proceeding
2. **Optimistic Execution:** Execute assuming prerequisites are met; revert or handle gracefully if not
3. **Explicit Sequencing:** Use separate Merkle trees for each leg, only signing the next after observing the previous complete

#### Atomicity Boundaries

The atomicity guarantee applies at the **voucher level**, not the Merkle tree level:

```
Atomicity Boundary
┌─────────────────────────────────────────────────────┐
│  Source Chain              │  Destination Chain    │
│                            │                       │
│  User locks funds ────────►│◄──── XLP issues       │
│                            │      voucher          │
│                            │                       │
│  XLP claims funds ◄────────│───── User consumes    │
│  (if voucher consumed)     │      voucher          │
│                            │                       │
│  OR                        │      OR               │
│                            │                       │
│  User reclaims funds ◄─────│───── Voucher expires  │
│  (if voucher expired)      │      (not consumed)   │
└─────────────────────────────────────────────────────┘
```

Within this boundary:
- Either the swap completes (user gets destination assets, XLP gets origin assets)
- Or the swap fails (user keeps origin assets, XLP keeps destination assets)

There is no state where both parties lose or where assets are stuck indefinitely.

#### Timeout Handling

**Request Expiration:**

If no voucher is consumed before `request.destination.expiresAt`:

1. User calls `cancelVoucherRequest()`
2. Origin funds are returned to user
3. Request status → CANCELLED

**Voucher Expiration:**

If a voucher is issued but not consumed before `voucher.expiresAt`:

1. XLP calls `claimUnspentVoucherFee()` to claim the unspent fee
2. After dispute window, XLP calls `withdrawUnspentVoucherFee()`
3. Remaining user funds (minus fee) can be reclaimed by user
4. Request status → UNSPENT

**Unstake During Active Vouchers:**

If an XLP initiates unstaking while they have outstanding vouchers:

1. XLP is immediately removed from active registry (cannot issue new vouchers)
2. Existing vouchers remain valid until their expiration
3. Stake remains locked for full `unstakeDelay` (8 days)
4. Any disputes during this window can still slash the stake

### Security Considerations

This section analyzes the security properties of WeissChannels, including threat models, attack vectors, and mitigations.

#### Trust Model: 1-of-N Honesty

WeissChannels operate under an **optimistic security model** with a 1-of-N honest assumption:

> The system is secure as long as at least ONE honest actor is online and willing to submit a fraud proof.

This is strictly weaker than:
- **N-of-N (Unanimous):** All parties must be honest (e.g., multisig bridges)
- **M-of-N (Threshold):** A majority/supermajority must be honest (e.g., PoS consensus)
- **Trusted Third Party:** A single designated entity must be honest

**Who Can Be the "1":**
- The user themselves
- A rival XLP (economically incentivized to catch cheaters)
- A public watcher service
- Any Ethereum user with the fraud proof data

**Implications:**
- Users who monitor their own transactions have sovereign security
- Even passive users benefit from the existence of watchers
- The cost of running a watcher is low (just monitoring events)

#### Fraud Proof Completeness

For the 1-of-N model to hold, fraud proofs must be **complete**—any misbehavior must be provable.

**Provable Misbehaviors:**

| Misbehavior | Proof | Mechanism |
|-------------|-------|-----------|
| XLP issues voucher but is insolvent | Voucher signature + destination chain state showing no payment | `disputeInsolventXlp()` |
| XLP claims override fraudulently | Both vouchers + destination execution proof showing original XLP paid | `disputeVoucherOverride()` |
| XLP claims unspent fee for consumed voucher | Voucher + destination execution proof | `disputeXlpUnspentVoucherClaim()` |

**Proof Structure:**

Each dispute requires evidence from both the origin and destination chains, matched on L1:

```
Origin Chain Evidence (ReportDisputeLeg):
├── requestIdsHash (identifies the disputed requests)
├── count (number of requests in batch)
├── firstRequestedAt / lastRequestedAt (timing bounds)
├── disputeTimestamp (when dispute was raised)
└── l1Beneficiary (who receives slashed funds)

Destination Chain Evidence (ReportProofLeg):
├── requestIdsHash (must match origin)
├── count (must match origin)
├── proofTimestamp (when proof was produced)
├── firstProveTimestamp (for pre/post window classification)
└── l1Beneficiary (who receives slashed funds)
```

L1 matches these legs by `requestIdsHash` and processes the slash atomically.

#### Replay Attack Prevention

**Attack Vector 1: Same-Chain Replay**

*Threat:* Attacker replays a user's signed operation on the same chain.

*Mitigation:* Each operation includes the account's nonce. Once executed, the nonce increments, invalidating the replay.

**Attack Vector 2: Cross-Chain Replay**

*Threat:* Attacker takes an operation signed for Chain A and submits it on Chain B.

*Mitigation:* Each Merkle leaf includes `chainId`. The leaf hash verification fails if `block.chainid` doesn't match.

**Attack Vector 3: Voucher Replay**

*Threat:* Attacker replays an old voucher to extract funds.

*Mitigation:*
- Vouchers reference a specific `requestId` (hash of the full request including nonce)
- Vouchers have `expiresAt` timestamps
- Consumed vouchers are marked in contract state

**Attack Vector 4: Request Replay**

*Threat:* Attacker replays a user's voucher request to lock their funds again.

*Mitigation:* The `senderNonce` in `SourceSwapComponent` prevents replay. Each request consumes a nonce.

#### Double-Spend Prevention

**Scenario: XLP Double-Spend During Unstake**

*Threat:* An XLP initiates unstake, waits until just before withdrawal, issues vouchers they don't intend to honor, then withdraws stake before disputes resolve.

*Mitigation:*
1. **Immediate Unregistration:** When `unlockStake()` is called, the XLP is immediately removed from the active registry. They cannot issue new vouchers.
2. **8-Day Unstake Delay:** The `unstakeDelay` (8 days) exceeds maximum L2 finality (7 days). Any fraud during the XLP's active period can still be proven and slashed.
3. **Stake Remains Slashable:** Even after initiating unstake, the stake can be slashed until actually withdrawn.

```
Timeline:
Day 0: XLP calls unlockStake() → Immediately unregistered
Day 0-7: Outstanding vouchers can still be disputed
Day 7: L2 finality reached for all pending transactions
Day 8: XLP can call withdrawStake() (if not slashed)
```

**Scenario: User Double-Spend via Reorg**

*Threat:* User's lock transaction is included in Block N. Before the XLP claims, the source chain reorgs and the user spends their funds differently in the new Block N'.

*Mitigation:*
1. **Anti-Rugpull Lock:** Claimed funds remain locked briefly before being credited to XLP
2. **XLP Can Resubmit:** If the XLP holds the user's signed UserOp, they can resubmit to the new chain tip
3. **Nonce Consumption:** If the user already used that nonce in the reorg, the XLP's submission fails but the user has effectively paid (their funds went elsewhere with that nonce)

The race condition favors the XLP who is actively monitoring.

#### Source Chain Reorg Safety

**Deep Reorg Scenario:**

If the source chain experiences a deep reorganization after the user has locked funds:

| Depth | Likelihood | Impact | Mitigation |
|-------|------------|--------|------------|
| 1-2 blocks | Common | XLP resubmits user's tx | XLP monitors and reacts |
| 3-12 blocks | Rare | XLP may lose if slow | Anti-rugpull lock period |
| 13+ blocks | Extremely rare | Potential loss | Finality assumptions; XLP accepts risk |

**XLP Risk Management:**

XLPs SHOULD:
- Wait for sufficient confirmations before issuing vouchers for large amounts
- Set lower `expiresAt` on vouchers for chains with uncertain finality
- Price reorg risk into their fee calculations

#### Griefing Economics

**User Griefing XLP:**

*Attack:* User creates many requests, gets vouchers issued, never consumes them.

*Cost to User:* `unspentVoucherFee × amount × numberOfRequests`
*Cost to XLP:* Gas for `issueVouchers()` + capital lockup

*Equilibrium:* If `unspentVoucherFee` is set appropriately, griefing is unprofitable.

**XLP Griefing User:**

*Attack:* XLP issues voucher but doesn't have destination liquidity.

*Cost to XLP:* Full stake slashed
*Cost to User:* Time delay (funds locked until expiration)

*Equilibrium:* Stake >> potential griefing utility makes this irrational.

**Concrete Calculation:**

```
Assume:
- Minimum stake per chain: 10 ETH (~$30,000)
- Maximum griefing utility: Delay user's $1M for 5 minutes
- User's opportunity cost: 10% APY = $1M × 0.10 × (5/525600) = $0.95

Griefing Ratio = Stake / Griefing Utility = $30,000 / $0.95 = 31,579x

The XLP would lose 31,579x more than they could possibly hurt the user.
```

#### XLP Insolvency Handling

**Scenario: XLP Becomes Insolvent Mid-Operation**

An XLP might become insolvent (destination liquidity depleted) due to:
- Multiple simultaneous voucher requests exceeding their reserves
- Price movements making their reserves insufficient
- Technical failure preventing destination funding

**Protocol Response:**

1. **Voucher Not Consumed:** User's funds remain locked until expiration, then unlock
2. **Dispute Window:** Anyone can call `disputeInsolventXlp()` with proof
3. **Slashing:** XLP's L1 stake is slashed
4. **Alternative Vouchers:** During dispute, other XLPs can issue `ALT` vouchers to rescue the user

**User Protection:**

Users never lose funds due to XLP insolvency. Worst case:
- Their funds are locked for the expiration period
- They can cancel after expiration and recover everything
- If another XLP issues an ALT voucher, they can complete their transaction

#### Cross-Chain Message Integrity

**Bridge Trust Assumptions:**

The protocol relies on L1 ↔ L2 messaging for:
- XLP registration (`onL1XlpChainInfoAdded`)
- XLP unregistration (`onL1XlpStakeUnlocked`)
- Dispute evidence (`reportOriginDispute`, `reportDestinationProof`)
- Slash notifications (`onXlpSlashedMessage`)

These messages use the **canonical rollup bridges** (e.g., Arbitrum's Outbox, Optimism's CrossDomainMessenger), which inherit the rollup's security:

- **Optimistic Rollups:** Messages are finalized after the challenge period (7 days)
- **ZK Rollups:** Messages are finalized after proof verification (~minutes to hours)

**Security Inheritance:**

```
WeissChannel Security ≤ min(L1 Security, Weakest Supported L2 Security)
```

The protocol cannot be more secure than the least secure bridge it uses.

#### Timing Attacks

**Attack: Manipulate Block Timestamps**

*Threat:* Miner/sequencer manipulates timestamps to:
- Expire vouchers prematurely
- Extend voucher validity
- Affect fee calculations

*Mitigation:*
- Timestamps only need ~minute accuracy
- `expiresAt` windows are typically 5-30 minutes (much larger than manipulation range)
- Fee ramp calculations are approximate; small manipulation has minimal impact

**Attack: Delay Dispute Submission**

*Threat:* Censorship of dispute transactions to prevent fraud proofs.

*Mitigation:*
- Multiple chains can submit evidence (origin OR destination can initiate)
- L1 itself is censorship-resistant
- Dispute windows (claimDelay) provide buffer time
- Users can use Flashbots/private channels to avoid mempool censorship

#### Known Limitations

1. **Not Atomic Across Chains:** Multi-leg transactions may partially succeed. Users must handle this at the application layer.

2. **Finality Assumptions:** The protocol assumes L2 transactions will finalize. If an L2 experiences a catastrophic failure (e.g., data unavailability), funds may be stuck.

3. **Bridge Dependency:** Security is bounded by the canonical bridges. Compromised bridges could allow fake dispute evidence.

4. **Capital Efficiency vs. Security Tradeoff:** Higher stakes mean more security but lower capital efficiency for XLPs. Deployments must tune this balance.

5. **Heterogeneous Finality:** Different L2s have different finality times. The `unstakeDelay` must exceed the maximum, making it suboptimal for faster L2s.

## Rationale

This section explains key design decisions and their alternatives.

### Why Merkle Trees Over Multiple Signatures?

**Decision:** Users sign a single Merkle root rather than N separate signatures for N chains.

**Alternatives Considered:**
1. **N Signatures:** User signs each chain's operation separately
2. **BLS Aggregation:** Aggregate N signatures into one
3. **Threshold Signatures:** M-of-N signers authorize all operations

**Rationale:**

| Approach | Hardware Wallet | Gas Cost | Complexity |
|----------|-----------------|----------|------------|
| Merkle Root | ✅ Single sign | O(log N) proof | Low |
| N Signatures | ❌ N sign flows | O(N) verification | Low |
| BLS Aggregation | ❌ Not supported | O(1) verification | High (pairing) |
| Threshold | ❌ Requires setup | O(1) verification | Very High |

Hardware wallet compatibility was the deciding factor. Users expect to confirm one action on their device for one logical operation, regardless of how many chains are involved.

### Why EIP-191 Over EIP-712 for Vouchers?

**Decision:** XLPs sign vouchers using EIP-191 personal sign format.

**Alternatives Considered:**
1. **EIP-712 Typed Data:** Structured, human-readable signing
2. **Raw Signing:** Sign hash directly without prefix

**Rationale:**

EIP-712 provides better UX in wallets that support it (showing structured data). However:
- XLP signing is typically automated (not shown to humans)
- EIP-191 has broader tooling support
- Simpler implementation reduces bug surface

Implementations MAY upgrade to EIP-712 in future versions for improved debuggability.

### Why Percentage-Based Fees Over Absolute?

**Decision:** Fees are specified as percentage numerators (10000 = 100%) rather than absolute token amounts.

**Rationale:**
- Scales naturally with transaction size
- Avoids repricing as token values fluctuate
- Simpler mental model: "0.2% fee" vs "$0.50 fee that may be too high or low"
- Consistent across different tokens and amounts

### Why 8-Day Unstake Delay?

**Decision:** XLPs must wait 8 days after initiating unstake before withdrawing.

**Alternatives Considered:**
- 7 days (match Optimistic Rollup finality)
- 14 days (extra safety margin)
- Variable per-chain

**Rationale:**

8 days provides a 1-day buffer beyond the 7-day Optimistic Rollup challenge period. This ensures:
- All pending L2 transactions reach finality
- Disputes can be submitted and processed
- Bridge messages can propagate to L1

A longer delay would improve security but harm XLP capital efficiency. 8 days strikes the balance.

### Why Not Enforce Multi-Leg Ordering?

**Decision:** The protocol does not enforce execution order across chains in multi-leg transactions.

**Rationale:**
- Cross-chain ordering requires trusted sequencers or complex coordination
- Application-level ordering (checking state before proceeding) is more flexible
- Users who need strict ordering can use sequential Merkle trees
- Simpler protocol = smaller attack surface

### Why Longest-Array for Insolvency Disputes?

**Decision:** Slashing rewards use a "longest array wins" algorithm rather than first-come-first-served.

**Rationale:**
- Incentivizes comprehensive reporting (catching more fraud)
- Prevents racing that might cause reporters to submit incomplete evidence
- Multiple reporters can participate without all-or-nothing competition
- Tie-breaking by timestamp provides fairness for equal-quality reports

### Why Per-Chain Staking?

**Decision:** XLPs stake separately for each chain they support rather than a single global stake.

**Alternatives Considered:**
- Global stake covering all chains
- Stake proportional to volume
- No stake (reputation-based)

**Rationale:**
- **Isolation:** Compromise on one chain doesn't affect others
- **Flexibility:** XLPs can support subsets of chains
- **Pricing:** Different chains have different risk profiles
- **Slashing Precision:** Only the relevant chains' stakes are slashed

## Backwards Compatibility

### ERC-4337 Compatibility

WeissChannels are fully backwards compatible with ERC-4337:

1. **UserOp Format:** The protocol uses standard `PackedUserOperation` structure
2. **EntryPoint:** Compatible with EntryPoint v0.7 and above
3. **Paymaster Interface:** `CrossChainPaymaster` implements `IPaymaster`
4. **Signature Field:** The Merkle encoding in `userOp.signature` is transparent to the EntryPoint

**Migration Path:**

Existing ERC-4337 accounts can add WeissChannel support by:
1. Updating their validation logic to detect Merkle signatures
2. Installing a WeissChannel validation module (for modular accounts)
3. No changes needed to the EntryPoint or bundler infrastructure

## Reference Implementation

A reference implementation is available at:

- https://github.com/eth-infinitism/eil-contracts
- https://github.com/eth-infinitism/eil-sdk

The implementation includes:
- `CrossChainPaymaster.sol` - L2 paymaster with origin/destination swap management
- `L1AtomicSwapStakeManager.sol` - L1 stake and dispute resolution
- Bridge connectors for Arbitrum and Optimism
- Integration tests demonstrating cross-chain flows

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
