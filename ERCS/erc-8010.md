---
eip: 8010
title: Counterfactual Signature Verification
description: Enables ERC-1271 signature verification for accounts that intend to deploy via CREATE2 or EIP-7702 before the deployment occurs onchain
author: Jake Moxey (@jxom), howydev (@howydev), Tanishk Goyal (@legion2002), Ivo Georgiev (@Ivshti)
discussions-to: https://ethereum-magicians.org/t/new-erc-signature-verification-for-pre-delegated-accounts/25201
status: Draft
type: Standards Track
category: ERC
created: 2025-08-21
requires: 1271, 7702
---

# Counterfactual Signature Verification

## Abstract

This ERC defines a signature verification procedure as a successor to [ERC-6492](./eip-6492.md) that enables signature validation for accounts that intend to deploy via CREATE2 or [EIP-7702](./eip-7702.md) before onchain deployment occurs. The standard introduces a detectable signature wrapper containing the context needed to simulate the deployment and verify signatures through [ERC-1271](./eip-1271.md) in a single atomic operation.

## Motivation

[EIP-7702](./eip-7702.md) enables EOAs to set code in their account, but signatures are often generated before onchain delegation occurs. Current verification methods ([ERC-6492](./eip-6492.md), [ERC-1271](./eip-1271.md), etc) cannot verify these pre-delegation signatures against the intended delegate logic.

This proposal addresses this limitation by:

- Standardizing a verification signature format that embeds deployment intent
- Defining a verification procedure that simulates deployment atomically
- Maintaining compatibility with existing [ERC-1271](./eip-1271.md) infrastructure

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Signer Side (e.g. Wallets)

This ERC proposes that wallets can wrap signatures into a predelegate verification-compatible format that is constructed as follows:

```solidity
// For CREATE2 Accounts:
wrapped_signature = abi.encode(factory, init_data, signature) || MAGIC_CREATE2
MAGIC_CREATE2 = 0x6492649264926492649264926492649264926492649264926492649264926492

// For EIP-7702 Accounts:
wrapped_signature = abi.encode(authorization, init_data, signature) || MAGIC_7702
MAGIC_7702 = 0x7702770277027702770277027702770277027702770277027702770277027702
authorization = abi.encode(chain_id, address, nonce, y_parity, r, s)
```

- `signature`: The signature to be verified by the delegate's `isValidSignature` method
- `MAGIC_CREATE2`: Detection marker for CREATE2 accounts
- `MAGIC_7702`: Detection marker for EIP-7702 accounts
- `factory`: Address of the CREATE2 factory contract
- `authorization`: Signed EIP-7702 authorization
- `init_data`: Optional initialization data to be executed before validation

### Requirements

- Signers SHOULD NOT wrap signatures if the account has already been delegated.
- `init_data` MAY be empty if the account has no initialization data.

### Verifier Side (e.g. Apps, Libraries,)

#### Account Consumers

The verification procedure is performed by consumers of the account contract (e.g. applications, services, libraries, etc.).

Given inputs `(account: address, digest: bytes32, wrapped_signature: bytes)`, verifiers MUST implement the following procedure (pseudocode):

### Step 1: Detection and parsing

1. Check if `wrapped_signature` ends with `MAGIC_CREATE2` or `MAGIC_7702`
2. If `MAGIC_CREATE2` or `MAGIC_7702` is not found:
    1. MUST perform standard ERC-1271 verification: `account.isValidSignature(digest, signature)` 
        1. If success, return successfully.
        2. If failure, attempt `ecrecover` verification.
3. If `MAGIC_7702`:
    - `(authorization, init_data, signature) = abi.decode(wrapped_signature[0:wrapped_signature.length - 32 - 2], (bytes, bytes, bytes))`
    - `(chain_id, delegation, nonce, y_parity, r, s) = abi.decode(authorization, (uint256, address, uint256, uint8, bytes32, bytes32))`
4. If `MAGIC_CREATE2`:
    - `(factory, init_data, signature) = abi.decode(wrapped_signature[0:wrapped_signature.length - 32], (address, bytes, bytes))`
5. Continue to [Step 2](#step-2-check-if-already-delegated-or-deployed).

### Step 2: Check if already delegated or deployed

Check if the account is already delegated to the target `delegation`, or if it has been deployed via CREATE2.

1. If `MAGIC_CREATE2` AND `account.code.length > 0`:
    1. Perform standard [ERC-1271](./eip-1271.md) verification: `account.isValidSignature(digest, signature)` 
        1. If success, return successfully. 
        2. If failure, attempt `ecrecover` verification. 
2. If `MAGIC_7702` AND `account.code == bytes.concat(hex"ef0100", delegation)`:
    1. Perform ERC-1271 verification: `account.isValidSignature(digest, signature)` 
        1. If success, return successfully. 
        2. If failure, attempt `ecrecover` verification. 
3. Otherwise, continue to [Step 3](#step-3-simulate-deployment-and-verify).

### Step 3: Simulate deployment and verify

If the account is not deployed yet, we will simulate the deployment, and verify the signature.

1. If `MAGIC_CREATE2`:
    1. Perform a CREATE2 deployment: `factory.call(init_data)`
    2. Perform a call to `account.isValidSignature(digest, signature)`, and return the result. 
2. If `MAGIC_7702`:
    1. Perform a call to initialize the account: `account.call(init_data)`
    2. Perform a call to: `account.isValidSignature(digest, signature)`, and return the result. 

### Requirements

- Verifiers MUST follow the verification procedure as specified
- Verifiers MAY use a (pre)deployed multicall contract or a deployless multicall mechanism. 
- Verifiers MUST include an `authorizationList` parameter containing `authorization` (in the `wrapped_signature`) in the `eth_call` request when verifying EIP-7702 signatures. 

## Rationale

### Offchain Verification

This ERC is intended for offchain signature verification. Onchain contracts cannot apply a delegation in a transient or simulated manner.

### Atomic Simulation Context

The design executes initialization and validation (Step 3) atomically (via multicall) to ensure state changes from initialization are visible during validation. This mirrors the execution flow when a 7702 delegation transaction includes both authorization and subsequent calls.

## Backwards Compatibility

This ERC defines a wrapped signature format that remains backward compatible with existing ERC-1271 infrastructure by leaving the inner `signature` unaltered, rather than ABI-encoding it. The assumption is that most [ERC-1271](./eip-1271.md) `isValidSignature` implementations rely on a static length for the signature, and will therefore parse the inner `signature` correctly when reading up to the defined context. This method ensures maximum compatibility with existing infrastructure.

This standard does not require compatibility with ERC-6492 or other signature wrapping standards, as it addresses the specific requirements of EIP-7702 delegation.

## Test Cases

TBD

## Security Considerations

TBD

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
