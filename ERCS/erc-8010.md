---
eip: 8010
title: Counterfactual Signature Verification
description: Enables ERC-1271 signature verification for accounts that intend to deploy via CREATE2 or EIP-7702 before the deployment occurs onchain
author: Jake Moxey (@jxom), howydev (@howydev), Tanishk Goyal (@legion2002), Ivo Georgiev (@Ivshti)
discussions-to: https://ethereum-magicians.org/t/new-erc-signature-verification-for-pre-delegated-accounts/25201
status: Draft
type: Standards Track
category: ERC
created: 2025-08-21
requires: 1271, 7702
---

# Counterfactual Signature Verification

## Abstract

This ERC defines a signature verification procedure as a successor to [ERC-6492](./eip-6492.md) that enables signature validation for accounts that intend to deploy via CREATE2 or [EIP-7702](./eip-7702.md) before onchain deployment occurs. The standard introduces a detectable signature wrapper containing the context needed to simulate the deployment and verify signatures through [ERC-1271](./eip-1271.md) in a single atomic operation.

## Motivation

Smart contract wallets and account abstraction have created the need to verify signatures for accounts that haven't been deployed yet. This includes both [CREATE2](./eip-1014.md) accounts (which can be deployed at predictable addresses) and [EIP-7702](./eip-7702.md) accounts (where EOAs can set code). In both cases, signatures are often generated before the actual deployment or delegation occurs onchain.

[ERC-6492](./eip-6492.md) successfully addressed this for CREATE2 accounts, however, with the introduction of [EIP-7702](./eip-7702.md), new challenges arise:
- Current verification methods cannot verify signatures of pre-delegated accounts
- Having multiple ERCs ([ERC-6492](./eip-6492.md) for CREATE2, and potentially a new one for 7702) creates ambiguity around verification procedures
- Developers must manage increasingly complex branching logic when dealing with different account types

This proposal serves as a successor to ERC-6492 that addresses these limitations by:

- Unifying the verification procedure for both CREATE2 and EIP-7702 counterfactual accounts
- Standardizing a verification signature format that embeds deployment/delegation intent
- Defining a clear verification order that removes ambiguity
- Maintaining compatibility with existing [ERC-1271](./eip-1271.md) and [ERC-6492](./eip-6492.md) infrastructure
- Simplifying the experience by providing a single standard for all counterfactual signature verification

By consolidating these verification methods into a single standard, we prevent fragmentation in the ecosystem and make it easier for developers to correctly implement signature verification across all account types.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Signer Side (e.g. Wallets)

This ERC proposes that wallets can wrap signatures into a predelegate verification-compatible format that is constructed as follows:

#### CREATE2 Accounts

```solidity
wrapped_signature = abi.encode(factory, init_data, signature) || MAGIC_CREATE2

MAGIC_CREATE2 = 0x6492649264926492649264926492649264926492649264926492649264926492
```

Where:
- `signature`: The signature to be verified by the delegate's `isValidSignature` method
- `MAGIC_CREATE2`: Detection marker for CREATE2 accounts
- `factory`: Address of the CREATE2 factory contract
- `init_data`: Optional initialization data to be executed before validation

#### EIP-7702 Accounts

```solidity
wrapped_signature = signature 
    || context 
    || context.length 
    || MAGIC_7702

MAGIC_7702 = 0x7702770277027702770277027702770277027702770277027702770277027702
context = abi.encode(authorization, init_data)
authorization = abi.encode(chain_id, address, nonce, y_parity, r, s)
```

Where:
- `signature`: The signature to be verified by the delegate's `isValidSignature` method
- `MAGIC_7702`: Detection marker for EIP-7702 accounts
- `authorization`: Signed EIP-7702 authorization
- `init_data`: Optional initialization data to be executed before validation

#### Requirements

- Signers SHOULD NOT wrap signatures if the account has already been delegated.
- `init_data` MAY be empty if the account has no initialization data.
- If `init_data` is not empty, EIP-7702 Delegation Contracts MUST ensure that verification of `init_data` occurs on initialization.

### Verifier Side (e.g. Apps, Libraries,)

The verification procedure is performed by consumers of the account contract (e.g. applications, services, libraries, etc.).

Given inputs `(account: address, digest: bytes32, wrapped_signature: bytes)`, verifiers MUST implement the following procedure (pseudocode):

1. Check if `wrapped_signature` ends with `MAGIC_CREATE2` or `MAGIC_7702`
2. If `MAGIC_CREATE2` or `MAGIC_7702` is not found:
    1. MUST perform standard ERC-1271 verification: `account.isValidSignature(digest, signature)` 
        1. If success, return successfully.
        2. If failure, attempt `ecrecover` verification.
3. If `MAGIC_CREATE2`:
   1. Parse the wrapped signature:
      1. `(factory, init_data, signature) = abi.decode(wrapped_signature, (address, bytes, bytes))`
   2. TBD. Follows [ERC-6492](./eip-6492.md) verification procedure.
4. If `MAGIC_7702`:
   1. Parse the wrapped signature:
      1. `length = wrapped_signature.length`
      2. `context_length = wrapped_signature[length-64:length-32]`
      3. `signature = wrapped_signature[0:length-64-context_length]`
      4. `(authorization, init_data) = abi.decode(wrapped_signature[length-64-context_length:length-64], (bytes, bytes))`
      5. `(chain_id, delegation, nonce, y_parity, r, s) = abi.decode(authorization, (uint256, address, uint256, uint8, bytes32, bytes32))`
   2. If `account.code == bytes.concat(hex"ef0100", delegation)`:
      1. Perform standard [ERC-1271](./eip-1271.md) verification: `account.isValidSignature(digest, signature)` 
         - If success, return successfully. 
         - If failure, attempt `ecrecover` verification. 
   3. Perform a multicall to initialize the account and validate the signature: 
      1. `account.call(init_data)`
      2. `account.isValidSignature(digest, signature)`
      3. Return the result of 2. 

#### Requirements

- Verifiers MUST follow the verification procedure as specified
- Verifiers MAY use a (pre)deployed multicall contract or a deployless multicall mechanism. 
- For `MAGIC_7702` (EIP-7702 accounts), Verifiers MUST include an `authorizationList` parameter containing `authorization` (in the `wrapped_signature`) in the `eth_call` request for Step 4(iii). 

## Rationale

### EIP-7702 Offchain Verification

The procedure for EIP-7702 accounts is intended for offchain signature verification, as onchain contracts cannot apply a delegation in a transient or simulated manner.

### Atomic Simulation Context

The design executes initialization and validation atomically (via a verifier or multicall contract) to ensure state changes from initialization are visible during validation. This mirrors the execution flow when a EIP-7702 delegation transaction includes authorization, or a CREATE2 account is deployed with initialization data.

## Backwards Compatibility

For CREATE2 accounts, this ERC defines the same wrapped signature format as [ERC-6492](./eip-6492.md). This is to ensure backwards compatibility with existing ERC-6492 infrastructure.

For EIP-7702 accounts, this ERC leaves the inner `signature` unaltered in the wrapped signature foramt, rather than ABI-encoding it. The assumption is that most [ERC-1271](./eip-1271.md) `isValidSignature` implementations rely on a static length for the signature, and will therefore parse the inner `signature` correctly when reading up to the defined context. This ensures wrapped signatures can still be validated if they are passed to [ERC-1271](./eip-1271.md) `isValidSignature` as-is for whatever reason.

## Test Cases

TBD

## Security Considerations

TBD

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
