---
eip: 8010
title: Counterfactual Signature Verification
description: Enables ERC-1271 signature verification for accounts that intend to deploy via CREATE2 or EIP-7702 before the deployment occurs onchain
author: Jake Moxey (@jxom), howydev (@howydev), Tanishk Goyal (@legion2002), Ivo Georgiev (@Ivshti)
discussions-to: https://ethereum-magicians.org/t/new-erc-signature-verification-for-pre-delegated-accounts/25201
status: Draft
type: Standards Track
category: ERC
created: 2025-08-21
requires: 1271, 7702
---

# Counterfactual Signature Verification

## Abstract

This ERC defines a signature verification procedure as a successor to [ERC-6492](./eip-6492.md) that enables signature validation for accounts that intend to deploy via CREATE2 or [EIP-7702](./eip-7702.md) before onchain deployment occurs. The standard introduces a detectable signature wrapper containing the context needed to simulate the deployment and validate signatures through [ERC-1271](./eip-1271.md) in a single atomic operation.

## Motivation

[EIP-7702](./eip-7702.md) enables EOAs to set code in their account, but signatures are often generated before onchain delegation occurs. Current verification methods ([ERC-6492](./eip-6492.md), [ERC-1271](./eip-1271.md), etc) cannot validate these pre-delegation signatures against the intended delegate logic.

This proposal addresses this limitation by:

- Standardizing a typed verification signature format that embeds deployment intent
- Defining a verification procedure that simulates deployment atomically
- Maintaining compatibility with existing [ERC-1271](./eip-1271.md) infrastructure

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Signer Side (e.g. Wallets)

This ERC proposes that wallets can wrap signatures into a predelegate verification-compatible format that is constructed as follows:

```solidity
wrapped_signature =
  signature
  || context
  || context.length
  || MAGIC

context = 
  0x01 || abi.encode(factory, init_data) // CREATE2
  0x02 || abi.encode(authorization, init_data) // EIP-7702
authorization = abi.encode(chain_id, address, nonce, y_parity, r, s)
MAGIC = 0x8010801080108010801080108010801080108010801080108010801080108010
```

- `signature`: The signature to be verified by the delegate's `isValidSignature` method
- `context`: Context required to simulate and validate the signature (CREATE2 or EIP-7702)
- `MAGIC`: Detection marker
- `factory`: Address of the CREATE2 factory contract
- `authorization`: Signed EIP-7702 authorization
- `init_data`: Optional initialization data to be executed before validation

### Requirements

- Signers SHOULD NOT wrap signatures if the account has already been delegated.
- `init_data` MAY be empty if the account has no initialization data.

### Verifier Side (e.g. Apps, Libraries,)

#### Account Consumers

The verification procedure is performed by consumers of the account contract (e.g. applications, services, libraries, etc.).

Given inputs `(account: address, digest: bytes32, wrapped_signature: bytes)`, verifiers MUST implement the following procedure (pseudocode):

### Step 1: Detection and parsing

1. Check if `wrapped_signature` ends with `MAGIC`
2. If `MAGIC` is not found:
    1. MUST perform standard ERC-1271 verification: `account.isValidSignature(digest, signature)` 
        1. If success, return successfully.
        2. If failure, attempt `ecrecover` verification.
3. If `MAGIC` is found:
    1. Parse `wrapped_signature`:
        - `length = wrapped_signature.length`
        - `context_length = wrapped_signature[length-64:length-32]`
        - `context = wrapped_signature[length-64-context_length:length-64]`
        - `signature = wrapped_signature[0:length-64-context_length]`
    2. Decode the `context`:
        - `type = context[0:1]`
        - If `type == 0x01` (CREATE2):
            - `(factory, init_data) = abi.decode(context[1:], (address, bytes))`
        - If `type == 0x02` (EIP-7702):
            - `(authorization, init_data) = abi.decode(context[1:], (bytes, bytes))`
            - `(chain_id, delegation, nonce, y_parity, r, s) = abi.decode(authorization, (uint256, address, uint256, uint8, bytes32, bytes32))`
    3. Continue to [Step 2](#step-2-check-if-already-delegated-or-deployed).

### Step 2: Check if already delegated or deployed

Check if the account is already delegated to the target `delegation`, or if it has been deployed via CREATE2.

1. If `type == 0x01` (CREATE2) AND `account.code.length > 0`:
    1. Perform standard [ERC-1271](./eip-1271.md) verification: `account.isValidSignature(digest, signature)` 
        1. If success, return successfully. 
        2. If failure, attempt `ecrecover` verification. 
2. If `type == 0x02` (EIP-7702) AND `account.code == bytes.concat(hex"ef0100", delegation)`:
    1. Perform ERC-1271 verification: `account.isValidSignature(digest, signature)` 
        1. If success, return successfully. 
        2. If failure, attempt `ecrecover` verification. 
3. Otherwise, continue to [Step 3](#step-3-simulate-delegation-and-validate).

### Step 3: Simulate deployment and validate

If the account is not deployed yet, we will simulate the deployment, and validate the signature.

This step assumes we have set up a CREATE2 Signature Verifier contract that implements `isValidSignature8010` and is deployed at `verifier`. This is not the case for EIP-7702, because we can verify via the account itself.

1. Perform a call to `verifier.isValidSignature8010(digest, wrapped_signature)` (via `eth_call`) with:
   1. If `type == 0x01` (CREATE2):
       - `data` containing `abi.encodeWithSignature("isValidSignature8010(bytes32,bytes)", digest, wrapped_signature)`
       - `to` containing `verifier`
   2. If `type == 0x02` (EIP-7702):
       - `authorizationList` containing `[[chain_id, delegation, nonce, y_parity, r, s]]`
       - `data` containing `abi.encodeWithSignature("isValidSignature8010(bytes32,bytes)", digest, wrapped_signature)`
       - `from` containing `account`
       - `to` containing `account`

### Requirements

- Verifiers MUST follow the verification procedure as specified
- Verifiers MAY use a (pre)deployed multicall contract or a deployless multicall mechanism.

#### Contract Interface

EIP-7702 Delegation or CREATE2 Signature Verifier contracts MUST implement the following interface:

```solidity
pragma solidity ^0.5.0;

/// @dev Interface for the ERC8010 signature verification.
interface IERC8010 { 
    /// @dev Initializes an account to be verified via ERC-1271, and then
    ///      verifies a signature for the given digest.
    function isValidSignature8010(bytes32 digest, bytes memory wrappedSignature)
        public
        returns (bool);
}
```

- `isValidSignature8010` MAY initialize the account with the provided `context` within `wrappedSignature`. 
  - As there is no `view`/`pure` modifier, this means it MAY modify state if the caller is not in a simulated environment (e.g. `eth_call`, etc). 
  - As such, [EIP-7702](./eip-7702.md) Delegation Contracts MUST check to ensure that unauthorized `init_data` in `wrappedSignature` is not executed (e.g. check a signature (over initialization contents) within `init_data`, or `msg.sender == address(this)`). 

## Rationale

### Offchain Verification

This ERC is intended for offchain signature verification. Onchain contracts cannot apply a delegation in a transient or simulated manner.

### Atomic Simulation Context

The design executes initialization and validation (Step 3) atomically (via multicall) to ensure state changes from initialization are visible during validation. This mirrors the execution flow when a 7702 delegation transaction includes both authorization and subsequent calls.

## Backwards Compatibility

This ERC defines a wrapped signature format that remains backward compatible with existing ERC-1271 infrastructure by leaving the inner `signature` unaltered, rather than ABI-encoding it. The assumption is that most [ERC-1271](./eip-1271.md) `isValidSignature` implementations rely on a static length for the signature, and will therefore parse the inner `signature` correctly when reading up to the defined context. This method ensures maximum compatibility with existing infrastructure.

This standard does not require compatibility with ERC-6492 or other signature wrapping standards, as it addresses the specific requirements of EIP-7702 delegation.

## Test Cases

TBD

## Security Considerations

TBD

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
