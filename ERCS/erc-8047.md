---
eip: 8047
title: Forensic Token (Forest)
description: A DAG-based token enabling hierarchical traceability and efficient enforcement for compliant digital assets.
author: Sirawit Techavanitch (@MASDXI)
discussions-to: https://ethereum-magicians.org/t/erc-8047-forensic-token-forest/25786
status: Draft
type: Standards Track
category: ERC
created: 2025-10-15
requires: 165, 1155, 5615
---

## Abstract

Forensic Token (Forest) is a directed acyclic graph (DAG) -inspired token model designed to enhance traceability and regulatory compliance in digital currency or e-Money systems. By introducing hierarchical token tracking, it enables efficient enforcement on any token linked to suspicious activity with level/root. Enforcement actions, such as freezing specific tokens or partitioning all tokens with relational links, are optimized to operate at $O(1)$ complexity.

## Motivation

The Central Bank Digital Currency (CBDC) and Private Money concept aims to utilize the advantages of Blockchain or Distributed Ledger Technology (DLT) that provide immutability, transparency, and security, and it adopts smart contracts, which play a key role in creating programmable money. However, technology itself gives an advantage and eliminates the ideal problem of compliance with the regulator and the Anti-Money Laundering and Countering the Financing of Terrorism (AML/CFT) standard, but it does not seem practical to be done in the real world and is not efficiently responsible for the financial crime or incidents that occur in the open network of economics.

Financial crime incident response actions, like freezing accounts or funds, typically necessitate further analysis to pinpoint illicit transactions. This process is off-chain; it can be slow and inefficient. Many existing solutions focus primarily on prevention by attempting to predict bad actors in advance; however, human behavior changes over time, sometimes immediately, especially during periods of economic stress, which may make such approaches unreliable.

Therefore, preventive controls alone cannot fully eliminate bad actors, an inevitable risk in open financial systems. Rather than attempting to predict malicious behavior, there is a need for systems that can respond to incidents faster and more precisely once they occur. The Forensic Token (Forest) is designed to address this need by providing native, on-chain traceability and enforcement at the token level, enabling targeted actions that reduce operational metrics such as Mean Time To Resolve (MTTR) and Mean Time To Fix (MTTF) while preserving on-chain programmability.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Compatible implementations MUST implement the `IERC8047` interface and MUST inherit from [ERC-1155](./eip-1155.md) and [ERC-5615](./eip-5615.md) interfaces. All functions defined in the interface MUST be present and all function behavior MUST meet the behavior specification requirements below.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity >=0.8.0 <0.9.0;

/**
 * @title ERC-8047 interface
 */

interface IERC8047 is IERC1155, IERC5615 {
    /**
     * @notice Emitted when a new token is created within a DAG.
     * @param root The root token ID of the DAG to which the new token belongs.
     * @param id The ID of the newly created token.
     * @param from The address that created/minted the token.
     */
    event TokenCreated(
        uint256 indexed root,
        uint256 id,
        address indexed from
    );

    /**
     * @notice Emitted when a token is spent or partially spent.
     * @param id The ID of the token being spent.
     * @param value The amount of the token that was spent.
     */
    event TokenSpent(
        uint256 indexed id,
        uint256 value
    );

    /**
     * @notice Retrieves the latest (highest) level of the DAG that a given token belongs to.
     * @param id The ID of the token.
     * @return uint256 The latest DAG level for the token.
     */
    function latestDAGLevelOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves the level of token within its DAG.
     * @param id The ID of the token.
     * @return uint256 The level of the token in the DAG.
     */
    function levelOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves the owner of a given token.
     * @param id The ID of the token.
     * @return address The address that owns the token.
     */
    function ownerOf(uint256 id) external view returns (address);

    /**
     * @notice Retrieves the parent token ID of a given token.
     * @param id The ID of the token.
     * @return uint256 The ID of the parent token. Retrieves 0 if the token is a root.
     */
    function parentOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves the root token ID of the DAG to which a given token belongs.
     * @param id The ID of the token.
     * @return uint256 The root token ID of the DAG.
     */
    function rootOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves total supply of all token.
     * @custom:overloading of {IERC5615.totalSupply}
     * @return uint256 The total supply of all token.
     */
    function totalSupply() external view returns (uint256);
}
```

### Behavior Specification

#### Creating Token

- When mint a token, the `id` MUST NOT be supplied by the minter, the `id` MUST be generate by the contract itself.
- The `value` of the `id` MUST NOT be `0`. If value is `0`, the mint operation MUST revert.
- The events `TokenCreated` MUST emit when mint, create, or issuing token operation is successful.

#### Burning Token

- When burn a token, the `id` MUST NOT be deleted from the DAG. Instead, its value MUST be set to `0`, and the operation MUST NOT create a new token to the zero address.
- The events `TokenSpent` MUST emit when burn, remove token operation is successful.

#### Transferring

- The `safeTransferFrom` MUST verify that the `id` exists. If it does not, the function MUST revert.
- The `sender` MUST be the owner of the `id` or an approved operator.
- The `value` to be spent MUST NOT exceed the `value` of the `id`. If it does, the function MUST revert.
- The `safeTransferFrom` function MUST mint a new `id` as a child of the `id` being spent. The new `id` MUST have its `parent` set to the `id` that was spent. and its level MUST be incremented by `1` relative to the parent.
- To maintain compatibility with [ERC-1155](./eip-1155.md), `safeTransferFrom` MUST emit two `TransferSingle` events to reflect the parent–child token behavior.
   - One for burning the parent token `TransferSingle(operator, from, address(0), id, value)`.
   - One for minting the new child token `TransferSingle(operator, address(0), to, newId, value)`.
- Similarly, `safeBatchTransferFrom` MUST emit two `TransferBatch` events, preserving token order.
    - First, for burning all parent tokens in the batch, MUST follow the order provided by the input `ids` array.
    - Second, for minting all corresponding child tokens, MUST match the same order of `ids` as the parent batch.
- The events `TokenSpent` MUST emit whenever token is spent.
- The events `TokenCreated` MUST be emitted whenever a new token is successfully created.

#### Merging

- To merge two or more `id` into a new `id`, all tokens MUST be part of the same `DAG` (i.e., share the same `root`).
  new `id` from merging will be

  $k\text{: The highest level from token ids that will be merging.}$

  $newTokenIdLevel = k + 1$

- The `TokenSpent` event MUST be emitted for all `id` involved in the merge when the merging operation is successful.

#### URI JSON Schema

In this proposal, each token has a unique `id` to track its movement in the `DAG` (like serial numbers), but all tokens representing the same asset share a single metadata URI. This reflects the fungible nature of the asset (like fiat currency)

- All tokens of the same asset MUST reference the same URI, regardless of their individual `id`.
- Implementations SHOULD follow the JSON Schema definition provided below for consistency across client implementations.

```json
{
  "title": "Token Metadata",
  "description": "Metadata schema for ERC-8047: Forensic Token (Forest).",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "Human-readable name of the asset represented by this token."
    },
    "symbol": {
      "type": "string",
      "description": "Ticker symbol or shorthand identifier for the token."
    },
    "decimals": {
      "type": "integer",
      "description": "Number of decimal places used to display token amounts. For example, 18 means the token amount should be divided by 10^18 to get its user representation."
    },
    "description": {
      "type": "string",
      "description": "Detailed description of the asset represented by this token."
    },
    "image": {
      "type": "string",
      "format": "uri",
      "description": "A URI pointing to an image (MIME type image/*) that visually represents the asset. Recommended image width: 320–1080 pixels; aspect ratio: between 1.91:1 and 4:5."
    },
    "properties": {
      "type": "object",
      "description": "Container for extended metadata such as compliance, traceability, and DAG lineage.",
      "properties": {
        "compliance": {
          "type": "object",
          "description": "Compliance and policy information for the asset.",
          "properties": {
            "issuer": {
              "type": "string",
              "description": "Legal entity responsible for issuing or managing this asset."
            },
            "jurisdiction": {
              "type": "string",
              "description": "Legal jurisdiction or regulatory domain governing this asset."
            },
            "policies": {
              "type": "string",
              "format": "uri",
              "description": "URI linking to AML/CFT, compliance, or risk policy documentation."
            },
            "enforcement_authority": {
              "type": "string",
              "format": "uri",
              "description": "URI to the entity or endpoint responsible for enforcement actions (e.g., freeze, revoke)."
            }
          },
          "required": ["issuer", "policies"]
        }
      },
      "required": ["compliance"]
    }
  },
  "required": ["name", "description", "image", "properties"]
}
```

A complete JSON Schema reference for ERC-8047 metadata is provided below for validation and implementation guidance.

```json
{
  "name": "United States Dollar",
  "symbol": "USD",
  "decimals": 18,
  "description": "A compliant, traceable digital representation of the U.S. Dollar using the ERC-8047: Forensic Token (Forest).",
  "image": "https://acmee-finance.invalid/assets/images/USD_icon.png",
  "properties": {
    "compliance": {
      "issuer": "Acmee Finance Inc.",
      "jurisdiction": "US-NY",
      "policies": "https://acmee-finance.invalid/policies",
      "enforcement_authority": "https://acmee-finance.invalid/enforcement"
    }
  }
}
```

## Rationale

### Transaction Flow Consistency

All token movements within the forest token-based model maintain a coherent parent–child lineage, preserving the integrity of value propagation and token provenance. Unlike the Unspent Transaction Output (UTXO) model, where each transaction produces new immutable outputs, the forest token-based model allows existing states to be updated directly. 

Each token group can be partially or repeatedly spent until its value is depleted to 0, maintaining continuity within the same lineage. This approach introduces a hierarchical structure of token relationships, forming a forest of DAGs that enables traceable and enforceable token flow across the system. Such structure allows for efficient forensic analysis and compliance enforcement by maintaining consistent linkages from child tokens back to their roots. 

Traditional token standards like [ERC-20](./eip-20.md) or [ERC-3643](./eip-3643.md) do not preserve this hierarchical traceability, as they abstract balances into account-level states rather than token-level flows.

<div align="center">
  <img src="../asset/eip-8047/Forest.svg" width="800"/>
</div>

### Reverse Topological Ordering of Tokens

One of the key benefits of the forest token-based model is that it natively supports reverse topological traversal. Each tokens stores a reference to its parent token, allowing to efficiently iterate `parentOf` back to the `root` of the DAG.

This back-to-root traversal differs from a full DAG traversal. It only follows the lineage of a specific token `id` up to its root, rather than visiting all tokens in the DAG.

<div align="center">
  <img src="../asset/eip-8047/Forest_Sort.svg" width="400"/>
</div>

### Spendable balance via off-chain

On-chain iteration to retrieve `spendableBalanceOf` can be gas-intensive and inefficient, especially for large DAGs or multiple sets of DAGs. To address this, the current `spendableBalanceOf` account can be determined off-chain by deploying a service that subscribes to events emitted by the contract. This service calculates the spendable balance by reconciling the account’s total `balanceOf` with any tokens that have been frozen or restricted due to hierarchical or forensic rules, providing an accurate representation of the amount available for `transfer`.

### Multi-Level Compliance Enforcement

Traditional systems are enforce rules at the account level. This often means freezing an entire wallet just to stop one bad transaction, which unfairly locks up a user's legitimate funds. Forest solves this by applying rules to both the account and the individual tokens. It works like pruning a tree rather than chopping it down. This precision allows authorities to target only the specific illicit assets while leaving the rest of the user's portfolio untouched and fully operational.

## Backwards Compatibility

This standard is fully compatible with [ERC-1155](./eip-1155.md) and [ERC-5615](./eip-5615.md).

## Reference Implementation

<!-- TODO WIP -->

## Security Considerations

**Denial Of Service (DoS)**  
Run out of gas problem due to the operation consuming more gas if transferring in `safeBatchTransferFrom`.

**Gas Limit Vulnerabilities**  
Exceeds block gas limit if the blockchain has a block gas limit lower than the gas used in the transaction.

**Data Fragmentation**  
The Forest model tracks all assets within the system, which can be represented mathematically as

$A^d \text{: The decimals of the asset.}$  
$A^t \text{: Total supply of the asset.}$  
$A^s \text{: The possible asset is represented in id.}$

$$A^s = A^t \times A^d$$

While this ensures precision, the high granularity can increase storage needs.
Traditional finance often uses simpler decimals like 2, 4 or 6, avoiding excessive detail.
Adopting similar strategies could help balance granularity with efficiency. Or limit value as `MINIMUM_AMOUNT` check before spending.

**Confidentiality and Privacy**  
Maybe it can be linked to identity. from spending and behavior usage.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
