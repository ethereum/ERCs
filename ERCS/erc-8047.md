---
eip: 8047
title: Forensic Token (Forest)
description: A DAG-based token enabling hierarchical traceability and efficient enforcement for compliant digital assets.
author: Sirawit Techavanitch (@MASDXI)
discussions-to: https://ethereum-magicians.org/t/erc-8047-forensic-token-forest/25786
status: Draft
type: Standards Track
category: ERC
created: 2025-10-15
requires: 165, 1155, 3525
---

## Abstract

Forensic Token (Forest) is a DAG-inspired token model designed to enhance traceability and regulatory compliance in digital currency or e-Money systems. By introducing hierarchical token tracking, it enables efficient enforcement on any token linked to suspicious activity with level/root. Enforcement actions, such as freezing specific tokens or partitioning all tokens with relational links, are optimized to operate at $O(1)$ complexity.

## Motivation

The Central Bank Digital Currency (CBDC) and Private Money concept aims to utilize the advantages of Blockchain or Distributed Ledger Technology (DLT) that provide immutability, transparency, and security, and it adopts smart contracts, which play a key role in creating programmable money. However, technology itself gives an advantage and eliminates the ideal problem of compliance with the regulator and the Anti-Money Laundering and Countering the Financing of Terrorism (AML/CFT) standard, but it does not seem practical to be done in the real world and is not efficiently responsible for the financial crime or incidents that occur in the open network of economics.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174.

```
// SPDX-License-Identifier: CC0-1.0
pragma solidity >=0.8.0 <0.9.0;

/**
 * @title Interface for Forest - Forensic Token
 */

interface IERC8047 {
    // events
    event TransactionCreated(bytes32 indexed root, bytes32 id, address indexed from);
    event TransactionSpent(bytes32 indexed id, uint256 value);

    // errors
    error TransactionNotExist();
    error TransactionInsufficient(uint256 value, uint256 spend);
    error TransactionZeroValue();

    // functions
    function hierarchyOfGraph(bytes32 tokenId) external view returns (uint256);
    function levelOfToken(bytes32 tokenId) external view returns (uint256);
    function ownerOfToken(bytes32 tokenId) external view returns (address);
    function parentOfToken(bytes32 tokenId) external view returns (bytes32);
    function rootOfToken(bytes32 tokenId) external view returns (bytes32);
    function tokenExists(bytes32 tokenId) external view returns (bool);
    function valueOfToken(bytes32 tokenId) external view returns (uint256);
}
```

### Function Behavior

#### Create Transaction

- The value of the transaction MUST NOT be zero. If value is zero, the function MUST revert.
- The transaction MUST be assigned a unique id. The id SHOULD be derived using the deterministic hashing function.
- The new transaction MUST include the correct parent field:
  If the transaction is derived (e.g., created by the spender), the parent field MUST reference the id of the original transaction.
  If the transaction is a root, the parent field MUST be set to zero.
- The events TransactionCreated MUST emit when a new transaction is created.

#### Spend Transaction

- The spending action MUST verify that the transaction with the given id exists. If not, the function SHOULD return false or revert.
- The value to be spent MUST NOT exceed the value of the transaction. If it does, the function MUST revert.
- The hierarchy of the transaction’s root MUST be incremented if the new transaction’s level exceeds the current hierarchy.
- The events TransactionSpent MUST emit when spending transaction.

#### Merging Transaction

- To merge two or multiple transactions into new one transaction, all transactions MUST have the same transaction root
  new transaction from merging will be
  - $tx^k$: The highest transaction level from transactions that will be merging.
  - $tx^l$: The transaction level of the merged transaction.

## Rationale

### Transaction State Management via DAG

In the `UTXO` model each transacton maintain the amount of money or group of money in each individual transaction and each transaction is not underlying to any account storage.To spend a transaction, the caller must be the owner of that transaction.  
`Forest` use to modify an existing state rather than create a new transaction, like in `UTXO` do, `Forest` token allows spending the transaction multiple times till it’s met 0, The `Forest` token enables tracking of child/subtree structures. providing a hierarchical view of token flows and relationships, which is not possible in traditional token standards like [ERC-20](./eip-20.md), and [ERC-3643](./eip-3643.md).

<div align="center">
  <img src="../asset/eip-xxxx/Forest.svg" width="800"/>
</div>

### Reverse Topological Ordering of Transactions

One of the key benefits of the `Forest` is that it natively supports reverse topological traversal. Each transaction stores a reference to its parent transaction, allowing to efficiently iterate `parentTxn` back to the `rootTxn` of the DAG.

This back-to-root traversal differs from a full DAG traversal. It only follows the lineage of a specific transaction up to its root, rather than visiting all transactions in the DAG.

<div align="center">
  <img src="../asset/eip-xxxx/Forest_Sort.svg" width="400"/>
</div>

### Spendable balance via off-chain

On-chain iteration to retrieve `spendableBalanceOf` can be gas-intensive and inefficient, especially for large DAGs or multiple sets of DAGs. To address this, the current `spendableBalanceOf` an account can be determined off-chain by deploying a service that subscribes to events emitted by the contract. This service calculates the spendable balance by reconciling the account’s total `balanceOf` with any tokens that have been frozen or restricted due to hierarchical or forensic rules, providing an accurate representation of the amount available for `transfer`.

## Backwards Compatibility

This standard is ideally fully compatible with [ERC-1155](./eip-1155.md) and [ERC-3525](./eip-3525.md)

## Reference Implementation

<!-- TODO WIP -->

## Security Considerations

**Denial Of Service (DoS)**  
Run out of gas problem due to the operation consuming higher gas if transferring multiple groups of small tokens or loop transfer.

**Gas Limit Vulnerabilities**  
Exceeds block gas limit if the blockchain has a block gas limit lower than the gas used in the transaction.

**Data Fragmentation**  
The Forest model tracks all assets within the system, which can be represented mathematically as

$A^d \text{: The decimals of the asset.}$  
$A^t \text{: Total supply of the asset.}$  
$A^s \text{: The possible asset represent in transaction.}$

$$A^s = A^t \times A^d$$

While this ensures precision, the high granularity can increase storage needs.
Traditional finance often uses simpler decimals like 2, 4 or 6, avoiding excessive detail.
Adopting similar strategies could help balance granularity with efficiency. Or limit value as MINIMUM spending.

**Confidentiality**  
Maybe it can be linked to identity. from spending and behavior usage

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
