---
eip: 8047
title: Forensic Token (Forest)
description: A DAG-based token enabling hierarchical traceability and efficient enforcement for compliant digital assets.
author: Sirawit Techavanitch (@MASDXI)
discussions-to: https://ethereum-magicians.org/t/erc-8047-forensic-token-forest/25786
status: Draft
type: Standards Track
category: ERC
created: 2025-10-15
requires: 165, 1155, 5615
---

## Abstract

Forensic Token (Forest) is a directed acyclic graph (DAG) -inspired token model designed to enhance traceability and regulatory compliance in digital currency or e-Money systems. By introducing hierarchical token tracking, it enables efficient enforcement on any token linked to suspicious activity with level/root. Enforcement actions, such as freezing specific tokens or partitioning all tokens with relational links, are optimized to operate at $O(1)$ complexity.

## Motivation

The Central Bank Digital Currency (CBDC) and Private Money concept aims to utilize the advantages of Blockchain or Distributed Ledger Technology (DLT) that provide immutability, transparency, and security, and it adopts smart contracts, which play a key role in creating programmable money. However, technology itself gives an advantage and eliminates the ideal problem of compliance with the regulator and the Anti-Money Laundering and Countering the Financing of Terrorism (AML/CFT) standard, but it does not seem practical to be done in the real world and is not efficiently responsible for the financial crime or incidents that occur in the open network of economics.

Financial crime incident response actions, like freezing accounts or funds, typically necessitate further analysis to pinpoint illicit transactions. This process is off-chain; it can be slow and inefficient. Many existing solutions focus primarily on prevention by attempting to predict bad actors in advance; however, human behavior changes over time, sometimes immediately, especially during periods of economic stress, which may make such approaches unreliable.

Therefore, preventive controls alone cannot fully eliminate bad actors, an inevitable risk in open financial systems. Rather than attempting to predict malicious behavior, there is a need for systems that can respond to incidents faster and more precisely once they occur. The Forensic Token (Forest) is designed to address this need by providing native, on-chain traceability and enforcement at the token level, enabling targeted actions that reduce operational metrics such as Mean Time To Resolve (MTTR) and Mean Time To Fix (MTTF) while preserving on-chain programmability.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Compatible implementations MUST implement the `IERC8047` interface and MUST inherit from [ERC-1155](./eip-1155.md) and [ERC-5615](./eip-5615.md) interfaces. All functions defined in the interface MUST be present and all function behavior MUST meet the behavior specification requirements below.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity >=0.8.0 <0.9.0;

/**
 * @title ERC-8047 interface
 */

// import "./IERC1155.sol";
// import "./IERC5615.sol";

// The EIP-165 identifier of this interface is `0x8aae36fc`.
interface IERC8047 /**is IERC1155, IERC5615 */ {
    /**
     * @dev Structure representing a token (node) within the Forest DAG.
     */
    struct Token {
        uint256 root;
        uint256 parent;
        uint256 value;
        uint96 level;
        address owner;
    }

    /**
     * @notice Emitted when a new token is created within a DAG.
     * @param root The root token ID of the DAG to which the new token belongs.
     * @param id The ID of the newly created token.
     * @param from The address that created/minted the token.
     */
    event TokenCreated(
        uint256 indexed root,
        uint256 id,
        address indexed from
    );

    /**
     * @notice Emitted when a token is spent or partially spent.
     * @param root The root token ID of the DAG to which the new token belongs.
     * @param id The ID of the token being spent.
     * @param value The amount of the token that was spent.
     */
    event TokenSpent(
      uint256 indexed root, 
      uint256 indexed id, 
      uint256 value
    );

    /**
     * @notice Retrieves the latest (highest) level of the DAG that a given token belongs to.
     * @param id The ID of the token.
     * @return uint256 The latest DAG level for the token.
     */
    function latestDAGLevelOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves the level of token within its DAG.
     * @param id The ID of the token.
     * @return uint256 The level of the token in the DAG.
     */
    function levelOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves the owner of a given token.
     * @param id The ID of the token.
     * @return address The address that owns the token.
     */
    function ownerOf(uint256 id) external view returns (address);

    /**
     * @notice Retrieves the parent token ID of a given token.
     * @param id The ID of the token.
     * @return uint256 The ID of the parent token. Retrieves 0 if the token is a root.
     */
    function parentOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves the root token ID of the DAG to which a given token belongs.
     * @param id The ID of the token.
     * @return uint256 The root token ID of the DAG.
     */
    function rootOf(uint256 id) external view returns (uint256);

    /**
     * @notice Retrieves token detail from given token id.
     * @param id The ID of the token.
     * @return Token struct containing the token's detailed properties.
     */
    function tokens(uint256 id) external view returns (Token memory);

    /**
     * @notice Retrieves total supply of all token.
     * @custom:overloading of {IERC5615.totalSupply}
     * @return uint256 The total supply of all token.
     */
    function totalSupply() external view returns (uint256);
}
```

### Behavior Specification

#### Creating Token

- The `value` of the MUST NOT be zero. If value is zero, the mint operation MUST revert.
- When mint a token, the `id` MUST NOT be supplied by the minter, the `id` MUST be generate by the contract itself.
- When mint a token, the `root` property of the new token MUST be set to its own `id` and 
the `parent` property of the new token token MUST be set to zero to explicitly indicate that the token serves as the `root` of a new DAG.
- The events `TokenCreated` MUST emit when mint, create, or issuing token operation is successful.

#### Burning Token

- When burn a token, the `id` MUST NOT be deleted from the DAG. Instead, its value MUST be set to zero, and the operation MUST NOT create a new token to the zero address.
- The events `TokenSpent` MUST emit when burn, remove token operation is successful.

#### Existence

- Since burning a token does not delete the node from the DAG (it only reduces the value to zero), the exists function defined in [ERC-5615](./eip-5615.md) MUST return `true` for any id that has been created, even if its balance is currently zero.
- Implementations MUST determine existence by verifying that the `root` of the `id` is not zero, rather than checking if the token's `value` is non-zero.

#### Transferring

- The `safeTransferFrom` MUST verify that the `id` exists. If it does not, the function MUST revert.
- The `safeTransferFrom` MUST revert if the `from` address is equal to the `to` address.
- The `from` MUST be the owner of the `id` or an approved operator.
- The `value` to be spent MUST NOT exceed the `value` of the `id`. If it does, the function MUST revert.
- The `safeTransferFrom` function MUST mint a new `id` as a child of the `id` being spent. The new `id` MUST have its `parent` set to the `id` that was spent. and its level MUST be incremented by one relative to the `parent`.
- To maintain compatibility with [ERC-1155](./eip-1155.md), `safeTransferFrom` MUST emit two `TransferSingle` events to reflect the parent–child token behavior.
   - One for burning the parent token `TransferSingle(operator, from, address(0), id, value)`.
   - One for minting the new child token `TransferSingle(operator, address(0), to, newId, value)`.
- Similarly, `safeBatchTransferFrom` MUST emit two `TransferBatch` events, preserving token order.
    - First, for burning all parent tokens in the batch, MUST follow the order provided by the input `ids` array.
    - Second, for minting all corresponding child tokens, MUST match the same order of `ids` as the parent batch.
- The events `TokenSpent` MUST emit whenever token is spent.
- The events `TokenCreated` MUST be emitted whenever a new token is successfully created.

#### Merging

- To merge two or more `id` into a new `id`, all tokens MUST be part of the same `DAG` (i.e., share the same `root`).
  new `id` from merging will be

  $k\text{: The highest level from token ids that will be merging.}$

  $$newTokenIdLevel = k + 1$$

- The `TokenSpent` event MUST be emitted for all `id` involved in the merge when the merging operation is successful.

#### URI JSON Schema

In this proposal, each token has a unique `id` to track its movement in the `DAG` (like serial numbers), but all tokens representing the same asset share a single metadata URI. This reflects the fungible nature of the asset (like fiat currency).

- All tokens of the same asset MUST reference the same URI, regardless of their individual `id`.
- Implementations SHOULD follow the JSON Schema definition provided below for consistency across client implementations.

```json
{
  "title": "Token Metadata",
  "description": "Metadata schema for ERC-8047: Forensic Token (Forest).",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "Human-readable name of the asset represented by this token."
    },
    "symbol": {
      "type": "string",
      "description": "Ticker symbol or shorthand identifier for the token."
    },
    "decimals": {
      "type": "integer",
      "description": "Number of decimal places used to display token amounts. For example, 18 means the token amount should be divided by 10^18 to get its user representation."
    },
    "description": {
      "type": "string",
      "description": "Detailed description of the asset represented by this token."
    },
    "image": {
      "type": "string",
      "format": "uri",
      "description": "A URI pointing to an image (MIME type image/*) that visually represents the asset. Recommended image width: 320–1080 pixels; aspect ratio: between 1.91:1 and 4:5."
    },
    "properties": {
      "type": "object",
      "description": "Container for extended metadata such as compliance, traceability, and DAG lineage.",
      "properties": {
        "compliance": {
          "type": "object",
          "description": "Compliance and policy information for the asset.",
          "properties": {
            "issuer": {
              "type": "string",
              "description": "Legal entity responsible for issuing or managing this asset."
            },
            "jurisdiction": {
              "type": "string",
              "description": "Legal jurisdiction or regulatory domain governing this asset."
            },
            "policies": {
              "type": "string",
              "format": "uri",
              "description": "URI linking to AML/CFT, compliance, or risk policy documentation."
            },
            "enforcement_authority": {
              "type": "string",
              "format": "uri",
              "description": "URI to the entity or endpoint responsible for enforcement actions (e.g., freeze, revoke)."
            }
          },
          "required": ["issuer", "policies"]
        }
      },
      "required": ["compliance"]
    }
  },
  "required": ["name", "description", "image", "properties"]
}
```

A complete JSON Schema reference for ERC-8047 metadata is provided below for validation and implementation guidance.

```json
{
  "name": "United States Dollar",
  "symbol": "USD",
  "decimals": 18,
  "description": "A compliant, traceable digital representation of the U.S. Dollar using the ERC-8047: Forensic Token (Forest).",
  "image": "https://acmee-finance.invalid/assets/images/USD_icon.png",
  "properties": {
    "compliance": {
      "issuer": "Acmee Finance Inc.",
      "jurisdiction": "US-NY",
      "policies": "https://acmee-finance.invalid/policies",
      "enforcement_authority": "https://acmee-finance.invalid/enforcement"
    }
  }
}
```

## Rationale

### Transaction Flow Consistency

All token movements within the forest token-based model maintain a coherent parent–child lineage, preserving the integrity of value propagation and token provenance. Unlike the Unspent Transaction Output (UTXO) model, where each transaction produces new immutable outputs, the forest token-based model allows existing states to be updated directly. 

Each token group can be partially or repeatedly spent until its value is depleted to zero, maintaining continuity within the same lineage. This approach introduces a hierarchical structure of token relationships, forming a forest of DAGs that enables traceable and enforceable token flow across the system. Such structure allows for efficient forensic analysis and compliance enforcement by maintaining consistent linkages from child tokens back to their roots. 

Traditional token standards like [ERC-20](./eip-20.md) or [ERC-3643](./eip-3643.md) do not preserve this hierarchical traceability, as they abstract balances into account-level states rather than token-level flows.

<div align="center">
  <img src="../asset/eip-8047/Forest.svg" width="800"/>
</div>

### Reverse Topological Ordering of Tokens

One of the key benefits of the forest token-based model is that it natively supports reverse topological traversal. Each token stores a reference to its parent token, allowing to efficiently iterate from any given token back to its root token of the DAG. This back-to-root traversal differs from a full DAG traversal. It only follows the lineage of a specific token ID up to its root, rather than visiting all tokens in the DAG.

### Variable Packing 

The property level returns `uint96` as this offers the maximum possible precision that fits within the same storage slot as the owner address. Since an address occupies 160 bits, exactly 96 bits remain available in the 256 bits word. Utilizing `uint96` ensures zero wasted space.

From a functional perspective, `uint96` allows for a tree depth of , which is for all practical purposes infinite. Even in an extreme scenario on a high-performance network or Layer 2 with a 250ms block time that produces 4 blocks per second, assuming a transaction increases the tree depth every single block

Network blocktime: $\text{250 milliseconds}$  
Second per year: $\approx \text{31,536,000 seconds}$  
Blocks per year: $\approx \text{126,144,000 blocks}$  
blocksYears to overflow: $\frac{2^{96}}{4 \times 31,536,000} \approx 6.2 \times 10^{20} \text{ years}$  

This timeframe is orders of magnitude longer than the current  known age of the universe ($\approx 1.38 \times 10^{10} \text{ years}$). Therefore, limiting the level to `uint96` to achieve storage packing imposes no realistic constraint on the system's longevity or throughput.

<div align="center">
  <img src="../asset/eip-8047/Forest_Sort.svg" width="400"/>
</div>

### Spendable Balance via off-chain

On-chain iteration to retrieve spendable balance can be gas-intensive and inefficient, especially for large DAGs or multiple sets of DAGs. To address this, the current spendable balance of account can be determined off-chain by deploying a service that subscribes to events emitted by the contract. This service calculates the spendable balance by reconciling the account’s total balance of with any tokens that have been frozen or restricted due to hierarchical or forensic rules, providing an accurate representation of the amount available for spend.

### Multi-Level Compliance Enforcement

Traditional systems are enforce rules at the account level. This often means freezing an entire wallet just to stop one bad transaction, which unfairly locks up a user's legitimate funds. Forest solves this by applying rules to both the account and the individual tokens. It works like pruning a tree rather than chopping it down. This precision allows authorities to target only the specific illicit assets while leaving the rest of the user's portfolio untouched and fully operational.

## Backwards Compatibility

This standard is fully compatible with [ERC-1155](./eip-1155.md) and [ERC-5615](./eip-5615.md).

## Reference Implementation

<!-- TODO WIP -->

## Security Considerations

**Denial Of Service (DoS)**  
A potential out-of-gas issue may occur due to the transaction gas limit cap introduced in [EIP-7825](./eip-7825.md), Operations such as `safeBatchTransferFrom` may consume more gas than permitted by the transaction gas limit introduced in [EIP-7825](./eip-7825.md)
, leading to transaction revert. For private networks that do not adopt [EIP-7825](./eip-7825.md) the transaction may exceed the block gas limit if the required gas is higher than the network’s configured maximum. To mitigate this, implementations should enforce a maximum limit on the number of input IDs allowed per transaction.

**State Growth**  
The token-based model tracks all assets within the system, which can be represented mathematically as


$A_{\text{decimals}}: \text{The decimals of the asset.}$

$A_{\text{totalSupply}}: \text{The total supply of the asset.}$

$A_{\text{ids}}: \text{The number of distinct assets represented by token IDs.}$



$A_{\text{ids}} = A_{\text{totalSupply}} \times A_{\text{decimals}}$


While this ensures precision, the high granularity can increase storage needs.
Traditional finance often uses simpler decimals like 2, 4 or 6, avoiding excessive detail.
Adopting similar strategies could help balance granularity with efficiency. Or limit value as minimum value check before spending.

**Coin Selection and Risk Propagation**  
Implementers have the flexibility to design automated coin selection algorithms tailored to user needs, such as First-In-First-Out (FIFO) 
, Last-In-First-Out (LIFO) or other optimization strategies base on business need e.g. tax optimization. 
This introduces a risk of account linking, where legitimate and illicit token IDs are combined in a single batch transfer. Because traditional compliance frameworks rely on account-level heuristics, they may incorrectly penalize a user's creditworthiness due to this association or the presence of isolated frozen tokens. To prevent unwarranted financial exclusion, compliance infrastructure must be updated to derive reputation from Net Spendable Equity (clean assets) rather than the aggregate portfolio state.

**Confidentiality and Privacy**  
Unlike opaque account-based models, this proposal treats every token as a traceable lineage, explicitly prioritizing forensic auditability. By preserving parent-child links on-chain, the protocol exposes the full transaction graph to observers. 
The proposal itself remains strictly pseudonymous. It tracks the relationships between assets, not the identities of owners, and the core specification stores no Personally Identifiable Information (PII). 
However, implementations of this standard may differ. Issuers are free to layer identity requirements such as whitelists or Soulbound Tokens (SBT) on top of the base protocol. Therefore, while the data structure is anonymous, a specific deployment may enforce real-world identity bindings.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
