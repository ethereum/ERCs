---
eic: 2002
title: EIC-2002 Decentralised Mail
author: Robert Mapes <robertjmapes@gmail.com>
discussions-to: https://github.com/ethereum/EIPs/issues/2002
status: Draft
type: Standards Track
category: ERC
created: 2025-08-12
---

## Simple Summary

A decentralized protocol standard for secure, interoperable messaging between Ethereum addresses.

## Abstract

This standard proposes a messaging interface enabling users and smart contracts to exchange encrypted, verifiable messages directly on-chain or off-chain. It aims to facilitate private, trustless communication without relying on centralized messaging servers.

## Motivation

Currently messaging solutions either rely on centralized services or lack standardization. A unified protocol for sending and receiving messages tied to Ethereum addresses, compatible across wallets and dApps, improves usability, security, and adoption of decentralized communication.

## Public Key for Encryption

Each participant may publish a public encryption key, for example, a PGP public key or any chosen asymmetric scheme. Senders can then encrypt message payloads before calling `sendMessage`. This ensures only the intended recipient, who holds the matching private key, can decrypt the contents. The storage and retrieval of these keys is outside the minimal interface of this specification, but implementers should provide a method to set and get a public key for interoperability.

## Vulnerabilty

The payoff to allow for a 24/7 mail service where user rather than sell there data or pay server upkeep fees is that all messages are public so that if an encryption key is present then this would jepredize all messages, a way one could offset this would be to cycle the key so that in an event off a key being leaked that only a portion of data will be exposed.

## Example Implementaiton

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Mail
{
    address public owner;
    bytes public key;

    bytes[] private inbox;

    constructor(bytes memory _key)
    {
        owner = msg.sender;
        key = _key;
    }

    function sendMessage(bytes calldata message) external
    {
        inbox.push(message);
    }

    // View a message by index
    function getMail(uint index) external view returns (bytes memory)
    {
        require(index < inbox.length, "No mail at index");
        return inbox[index];
    }

    // Get total number of messages
    function getInboxCount() external view returns (uint)
    {
        return inbox.length;
    }

    // Owner-only: clear entire inbox
    function clearInbox() external onlyOwner
    {
        delete inbox;
    }

    function updatesKey(bytes calldata _key) external onlyOwner
    {
        key = _key;
    }

    modifier onlyOwner()
    {
        require(msg.sender == owner, "Only owner");
        _;
    }
}

```
