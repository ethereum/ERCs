---
title: Decentralized Mail Protocol
description: A standardized interface for secure, interoperable messaging between Ethereum addresses.
author: Robert Mapes (robertjmapes)
discussions-to: https://github.com/ethereum/EIPs/issues/2002
status: Draft
type: Standards Track
category: ERC
created: 2025-08-12
---

## Abstract

This proposal defines a decentralized messaging protocol that allows Ethereum addresses to send and receive encrypted messages securely and interoperably. It enables both users and smart contracts to exchange verifiable, privacy-preserving messages on-chain or off-chain without relying on centralized servers. The protocol includes a minimal interface for storing and retrieving encrypted messages and supports public key usage for encryption.

## Motivation

Messaging between Ethereum users and smart contracts currently suffers from fragmentation and dependency on centralized services. Existing solutions either require trusting third-party servers, risking privacy and censorship, or lack interoperability across different wallets and dApps. This lack of a unified messaging standard creates usability barriers and slows adoption of decentralized communication. A standardized, decentralized messaging protocol tied directly to Ethereum addresses would enable secure, private, and trustless communication without intermediaries, fostering a more robust ecosystem.

## Specification

Here’s a thorough **Specification** section draft for your decentralized mail EIP, following the RFC keywords guidance and focusing on a minimal interface and expected behavior:

## Specification

This specification defines a minimal interface for decentralized messaging between Ethereum addresses. Implementations **MUST** provide the following features:

* A method `sendMessage(bytes calldata message)` allowing any address to submit an encrypted message to the recipient’s inbox.
* A method `getMail(uint index) external view returns (bytes memory)` allowing retrieval of a message by index.
* A method `getInboxCount() external view returns (uint)` to obtain the total number of messages stored.
* Optional administrative functions for the mailbox owner to manage keys and message storage.

### Message Format

* Messages **MUST** be opaque bytes. The protocol **SHOULD** support encryption by the sender using the recipient’s public key, but encryption is not enforced by the interface.
* Metadata such as sender address or timestamp **MAY** be included inside the encrypted payload but are not part of the interface.

### Public Key Management

* The protocol **DOES NOT** specify on-chain storage or retrieval mechanisms for public encryption keys.
* Implementations **SHOULD** provide mechanisms for users to publish and update their public keys off-chain or on-chain for interoperability.

### Security Properties

* Senders **MUST** encrypt messages when privacy is required.
* Recipients **SHOULD** rotate encryption keys periodically to mitigate key compromise risks.

### Error Handling

* `getMail` **MUST** revert if the requested index is out of bounds.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

## Rationale

This protocol was designed to address the lack of a unified, decentralized messaging standard for Ethereum. Existing messaging solutions either rely heavily on centralized infrastructure—introducing risks of censorship, privacy breaches, and service outages—or use incompatible protocols that fragment the user experience. By defining a minimal, interoperable interface for sending and retrieving encrypted messages tied directly to Ethereum addresses, this EIP enables seamless communication between wallets, dApps, and smart contracts without trust in third parties.

Alternate approaches considered included off-chain encrypted messaging protocols and fully on-chain storage. Off-chain methods often rely on centralized nodes or complicated peer-to-peer discovery, limiting adoption and security guarantees. Fully on-chain messaging offers censorship resistance but is costly and limited in message size. This EIP strikes a balance by supporting encrypted messages stored on-chain with an open interface, allowing implementations to optimize storage and encryption methods while maintaining interoperability.

## Backwards Compatibility

No backward compatibility issues found.

## Reference Implementation

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Mail {
    address public owner;
    bytes public key;

    bytes[] private inbox;

    constructor(bytes memory _key) {
        owner = msg.sender;
        key = _key;
    }

    function sendMessage(bytes calldata message) external {
        inbox.push(message);
    }

    // View a message by index
    function getMail(uint index) external view returns (bytes memory) {
        require(index < inbox.length, "No mail at index");
        return inbox[index];
    }

    // Get total number of messages
    function getInboxCount() external view returns (uint) {
        return inbox.length;
    }

    // Owner-only: clear entire inbox
    function clearInbox() external onlyOwner {
        delete inbox;
    }

    // Owner-only: update encryption key
    function updateKey(bytes calldata _key) external onlyOwner {
        key = _key;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
}
```

## Security Considerations

Since all messages are stored on-chain or otherwise publicly accessible, encryption is critical to preserve privacy. If a participant’s private key is compromised, all messages encrypted with the corresponding public key become vulnerable. To mitigate this risk, key rotation should be encouraged so that exposure of a single key affects only a limited subset of messages. Additionally, the protocol itself does not enforce encryption or authentication, so implementations must carefully manage key distribution and message validation to prevent impersonation or spam. Finally, on-chain storage costs and scalability should be considered to avoid denial-of-service attacks through message flooding.

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
