---
eip: 7803
title: EIP-712 Extensions for Account Abstraction
description: Improvements for EIP-712 to support smart contract accounts.
author: Francisco Giordano (@frangio), Ernesto Garc√≠a (@ernestognw)
discussions-to: https://ethereum-magicians.org/t/erc-7803-eip-712-extensions-for-account-abstraction/21436
status: Draft
type: Standards Track
category: ERC
created: 2024-10-08
requires: 712
---

## Abstract

This ERC improves on [EIP-712] signatures to better support smart contract accounts by 1) introducing signing domains as a way to prevent replay attacks when private keys are shared across accounts, and 2) allowing dapps and wallets to coordinate on the method that will be used to authenticate the signature.

[EIP-712]: ./eip-712.md
[EIP-191]: ./eip-191.md

## Motivation

### Signing Domains

Standards like [ERC-1271], [ERC-7913], and [ERC-6492] give smart contract accounts (SCAs) the ability to produce signatures that an application can authenticate without knowledge of the abstract rules of the account. This is an important primitive for applications, as the account owner is able to authorize a third-party to act on its behalf without interacting with the chain.

[ERC-1271]: ./eip-1271.md
[ERC-6492]: ./eip-6492.md
[ERC-7913]: ./eip-7913.md

Smart contract accounts may be "owned" by cryptographic keys whose signatures are used to authorize the use of the account. There is not necessarily a one-to-one mapping between keys and accounts, because a single key may control multiple accounts, so care must be taken to prevent replay attacks across them. This is done by binding a signature to a particular account.

EIP-712 introduced a scheme where signatures can be bound to a verifying domain, which corresponds to the protocol contract that will authenticate a signature. Reusing this mechanism to additionally bind a signature to the domain of the smart contract account runs into a large amount of complexity and attack surface (see [ERC-7739]), as well as yet unresolved issues with account composability (SCAs that control other SCAs). This ERC introduces _signing domains_ in addition to verifying domains to natively enable wallets to generate smart contract account signatures with replay protection.

[ERC-7739]: ./eip-7739.md

### Authentication Methods

[ERC-1271] is a minimal and very general interface that has been very effective. It requires the contract code to be already deployed by the time the signature needs to be authenticated, so [ERC-6492] extends [ERC-1271] to support that use case. [ERC-7913] further extends this by introducing signature verifiers that can handle non-ethereum cryptographic keys without requiring deployment of individual identity contracts. In the future additional methods may need to be developed.

Support for these methods across protocols is currently lacking and is a major pain point for the Account Abstraction roadmap. Where [ERC-1271] is supported, it is not necessarily used uniformly, in particular some contracts attempt `ECRECOVER` prior to invoking `isValidSignature` while others do the opposite, which will result in very different semantics post [EIP-7702]. Additionally, the introduction of [ERC-7913] verifiers adds another layer of complexity in determining the appropriate verification method.

[EIP-7702]: ./eip-7702.md

This ERC addresses this by allowing dapps to communicate the types of signatures a protocol's contracts support, i.e., which authentication methods will be used, and in what order.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Requests for typed data signatures via JSON-RPC (`eth_signTypedData`) or client libraries are extended with the following optional properties:

- `signingDomains`
- `authMethods`

These new properties are used alongside the existing ones, i.e., `types`, `primaryType`, `domain`, and `message`.

The signature returned in response to the request MAY be of any size, and in the absence of `authMethods` it MUST be treated opaquely as the type of the signature is not known.

### `signingDomains`

This property is an array of smart contract account domains. Each member of the array is an object with the following keys:

- `types`: An object with the same format as EIP-712 `types` with at least an `EIP712Domain` key.
- `domain`: An object that is valid with respect to the type `EIP712Domain` described in `types`.

From right to left the array lists the chain of accounts through which the signer ultimately has control over the "outermost" signing domain (i.e., that listed first).

For example:

1. A dapp requests an EIP-712 signature to a connected account via JSON-RPC. `signingDomains` is empty or undefined.
2. The connected account is a multisig, so it requests EIP-712 signatures from its signers, prepending the domain of the multisig to `signingDomains`, which is now an array of length 1.
3. One of the signers uses a smart contract account controlled by an ECDSA key held in a hardware wallet, so their wallet requests an EIP-712 signature from the hardware wallet, prepending the domain of the smart contract account to `signingDomains`, which is now an array of length 2.
4. The signer verifies the contents of the signature in their hardware wallet. They are able to see that they are signing a message intended for a particular dapp domain, on behalf of their smart contract account (closest signing domain), as a member of the multisig (furthest signing domain).

#### Encoding of data to be signed

In the presence of `signingDomains` the account should encode the message to be signed according to the following recursive procedure:

- `encodeForSigningDomains(signingDomainSeparators : [ùîπ¬≤‚Åµ‚Å∂], verifyingDomainSeparator : ùîπ¬≤‚Åµ‚Å∂, message : ùïä) =`
  - If `signingDomainSeparators = [first, ...others]`: `"\x19\x02" ‚Äñ first ‚Äñ encodeForSigningDomains(others, verifyingDomainSeparator, message)`
  - If `signingDomainSeparators = []`: `encode(domainSeparator, message)`, where `encode` is defined by EIP-712.

`signingDomainSeparators` is the array of hashes of the domains included in `signingDomains`, in the same order, computed according to EIP-712's `hashStruct`.

#### Encoding of signatures for onchain validation

To accommodate existing onchain signature validation functions like [ERC-1271]'s `isValidSignature`, it is possible to use `signature` argument (or equivalent) to ABI encode the signature and its metadata. The following format is RECOMMENDED for completeness:

```solidity
abi.encodePacked(
    uint16 signatureLength,              // Length of the actual signature
    bytes signature,                     // The actual cryptographic signature
    abi.encode(bytes32[] signingDomainSeparators)  // Signing domain separators (outermost first)
)
```

### `authMethods`

This property is an array of supported signature authentication methods, listed in the order that the verifying domain tries them.

Each member of the array is an object with the following keys:

- `id`: An string that identifies the method. It may be one of:
  - `ECDSA`: ECDSA signatures by Externally Owned Accounts.
  - `ERC-{n}`: A standard type of signature specified by an ERC. `n` must not be padded with zeros.
- `parameters` (optional): An array of method-specific parameters.

### JSON Schema

```javascript
{
  type: 'object',
  properties: {
    types: {$ref: '#/$defs/EIP712Types'},
    primaryType: {type: 'string'},
    domain: {type: 'object'},
    message: {type: 'object'},
    signingDomains: {
      type: 'array',
      items: {$ref: '#/$defs/EIP712Types'}
    }
    authMethods: {
      type: 'array',
      items: {
        type: 'object',
        id: {type: 'string'},
        parameters: {type: 'array'},
        required: ['id'],
      },
    }
  },
  required: ['types', 'primaryType', 'domain', 'message'],
  $defs: {
    EIP712Types: {
      type: 'object',
      properties: {
        EIP712Domain: {type: 'array'},
      },
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: {type: 'string'},
            type: {type: 'string'}
          },
          required: ['name', 'type']
        }
      },
      required: ['EIP712Domain']
    }
  }
}
```

## Rationale

Maintaining human-readable domain information throughout the entire stack is essential for user security. Users need clear context about both the content and authorization chain they're participating in, requiring consistent domain representation from the initial `eth_signTypedData` request through wallet interfaces to contract verification.

This transparency helps users make informed decisions and prevents phishing attacks, while ensuring they understand how their signatures will be used. The complexity of signing operations underscores the need for a robust and flexible domain representation system that maintains security and usability.

### Prefix Choice

The prefix `\x19\x02` was chosen to differentiate from [EIP-712]'s `\x19\x01` while maintaining compatibility with [EIP-191]'s prefix scheme. This ensures that signatures generated with this extension can be distinguished from standard [EIP-712] signatures while still following the established security practices.

### Recursive Encoding

The recursive encoding scheme was designed to maintain the hierarchical nature of account relationships while supporting unlimited nesting depth. This approach provides better wallet UX by preserving the context of each signing domain in the chain, making it clearer to users what they are signing for and on behalf of whom.

The recommended `signature` encoding format enables efficient onchain validation by packing the signature length and data at the start for easy calldata decoding. The signing domain separators array follows and requires more complex decoding, this can be done in memory for type safety or in calldata for gas efficiency.

### Array Ordering

The array ordering convention (outermost to innermost) was chosen to match the natural flow of authorization, where the outermost domain represents the final destination of the signature. This ordering enables wallets to display the signing context in a logical and intuitive way, helping users understand the full chain of authorization they are participating in.

### Graceful Degradation

When using `signingDomains`, both wallets and applications must support this standard since it uses a different encoding than standard [EIP-712]. Applications can achieve graceful degradation by detecting wallet capabilities before including `signingDomains` and falling back to standard [EIP-712] when the wallet doesn't support this extension.

## Backwards Compatibility

This specification maintains backwards compatibility with existing [EIP-712] implementations across the Ethereum ecosystem, with wallets being able to identify signatures encoded through the `\x19\x02` prefix while standard [EIP-712] signatures using `\x19\x01` continue to function normally.

Smart accounts using [ERC-7739] can upgrade or add support for this authentication method, with the [`authMethods`](#authmethods) field covering the corresponding ERC's verification behavior. Existing contracts using [ERC-1271], [ERC-6492], or [ERC-7913] require no modifications, and all [EIP-712] libraries, development tools, and frameworks continue to work without changes to their current interfaces.

### JSON-RPC

The new fields [`signingDomains`](#signingdomains) and [`authMethods`](#authmethods) are optional extensions to the `eth_signTypedData` method, where requests without these fields behave identically to standard [EIP-712] requests, ensuring existing applications continue to work without modification while allowing RPC providers to implement support incrementally.

### Wallet UIs

Wallets that don't support this specification will produce incompatible signatures when `signingDomains` is present, as they'll use standard [EIP-712] encoding (`\x19\x01` prefix) instead of the encoding of this specification (`\x19\x02` prefix).

Applications using `signingDomains` can only work with wallets that support this specification and should implement capability detection with fallback mechanisms and new rendering logic to properly handle the new fields (i.e., `signingDomains` and `authMethods`).

## Security Considerations

Needs discussion. <!-- TODO -->

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
