---
eip: 7656
title: Generalized Contract-Linked Services
description: Define a registry for generic services linked to a specific contract, with or without ID
author: Francesco Sullo (@sullof)
discussions-to: https://ethereum-magicians.org/t/variation-to-erc6551-to-deploy-any-kind-of-contract-linked-to-an-nft/19223
status: Review
type: Standards Track
category: ERC
created: 2024-03-15
requires: 165, 1167, 5313
---

## Abstract

This proposal defines a registry for generic services linked to specific contracts. The standard supports both NFT-linked services (with an 'id', in this case a `tokenId`) and generalized contract-linked services (without an `id`, like [ERC-4337](./eip-4337.md) accounts).

## Motivation

Existing proposals (like the one by TokenBound, numbered as 6551, not directly linkable here because not finalized yet) aim to bind smart accounts to NFTs, allowing their registries to deploy accounts owned by specific token IDs. The issue we attempt to address with this new proposal is that these proposals often explicitly require any contract deployed via their registries to implement specific interfaces to handle assets and execute transactions, effectively mandating that the deployed contract must be an account. Also, those proposals do not support the deployment of contracts linked to a contract without an ID.  

Since one of this proposal's goals is flexibility, there is no expectation for an `ERC7656Registry` contract to be deployed as a singleton, allowing any project to adjust it to their needs; consequently, we require that any registry explicitly supports the `IERC7656Registry` interface.
For example, a registry may add more data to the proxy for specific purposes. 

The expansion of the registry's capabilities to manage contracts implementing any kind of service beyond accounts provides several advantages:

- **Flexibility**: Developers can allow NFTs or contracts to interact with a broader range of linked contracts, unlocking new use cases and functionalities (lending systems, vested asset distribution, fractional ownership, identity, etc.)
- **Compatibility**: By ensuring that account-like contracts can still be identified as such, the proposal maintains backward compatibility with existing account-based proposals.
- **Innovation**: This proposal encourages further innovation in the NFT and contract space by removing limitations on the types of contracts that can be associated with NFTs or contracts, opening the door to pure-utility NFTs and generalized contract extensions.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Registry Interface

The interface `IERC7656Registry` is defined as follows:

```solidity
interface IERC7656Registry {
  /**
   * @notice The registry MUST emit the Created event upon successful contract creation.
   * @param contractAddress The address of the created contract
   * @param implementation The address of the implementation contract
   * @param salt The salt to use for the create2 operation
   * @param chainId The chain id of the chain where the contract is being created
   * @param linkedContract The address of the token or contract
   * @param mode If true, the id is not used, saving 32 bytes in the bytecode
   * @param id The optional ID (e.g., tokenId) of the linked contract, or 0 if not applicable
   */
  event Created(
    address contractAddress,
    address indexed implementation,
    bytes32 salt,
    uint256 chainId,
    address indexed linkedContract,
    bool mode,
    uint256 indexed id
  );

  /**
   * The registry MUST revert with CreationFailed error if the create2 operation fails.
   */
  error CreationFailed();

  /**
   * @notice Creates a token or contract-linked service.
   * If the service has already been created, returns the service address without calling create2.
   * @param implementation The address of the implementation contract
   * @param salt The salt to use for the create2 operation
   * @param chainId The chain id of the chain where the service is being created
   * @param linkedContract The address of the token or contract
   * @param mode If true, the id is not used, saving 32 bytes in the bytecode
   * @param id The optional ID (e.g., tokenId) of the linked contract. If mode is true, this value is ignored
   * Emits Created event.
   * @return service The address of the token or contract-linked service
   */
  function create(
    address implementation,
    bytes32 salt,
    uint256 chainId,
    address linkedContract,
    bytes1 mode,
    uint256 id
  ) external returns (address service);

  /**
   * @notice Returns the computed token or contract-linked service address.
   * @param implementation The address of the implementation contract
   * @param salt The salt to use for the create2 operation
   * @param chainId The chain id of the chain where the service is being created
   * @param linkedContract The address of the token or contract
   * @param id The optional ID (e.g., tokenId) of the linked contract. If mode is true, this value is ignored
   * @param mode Needed to get the correct deployed bytecode, needed to compute the address
   * @return service The address of the token or contract-linked service
   */
  function compute(
    address implementation,
    bytes32 salt,
    uint256 chainId,
    address linkedContract,
    bytes1 mode,
    uint256 id
  ) external view returns (address service);
}
```

Any `ERC7656Registry` implementation MUST support [ERC-165](./eip-165.md) and the `IERC7656Registry`'s interface ID.

### Deployment Requirements

The registry MUST deploy each token or contract-linked service as an [ERC-1167](./eip-1167.md) minimal proxy with immutable constant data appended to the bytecode, like existing token-bound account proposals.

The deployed bytecode of each token or contract-linked service MUST have the following structure:
```
ERC-1167 Header               (10 bytes)
<implementation (address)>    (20 bytes)
ERC-1167 Footer               (15 bytes)
<salt (bytes32)>              (32 bytes)
<chainId (uint256)>           (32 bytes)
<mode (bytes1)>               (1 byte)
<reserved(bytes11)>           (11 empty bytes)
<linkedContract (address)>    (20 bytes)
<id (uint256)>                (32 bytes, optional)
```

- `mode` specifies if the linkedContract has an `id`, i.e., it is an NFT, or it has not, i.e., is, for example, a smart wallet. To keep compatibility with proposal built for NFTs, it MUST accept on of the the two following values: `HAS_ID`, equal to `0x00`, and `NO_ID`, equal to `0x01`. In a future extension, `mode` may assume other values to allow for more complex scenarios.
 
- The `reserved` 11 bytes are left empty to mantain a clear memory layout and to allow for future extensions.

- The `id` field (e.g., `tokenId`) is optional. If `mode` == `0x01`, it is omitted. In this case, the last 32 bytes of the proxy's bytecode MUST be left empty to reduce the bytecode size and save gas, and allow correct computations.

### Recommended Service Interface

Any contract created using a `ERC7656Registry` SHOULD implement the `IERC7656Service` interface:

```solidity
// InterfaceId 0xfc0c546a
interface IERC7656Service {
  /**
  * @notice Returns the contract and optional ID linked to the service.
  * @return chainId The chainId of the contract.
  * @return linkedContract The address of the token or contract.
  * @return id The optional ID (e.g., tokenId) of the linked contract, or 0 if not applicable.
  */
  function linkedContract() external view returns (uint256 chainId, address linkedContract, uint256 id);
}
```

The `mode` parameter is not included here because we assume that service are single-mode, i.e., they knows if the linked contract is expected to have an ID or not. However, if the service is multi-mode, the implementer MAY add more functions to the service to handle the different cases.

## Rationale

The technical foundation of [ERC-7656](./eip-7656.md) centers on the extension and generalization of contract types that can be associated with NFTs or other contracts. This approach was chosen to address specific limitations and opportunities identified in the design and application of NFT-linked contracts. Key technical decisions in this proposal include:

- **Addressing ERC Proliferation and Contract Size Limitations**: The increasing number of ERC proposals extending the [ERC-721](./eip-721.md) standard has led to complexity and potential confusion within the developer community. Since smart contracts have size limitations, incorporating multiple extensions into a single contract can become impractical or even impossible. [ERC-7656](./eip-7656.md) offers a solution by enabling the deployment of services that extend standard [ERC-721](./eip-721.md) NFTs or other contracts without requiring modifications to the [ERC-721](./eip-721.md) standard itself. For example, instead of adding features to an NFT to associate real-world assets with it, developers can deploy specialized smart contracts owned by that NFT to add these features. This approach allows NFTs to seamlessly expand their capabilities while maintaining compliance with the existing [ERC-721](./eip-721.md) standard, promoting a more efficient and modular development process.

- **No Singleton Requirement for the Registry**: Unlike some previous proposals, [ERC-7656](./eip-7656.md) does not mandate that the registry be deployed as a singleton. This decision was influenced by the recognition that different projects may have unique requirements and constraints. By allowing for multiple instances of the registry, projects can customize and optimize the registry's deployment to fit their specific needs, enhancing the ecosystem's overall diversity and resilience. However, for convenience, a reference implementation of the registry will be deployed to `erc7656.eth` on the most used networks.

- **Explicit Support for the `IERC7656Registry` Interface**: Requiring that any registry explicitly supports the `IERC7656Registry` interface is a technical decision aimed at ensuring interoperability and recognition. This requirement facilitates the identification and interaction with compliant registries, promoting a more standardized and cohesive ecosystem.

- **Flexibility in Contract Association**: The proposal is designed to accommodate not just accounts, but any contract that can meaningfully be associated with an NFT or other contract. This decision stems from a technical evaluation of the evolving landscape of NFT and contract use cases, recognizing the need for a standard that can support a broader range of functionalities, from complex financial instruments to identity verification systems.

- **Backward Compatibility**: The proposal includes provisions for backward compatibility, particularly with account-like contracts from existing standards. This technical choice ensures that projects built on earlier standards can transition to or leverage the new standard without discarding existing infrastructure or investments.

These technical decisions collectively aim to broaden the scope and applicability of NFT-linked and contract-linked contracts, empower developers with more tools for innovation, and support a growing ecosystem of decentralized applications. By addressing both current limitations and future opportunities, [ERC-7656](./eip-7656.md) seeks to lay a flexible and robust foundation for the next generation of NFT and contract technologies.

## Reference Implementation

See [`ERC7656Registry.sol`](../assets/eip-7656/ERC7656Registry.sol) for an example implementation of `IERC7656Registry`.

An example of implementation of `IERC7656Service` in a service linked to an NFT is the following:

```solidity
contract LinkedService is IERC7656Service, EIP5313 {

  function linkedContract() public view virtual returns (uint256, address, uint256) {
    bytes memory footer = new bytes(0x60);
    assembly {
      extcodecopy(address(), add(footer, 0x20), 0x4d, 0x60)
    }
    return abi.decode(footer, (uint256, address, uint256));
  }

  function owner() public view virtual override returns (address) {
    (uint256 chainId, address linkedContract_, uint256 id_) = linkedContract();
    if (chainId != block.chainid) return address(0);
    if (id_ == 0) {
      return linkedContract_;
    } else {
      return IERC721(linkedContract_).ownerOf(id_);
    }
  }
}
```

## Security Considerations

### Ownership Cycles

If a token-linked service functions as a smart wallet, an ownership cycle can render all assets permanently inaccessible. For example, if an ERC-721 token is transferred to the same smart wallet that it owns, neither the token nor the wallet’s assets can be retrieved, because the wallet cannot transfer the token back.

Preventing more complex ownership cycles on-chain is difficult, as it would require searching an unbounded number of possible transfers. Consequently, this proposal does not address cycle prevention. Projects adopting this proposal SHOULD include their own safeguards against such scenarios.

### Fraud Prevention when linking accounts to NFTs

Token-linked services can take many forms—such as subscription services, smart wallets, or renting platforms—and a malicious seller could exploit this flexibility by altering or removing critical components just before finalizing a sale. For instance, the seller might transfer out assets from a wallet service, revoke access from a subscription, or break a rental agreement at the last moment, leaving the buyer with a compromised or worthless service.

Because this proposal accommodates a wide range of services, there is no one-size-fits-all fraud mitigation strategy. However, a common approach is to implement a lock mechanism that restricts changes for a certain period before the sale is completed, or until the buyer confirms the purchase. Such functionality MAY be included by service developers but is not mandated by this proposal.

### Malicious or Unverified Implementations
Since the registry cannot ensure that only the legitimate NFT owner can create services for a given token, there is a risk that malicious or unverified code could be used. Users and marketplaces SHOULD carefully review or audit any implementation before linking it to an NFT.

### Upgradeability and Governance Risks
If a token-linked service is upgradable, the current owner (or a compromised owner) could upgrade the contract to exfiltrate assets or change functionality unexpectedly. Projects SHOULD implement secure upgrade mechanisms that only permit trusted implementations.

### Reentrancy and Cross-Contract Interactions
Token-linked services (especially those that hold assets or interact with external protocols) may be vulnerable to reentrancy attacks or other cross-contract exploits. Implementers SHOULD follow standard security patterns and best practices.

### Denial of Service (DoS)
If a service is designed or implemented incorrectly, it may become impossible to execute certain calls or transfer ownership, resulting in a DoS scenario. Implementers SHOULD consider fail-safes or recovery methods to prevent indefinite lockouts.

### User Education and Phishing Risks
Even with secure smart contracts, end-users can still be tricked into interacting with fraudulent services. Clear user interfaces, warnings, and contract verifications (e.g., Etherscan or similar tools) SHOULD be encouraged to reduce phishing and social engineering risks.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
