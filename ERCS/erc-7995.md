---
eip: 7995
title: Encrypted Data
description: A standard for representing, validating, and operating on encrypted data in Ethereum smart contracts using typed handles, validation proofs, and decryption oracles.
author: Clément Danjou (@immortal-tofu), Ghazi Ben Armor (@GBAZama), Joseph-André Turk (@jatZama), Nicolas Pasquier (@npasquie)
discussions-to: https://ethereum-magicians.org/t/erc-7995-encrypted-data/25013
status: Draft
type: Standards Track
category: ERC
created: 2025-07-28
requires: 712
---

## Simple Summary

This EIP introduces a standardized framework for handling encrypted data in Ethereum smart
contracts. It defines a set of on-chain encrypted data types, as `bytes32` aliases, (e.g.,
`euint64`, `ebool`); along with their corresponding off-chain encrypted data types, also as
`bytes32` aliases, (e.g. `externalEuint64`, `externalEbool`) for securely integrating
encrypted data generated off-chain in smart contracts. It specifies an on-chain validation
interface for verifying encrypted inputs, and a decryption oracle mechanism to asynchronously
retrieve cleartexts via callback.

This standard enables developers to build privacy-preserving DApps with interoperable,
type-safe, and composable support for confidential data.

## Abstract

This EIP establishes a protocol for representing, validating, and decrypting encrypted data on
Ethereum. It introduces:

- A set of encrypted data types (`euint*`, `ebool`, etc.) for on-chain usage.
- `externalE*` data types for off-chain ciphertexts accompanied by cryptographic proofs.
- An on-chain representation of encrypted values as `bytes32` handles.
- A standardized layout for encrypted contract storage, ensuring consistent slot usage across different libraries and enabling seamless compatibility.
- An on-chain ACL contract that stores access permissions associated with all encrypted values.
- An on-chain contract that provides verification of the authenticity of external encrypted inputs and provides operations over encrypted data types, enabling confidential computation directly on encrypted values without the need for decryption.
- An on-chain decryption oracle interface for asynchronous decryption requests with standardized callback mechanisms.
- An on-chain contract responsible for managing and verifying the decryption received via the oracle.
- A JavaScript API for constructing encrypted inputs, performing user-side or delegated decryption using EIP-712 signatures, and supporting public decryption for non-confidential workflows.

By providing a consistent abstraction for encrypted data and a on-chain contracts, this
standard allows developers to perform confidential operations, such as private transfers,
sealed-bid auctions, and anonymous voting, while preserving composability and auditability
within the Ethereum ecosystem.

## Motivation

DApp developers often require on-chain operations over confidential data, such as:

- Hiding token balances and transfer values
- Securing votes in an election
- Concealing bids in auctions
- Obfuscating answers in quizzes

Without a standardized method for handling encrypted data, developers must implement ad hoc
solutions that hurt composability and interoperability.

This proposal ensures:

- A unified approach for encrypted data representation
- Compatibility between smart contracts and frontend tooling
- Support for confidential, asynchronous workflows through oracles

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in RFC 2119.

### Definitions

- Cleartext: Unencrypted data in a native Solidity type.
- Ciphertext: An encryption of the cleartext.
- Protocol contracts: A set of contracts that enable interaction with an offchain service, define access to handles, or initiate decryption requests.
- Handle: A `bytes32` on-chain or off-chain reference to a ciphertext, used in contracts and UIs to avoid storing large ciphertexts directly. The actual ciphertext **MAY** not be stored on-chain, for e.g. in the context of cross-chain messaging.
- Encrypted Data Type: A handle type alias used for an encrypted value.
- Decryption Oracle: A smart contract and off-chain service that handles asynchronous
  decryption and triggers a callback.
- Solidity Library: On-chain utility library that exposes encryption, decryption, operations
  and access control functions.

### Core Encrypted Data Types

The library **SHOULD** define aliases for encrypted data types:

```solidity
type eaddress is bytes32;
type ebool is bytes32;

type eint8 is bytes32;
...
type eint256 is bytes32;

type euint8 is bytes32;
...
type euint256 is bytes32;
```

### External Encrypted Input Types and Validation

In addition to the core encrypted data types, this standard **SHOULD** define **external encrypted data
types** to represent ciphertexts generated off-chain. These types are:

```solidity
type externalEbool is bytes32;
type externalEuint8 is bytes32;
type externalEuint16 is bytes32;
type externalEuint32 is bytes32;
type externalEuint64 is bytes32;
type externalEuint128 is bytes32;
type externalEuint256 is bytes32;
// ... and other types as needed
```

Each of these is an alias for `bytes32`, used to encode a reference to an externally generated
ciphertext.

#### Purpose of External Encrypted Types

These `externalE*` types are introduced to:

- Distinguish unverified off-chain generated ciphertexts from verified or computed on-chain
  ciphertexts
- Enable validation and type-safe usage in smart contracts
- Provide extensibility and composability in multi-chain or hybrid compute models

### Contracts

Protocol contracts **MUST** include at least these 4 contracts.

#### ACL (Access Control List)

The ACL Contract is a trusted host contract on the host chain responsible for managing access rights to encrypted data handles. It defines which addresses (users or contracts) can use, decrypt, or grant access to encrypted values.

#### Coprocessor

The Coprocessor contract is responsible for validating encrypted inputs and executing computations.

#### Decryption Oracle

The Decryption Oracle is an on-chain contract interface used by smart contracts to request decryption of encrypted values. This enables asynchronous, verifiable decryption results to be received on-chain.

#### KMS Verifier

This contract is responsible for managing and verifying the decryption received via the oracle. This ensures trustless decryption handling without the need to trust the oracle.

### Input Representation and Proof Verification

Values of type `externalE*` reference ciphertexts generated off-chain. To ensure their integrity
and origin, a proof **MUST** be provided along with the value when submitted to a smart contract.
This proof could be a signature, a zero-knowledge proof, or any other verification metadata
appropriate for the application.

The coprocessor contract **MUST** provide a function for validating these values:

```solidity
function verifyInput(
    bytes32 inputHandle,
    address userAddress,
    bytes memory inputProof
) public virtual returns (bytes32 result);
```

- input: A `bytes32` value cast to an appropriate `externalE*` type (e.g.,
  `externalEbool`, etc.).
- proof: Bundled verification metadata.
- returns: A validated encrypted value cast to its encrypted data type (e.g., euint32,
  ebool, etc.).

This function **MUST** verify the authenticity and correctness of the external value using the
supplied proof. The verification process **MUST** ensure that the encrypted value cannot be
reused in a different context. If the validation succeeds, the function **MUST** return a value of a
core encrypted data type, enabling safe usage within the contract. Otherwise, the transaction
**MUST** revert.

Note: The type of the input parameter and the return value **MUST** be aligned with
the expected data type (e.g., `externalEuint64` to euint64, `externalEbool` to
ebool, etc.).

This design allows smart contracts to securely accept and process encrypted inputs created
outside the chain while preserving type safety and auditability.

### Standardized Storage Layout

Implementations **MUST** adhere to a standardized storage layout for all encrypted-related
components. This ensures consistent slot usage across different libraries and guarantees
compatibility between contracts compiled with different backends.

Specifically:

- Storage slots **MUST** be deterministic and stable across implementations.
- Core contracts such as `DecryptionOracle`, `ACL`, or `Coprocessor` addresses **MUST**
  be stored at predefined slots or under a standardized namespacing convention:
  `keccak256(abi.encode(uint256(keccak256("confidential.storage.config")) - 1)) & ~bytes32(uint256(0xff))`

  - The on-chain contracts are stored with this struct:

  ```solidity
  struct CoprocessorConfig {
    address ACLAddress;
    address CoprocessorAddress;
    address DecryptionOracleAddress;
    address KMSVerifierAddress;
  }
  ```

- Any contract extending shared standards (e.g., ConfidentialToken) **MUST** rely on
  this layout to retrieve and store encrypted metadata and associated access control
  configurations.
- dApp contracts **SHOULD** expose a function to determine which protocol is used.

```solidity
function protocolId() external returns(uint256 protocolId);
```

This layout requirement ensures that protocols remain interoperable, even if the underlying
implementations differ.

### Operations on Encrypted Data

Smart contracts that integrate this standard **MAY** support homomorphic operations over
encrypted values without requiring prior decryption. These operations enable computation on
encrypted data directly, preserving confidentiality while allowing contracts to enforce logic.

The Coprocessor contract **SHOULD** expose functions for basic arithmetic and logical operations on
encrypted data types. These functions **MUST** operate on the encrypted data types defined in
this standard and return new encrypted values.

### Supported Operations

The following operations **MAY** be provided for compatible encrypted types:

#### Addition

```solidity
function add(bytes32 a, bytes32 b) external returns (euint
result);
```

#### Subtraction

```solidity
function sub(bytes32 a, bytes32 b) external returns (euint
result);
```

#### Multiplication

```solidity
function mul(bytes32 a, bytes32 b) external returns (euint
result);
```

#### Equality Comparison

```solidity
function eq(bytes32 a, bytes32 b) external returns (ebool
result);
```

#### Conditional Selection

```solidity
function select(bytes32 condition, bytes32 thenValue, bytes
elseValue) external returns (euint32 result);
```

Implementations **MAY** choose to extend this set with additional operations (e.g., modular
arithmetic, bitwise logic) supported by the underlying encryption scheme.

Type Safety and Interoperability

All operations **MUST** preserve type safety by accepting and returning specific encrypted data
types. Mixing types (e.g., euint32 with euint64) **MUST** be explicitly cast via well-defined
conversion functions if such behavior is desired. This avoids ambiguity and enforces
consistency across contracts and toolchains.

Constraints and Considerations

- Operations **MUST NOT** leak information about the encrypted operands or results.

- Operations **SHOULD** be implemented in a way that is compatible with circuit-based or
  homomorphic evaluation strategies.

- Implementers **MAY** introduce operation limits (e.g., maximum supported depth or
  operand size) depending on performance or cryptographic constraints.

This module allows developers to perform meaningful computation on private data while
maintaining the composability and auditability guarantees of Ethereum smart contracts.

### On-Chain ACL for Handle-Based Permissions

The ACL contract **MAY** provide functions to allow a `bytes32` value for a given address, and to check
whether such a value is allowed.

```solidity
function allow(bytes32 handle, address entity) external;
function isAllowed(bytes32 handle, address entity) external view
returns (bool);
```

- allow: Grants access for a given address to a specific handle.
- isAllowed: Returns true if the address has access to the given handle.

The ACL **MAY** include account delegation:

```solidity
function delegateAccount(address delegatee, address[] memory contractAddresses, uint expiration) external;
function revokeDelegation(address delegatee, address[] memory contractAddresses) external;
function allowedOnBehalf(address delegatee,bytes32 handle,address contractAddress,address account) external view returns (bool);
```

- delegateAccount: Grants delegation rights to delegatee, allowing them to act on
  behalf of the sender for the specified contract addresses with an expiration date (timestamp). This delegation **MAY** apply to all handles associated with the sender within those contracts.
- revokeDelegation: Revokes previously granted delegation rights from delegatee
  for the specified contract addresses.
- allowedOnBehalf: Returns true if delegatee is authorized to act on behalf of
  account for the given handle and contract address; otherwise returns false.

Smart contracts can integrate this module to perform permission checks before granting access
to sensitive operations.

### Decryption Oracle Interface

The Decryption Oracle contract **MAY** provide a function to request decryption, with the result delivered via a callback.

```solidity
function requestDecryption(
uint256 requestID,
bytes32[] calldata handles,
bytes4 callbackSelector
) external;
```

- requestID: Unique identifier generated by the caller.
- handles: Encrypted inputs (`bytes32`) to be decrypted.
- callbackSelector: Selector of the callback function.

This function **MAY** be payable to allow passing a msg.value.

### Callback Interface

Contracts initiating decryption **MAY** implement a callback function with the following signature
pattern:

```solidity
function callbackExample(
  uint256 requestID,
  bytes memory cleartexts,
  bytes memory decryptionProof
) external;
```

- First parameter is the requestID.
- Followed by ABI encoded decrypted values in the same order as handles.
- Final parameter is an array of metadata (e.g., ZK proofs or signatures).

The callback function **SHOULD** verify the decrypted result by checking the proof by calling
verifyDecryptionSignatures implemented on KMSVerifier contract.

```solidity
function verifyDecryption(
  bytes32[] memory handlesList,
  bytes memory cleartexts,
  bytes memory decryptionProof
) external returns (bool);
```

### JavaScript API

To support encrypted data workflows in frontend applications, a reference JavaScript library
provides a standardized interface for constructing encrypted inputs, validating decryption
access, and sending decryption requests—either directly or via delegation, based on
cryptographic proofs using EIP-712.

### Encrypted Input Creation

```javascript
const input = instance.createInputBuilder({
  contractAddress: '0xYourContractAddress',
  userAddress: '0xUserAddress',
});
input.pushEuint8(33).pushEbool(true);
const { handles, proof } = input.encrypt();
```

```typescript
createInputBuilder(metadata: Record<string, any>): { handles: Uint8Array[],
inputProof: Uint8Array }
```

- Initializes a new encrypted input context.
- Accepts arbitrary metadata (e.g., contract address, user address, session data, etc.).
- Returns a builder that allows the developer to append encrypted fields and call
  .encrypt() to finalize.
  ○ .pushEuint8(value: number): Input, .pushEbool(value:
  boolean): Input, ...: Appends values to the encrypted input. Returns the
  input.
  ○ encrypt(): Promise<{ handles: Uint8Array[], inputProof:
  Uint8Array }>: Finalizes encryption of the appended inputs. Returns
  encrypted `externalE*` handles ready for submission to smart contracts or
  validation routines.

### User Decryption

To decrypt encrypted data client-side, the user must sign a **decryption authorization** using
EIP-712. The userDecrypt method accepts encrypted handles, a key pair, and the signed
proof to perform decryption locally.

```javascript
const decryptedValues = await instance.userDecrypt(
  handleContractPairs, // Array of HandleContractPair
  privateKey, // User’s decryption key (e.g., libsodium)
  publicKey, // User’s encryption key (must match EIP-712)
  signature, // Signature over EIP-712 message
  contractAddresses, // Contracts the user is authorizing
  userAddress, // Ethereum address of the user
  startTimestamp, // Start time for access
  durationDays // Duration (in days) the access is valid
);
```

```typescript
userDecrypt(
handleContractPairs: HandleContractPair[],
privateKey: string,
publicKey: string,
signature: string,
contractAddresses: string[],
userAddress: string,
startTimestamp: string | number,
durationDays: string | number,
delegatorAddress?: string
): Promise<any[]>
```

- handleContractPairs: Array of `{ handle: string; contractAddress: string }`
  referencing encrypted inputs.
- privateKey: The secret key used to decrypt (e.g., libsodium format).
- publicKey: Corresponding public key, included in the signed message.
- signature: EIP-712 signature proving that the public key is authorized by the user.
- contractAddresses: Contracts for which the user grants decryption rights.
- userAddress: Ethereum address of the authorizing user.
- startTimestamp: When the decryption access begins.
- durationDays: Number of days access is valid from startTimestamp.
- delegatorAddress: Address of the user on whose behalf the decryption is being
  performed (optional).

### EIP-712 Message Format (Standard Decryption)

```json
{
  "types": {
    "EIP712Domain": [
      { "name": "name", "type": "string" },
      { "name": "version", "type": "string" },
      { "name": "chainId", "type": "uint256" },
      { "name": "verifyingContract", "type": "address" }
    ],
    "UserDecryptRequestVerification": [
      { "name": "publicKey", "type": "bytes" },
      { "name": "contractAddresses", "type": "address[]" },
      { "name": "contractsChainId", "type": "uint256" },
      { "name": "startTimestamp", "type": "uint256" },
      { "name": "durationDays", "type": "uint256" }
    ]
  },
  "primaryType": "UserDecryptRequestVerification",
  "domain": {
    "name": "Decryption",
    "version": "1",
    "chainId": 1,
    "verifyingContract": "0x1C5630F86A1Aa6fE1F7C625f52A2503DfAaC7922"
  },
  "message": {
    "publicKey": "0xd75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a",
    "contractAddresses": ["0xCb28e13094714cE75Af8D8A3fD81bDdFb8B03fA1", "0x4De6A93aBC8C90D35eB18477f9C2cF029Aa4Eaa2"],
    "contractsChainId": 1,
    "startTimestamp": 1753775700000,
    "durationDays": 365
  }
}
```

### EIP-712 Message Format (Delegated Decryption)

```json
{
  "types": {
    "EIP712Domain": [
      { "name": "name", "type": "string" },
      { "name": "version", "type": "string" },
      { "name": "chainId", "type": "uint256" },
      { "name": "verifyingContract", "type": "address" }
    ],
    "DelegatedUserDecryptRequestVerification": [
      { "name": "publicKey", "type": "bytes" },
      { "name": "contractAddresses", "type": "address[]" },
      { "name": "delegatorAddress", "type": "address" },
      { "name": "contractsChainId", "type": "uint256" },
      { "name": "startTimestamp", "type": "uint256" },
      { "name": "durationDays", "type": "uint256" }
    ]
  },
  "primaryType": "DelegatedUserDecryptRequestVerification",
  "domain": {
    "name": "Decryption",
    "version": "1",
    "chainId": 1,
    "verifyingContract": "0x1C5630F86A1Aa6fE1F7C625f52A2503DfAaC7922"
  },
  "message": {
    "publicKey": "0xd75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a",
    "contractAddresses": [
      "0xA4c3D920f7e1B93C46E6e9E1D3C15F9B2f1E0c9a",
      "0x9F1D7a56AeC0eD3F3c92b8E9e42D8bC45Ea8F2B4",
      "0xB89aE101cF0073e03f2B1D1248F7b63F6C1A003e",
      "0x6eD9350b7BcC3FeF46B9AD1f45E212A1a2Ae15F0"
    ],
    "delegatorAddress": "0x71721075e4Cc9389aA46b10d705A98fEFdCd3A4C",
    "contractsChainId": 1,
    "startTimestamp": 1753775700000,
    "durationDays": 365
  }
}
```

This format allows a user to delegate decryption rights to another agent (e.g., relayer, backend
service) while keeping full auditability and expiration control.

### Public Decryption

When confidentiality is not required, encrypted values can be decrypted without signature or
identity verification. This is useful in test environments, open-data scenarios, or where
user-specific access control is not enforced.

```javascript
const result = instance.publicDecrypt([encryptedData1, encryptedData2]);
```

```typescript
publicDecrypt(handles: (Uint8Array | string)[]): any[]
```

- handles: An array of encrypted data, each as a Uint8Array or base64/hex-encoded
  string.
- Returns: An array of decrypted cleartext values, in the same order as provided.

## Rationale

### Architecture

This standard defines a two layer architecture:

1. **Smart Contract Layer**: Operates on encrypted data via handles.
2. **Oracle Layer**: Handles decryption requests and callbacks.

### Design Decisions

- Use of Handles: Avoids storing large ciphertexts on-chain, separates contract logic from
  access control, and supports cross-chain references.
- Deterministic Input Verification: Ensures that encryption proofs are verifiable.

## Technology Choices

### Encryption Scheme

- **MUST** use a standardized encryption scheme
- **MAY** support arithmetic operations including addition and conditional logic (e.g.,
  FHE/TFHE).
- **SHOULD** support efficient re-encryption and key switching.

### Key Management

- **MUST** provide secure key generation and distribution.
- **SHOULD** support key rotation and recovery.
- **MUST** protect against key compromise.
- **MAY** distribute decryption key shares across a decentralized protocol.

## Security Considerations

- Input Verification: Prevent unauthorized reuse of ciphertexts without knowledge of
  cleartexts.
- Ciphertext Immutability: Prevent ciphertext tampering or replay.
- Proof Binding: Prevent attackers from reusing encrypted inputs in a different context.

## Reference Implementation

[fhevm](https://github.com/zama-ai/fhevm) Protocol using encrypted types, based on FHE
[encrypted-types](https://github.com/confidential-token-association/encrypted-types) Solidity encrypted types
[@zama-fhe/relayer-sdk](https://www.npmjs.com/package/@zama-fhe/relayer-sdk) JavaScript library

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
