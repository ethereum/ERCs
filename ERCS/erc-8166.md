---
eip: 8166
title: Shared Sequencer Interface for Agent L2s
description: A minimal, stateless interface for shared sequencer contracts optimized for autonomous agent compatibility.
author: Michael Winczuk (@michaelwinczuk)
discussions-to: https://ethereum-magicians.org/t/erc-8166-shared-sequencer-interface-for-agent-l2s/27772
status: Draft
type: Standards Track
category: ERC
created: 2026-02-19
---

## Abstract

This ERC defines a standard interface for shared sequencer contracts on Ethereum Layer 2 networks, with a specific focus on compatibility with autonomous agent systems. It provides a minimal, stateless, gas-predictable interface enabling agents and applications to interact with any compliant shared sequencer implementation without chain-specific integration work.

## Motivation

Shared sequencers (Espresso, Taiko's based sequencing, Puffer UniFi) represent one of the most promising vectors for tightly coupling L2 applications to Ethereum's security guarantees — but each project currently implements a proprietary interface. There is no standard.

This fragmentation creates real problems:

**For autonomous AI agents:** Agents operating on L2s need gas-predictable submission costs, explicit machine-readable error codes for automated retry logic, and stateless view functions for pre-flight checks. No current shared sequencer implementation is designed with autonomous agents as a primary user.

**For tooling developers:** Wallets, block explorers, monitoring infrastructure, and SDKs must write custom integrations for every sequencer.

**For the ecosystem:** The post-Astria vacuum (Astria shut down December 2025) and the EF's 2026 Protocol Priorities interoperability track create a direct opening for a clean, minimal interface standard.

This ERC proposes a minimal standard interface that:

1. Enables any autonomous agent to interact with any compliant shared sequencer
2. Provides gas-predictable submission with cost estimation
3. Returns explicit, machine-readable error codes
4. Exposes sequencer metadata for dynamic agent adaptation
5. Defines slashing event signatures for decentralized sequencer accountability

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Interface
```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity >=0.8.19 <0.9.0;

interface ISharedSequencer {

    struct ConfirmationReceipt {
        uint64 timestamp;
        bytes32 l1TxHash;
        bytes32 l2TxHash;
        uint8 status;
        string errorReason;
    }

    struct SequencerMetadata {
        string version;
        address[] supportedL2s;
        uint256 minConfirmationTime;
        uint256 maxTxSize;
    }

    event TransactionSubmitted(address indexed sender, bytes32 indexed transactionId, uint256 paidAmount);
    event TransactionConfirmed(bytes32 indexed transactionId, bytes32 l1TxHash, bytes32 l2TxHash);
    event TransactionFailed(bytes32 indexed transactionId, string errorReason);
    event SequencerSlashed(address indexed sequencer, uint256 slashAmount, string reason);

    function submitTransaction(bytes calldata transactionData) external payable returns (bytes32 transactionId);
    function getConfirmationReceipt(bytes32 transactionId) external view returns (ConfirmationReceipt memory receipt);
    function estimateSubmissionCost(bytes calldata transactionData) external view returns (uint256 totalCostWei);
    function getSequencerMetadata() external view returns (SequencerMetadata memory metadata);
}
```

## Rationale

**Why `string errorReason` in `ConfirmationReceipt`?**
The `errorReason` field is intentionally a `string` rather than a custom error type. Confirmation receipts are returned from `view` functions — there is no revert context to propagate typed errors. Human-readable strings allow agents to log and surface failure reasons. Implementations are RECOMMENDED to use custom errors in their revert paths for gas efficiency.

**Why a single `submitTransaction` rather than batching?**
Minimal surface area maximizes composability. Batching, scheduling, and multi-sequencer routing are higher-order concerns best handled by wrapper contracts. A batch-aware interface MAY be proposed as a companion ERC extending this one.

**Why `bytes calldata transactionData` in `estimateSubmissionCost`?**
Passing the actual calldata allows implementations to perform byte-level cost analysis. Callers that cannot provide full data MAY pass a zero-filled byte array of the expected length.

## Backwards Compatibility

No backward compatibility issues. This is a new interface standard with no modifications to existing contracts, protocols, or clients.

## Test Cases

The reference implementation includes a Foundry test suite with 14 tests covering unit, fuzz, invariant, gas profiling, and regression cases at approximately 97% coverage.

## Reference Implementation

The reference implementation includes:

- `src/MockSharedSequencer.sol` — a complete implementation featuring `mapping`-based receipt storage (O(1) lookup), fee-based spam protection, emergency pause, and dynamic cost estimation via `block.basefee`.
- `test/MockSharedSequencer.t.sol` — a Foundry test suite with 14 tests covering unit, fuzz, invariant, gas profiling, and regression cases.

## Security Considerations

**Reentrancy:** `submitTransaction` is payable. Implementations MUST use Checks-Effects-Interactions ordering or an equivalent reentrancy guard.

**Front-running:** Transaction submission ordering is at sequencer discretion. Agents MUST NOT rely on submission order for time-sensitive operations.

**Sequencer trust:** This standard does not enforce decentralization. The `SequencerSlashed` event is designed for decentralized implementations. Callers SHOULD call `getSequencerMetadata()` to verify the trust model before use.

**Fee volatility:** `estimateSubmissionCost()` MAY use `block.basefee` which fluctuates. Callers SHOULD apply a buffer (recommended: 20%) to all estimates.

**DoS via spam:** Permissionless deployments MUST implement fee or staking requirements. Without this, unbounded state growth is a griefing vector.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE).
