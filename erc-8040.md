---
eip: 8040
title: ESG Tokenization Protocol
description: ESG-compliant, AI-native asset tokenization with quantum auditability and lifecycle integrity.
author: Leandro Lemos (@agronetlabs) <leandro@agronet.io>
discussions-to: https://ethereum-magicians.org/t/erc-8040-esg-tokenization-protocol/25846
status: Draft
type: Standards Track
category: ERC
created: 2025-09-06
requires: 20, 721, 1155
---

## Abstract

This ERC defines an AI-native protocol for ESG-compliant asset tokenization, with quantum auditability, compliance-grade metadata, and lifecycle integrity.

## Specification

### Metadata Structure

Tokens MUST expose a metadata JSON with the following minimum fields:

```json
{
  "standard": "ERC-ESG/1.0",
  "category": "carbon",
  "geo": "BR-RS",
  "carbon_value": 12.5,
  "cycle": "2025-Q3",
  "digest": "sha3-512:...",
  "physical_id": "seal:XYZ123",
  "attestation": {
    "atf_digest": "sha3-512:...",
    "signer": "did:atf:ai:..."
  },
  "status": "issued|audited|retired",
  "evidence": "cid:Qm..."
}
```

### Smart Contract Interface

Contracts implementing this standard MUST support the following interface:

```solidity
pragma solidity ^0.8.0;

interface IERC8040 {
    /// @notice Metadata structure for ESG tokens
    /// @dev All digest fields use bytes to support SHA3-512 (64 bytes)
    struct Metadata {
        string standard;
        string category;
        string geo;
        uint256 carbon_value;
        string cycle;
        bytes digest;  // SHA3-512 digest (64 bytes)
        string physical_id;
        Attestation attestation;
        string status;
        string evidence;
    }
    
    /// @notice Attestation structure for AI-native validation
    /// @dev atf_digest uses bytes to support SHA3-512 (64 bytes)
    struct Attestation {
        bytes atf_digest;  // SHA3-512 attestation digest (64 bytes)
        string signer;
    }
    
    /// @notice Mints a new ESG token with provided metadata
    /// @param metadata The ESG metadata structure
    /// @return tokenId The ID of the newly minted token
    function mintESGToken(Metadata memory metadata) external returns (uint256 tokenId);
    
    /// @notice Audits an existing ESG token
    /// @param tokenId The token to audit
    /// @param auditDigest SHA3-512 digest of the audit report (64 bytes)
    function auditESGToken(uint256 tokenId, bytes memory auditDigest) external;
    
    /// @notice Retires an ESG token permanently
    /// @param tokenId The token to retire
    /// @param reason Human-readable retirement reason
    function retireESGToken(uint256 tokenId, string memory reason) external;
    
    /// @notice Returns the ESG metadata URI for a token
    /// @param tokenId The token ID
    /// @return The URI string pointing to off-chain metadata
    function esgURI(uint256 tokenId) external view returns (string memory);
    
    /// @notice Returns the complete on-chain metadata for a token
    /// @param tokenId The token ID
    /// @return The complete Metadata structure
    function getMetadata(uint256 tokenId) external view returns (Metadata memory);
    
    /// @notice Emitted when a new ESG token is minted
    /// @param tokenId The ID of the minted token
    /// @param category The ESG category (e.g., "carbon")
    /// @param geo Geographic identifier (e.g., "BR-RS")
    event Minted(uint256 indexed tokenId, string category, string geo);
    
    /// @notice Emitted when a token is attested by AI validator
    /// @param tokenId The ID of the attested token
    /// @param atfDigest SHA3-512 digest of the attestation (64 bytes)
    /// @param esgURI The URI of the ESG metadata
    event Attested(uint256 indexed tokenId, bytes atfDigest, string esgURI);
    
    /// @notice Emitted when a token is permanently retired
    /// @param tokenId The ID of the retired token
    /// @param timestamp The retirement timestamp
    /// @param reason Human-readable retirement reason
    event Retired(uint256 indexed tokenId, uint256 timestamp, string reason);
}
```

### JSON-RPC Example

```json
{
  "method": "eth_call",
  "params": [
    {
      "to": "0xContractAddress",
      "data": "0x..."
    }
  ],
  "example_metadata": {
    "category": "carbon",
    "geo": "BR-RS",
    "carbon_value": 12.5,
    "digest": "sha3-512:abc123def456...",
    "attestation": {
      "atf_digest": "sha3-512:xyz789...",
      "signer": "did:atf:ai:validator-001"
    }
  }
}
```

### Mapping & Compatibility

- [ERC-20](./eip-20.md): Each unit represents a standardized fraction (e.g., 1e18 = 1 tCO2e).
- [ERC-721](./eip-721.md): Single credit with unique esgURI and immutable metadata.
- [ERC-1155](./eip-1155.md): Homogeneous batch with common URI, metadata, and fungible amounts.

## Rationale

- **Deterministic flows**: Lifecycle follows strict state transitions (issued → audited → retired).
- **Immutable metadata**: SHA3-512 digest ensures tamper-proof records with 512-bit security.
- **Machine-verifiable audit trails**: ATF-AI validates compliance deterministically.
- **Post-quantum readiness**: SHA3-512 hash functions provide quantum-resistant cryptography.
- **Full hash storage**: Using `bytes` instead of `bytes32` allows complete SHA3-512 digest storage (64 bytes).

## Security Considerations

1. **Metadata immutability**: All metadata fields MUST be cryptographically sealed after minting.
2. **Zero-trust validation**: ATF-AI provides deterministic validation; all attestations are timestamped.
3. **Digest integrity**: SHA3-512 (64 bytes) ensures audit-trail integrity. Implementations MUST use `bytes` type to store complete 512-bit digests.
4. **Post-quantum cryptography**: Hash functions and signature schemes MUST be quantum-resistant. SHA3-512 provides 512-bit security suitable for post-quantum scenarios.
5. **Irreversible retirement**: Once retired, tokens cannot be reactivated.
6. **Physical seal validation**: On-chain digest MUST match physical seal cryptographic hash.
7. **Input validation**: All off-chain documents MUST be hashed using SHA3-512 and publicly referenced on-chain.
8. **Hash truncation prevention**: Implementations MUST NOT truncate SHA3-512 digests. The `bytes` type MUST be used instead of `bytes32` to prevent loss of cryptographic security.

## Copyright

Copyright and related rights waived via CC0-1.0.
