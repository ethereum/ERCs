// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use clap::{Arg, Command};
use methods::{METHOD_ELF, METHOD_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PaymentInstructionInput {
    // Public inputs (will be committed)
    pub root: [u8; 32],
    pub sender_hash: [u8; 32],
    pub recipient_hash: [u8; 32],
    pub min_amount_milli: u64,
    pub max_amount_milli: u64,
    pub currency_hash: [u8; 32],
    pub expiry: u64,

    // Private inputs (for proof generation only)
    pub sender_data: String,
    pub recipient_data: String,
    pub amount_value: u64,
    pub currency: String,
    pub expiry_date: String,

    // Merkle proof data
    pub sender_proof_siblings: Vec<[u8; 32]>,
    pub sender_proof_directions: Vec<u8>,
    pub recipient_proof_siblings: Vec<[u8; 32]>,
    pub recipient_proof_directions: Vec<u8>,
    pub amount_proof_siblings: Vec<[u8; 32]>,
    pub amount_proof_directions: Vec<u8>,
    pub currency_proof_siblings: Vec<[u8; 32]>,
    pub currency_proof_directions: Vec<u8>,
    pub expiry_proof_siblings: Vec<[u8; 32]>,
    pub expiry_proof_directions: Vec<u8>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct PaymentInstructionOutput {
    pub root: [u8; 32],
    pub sender_hash: [u8; 32],
    pub recipient_hash: [u8; 32],
    pub min_amount_milli: u64,
    pub max_amount_milli: u64,
    pub currency_hash: [u8; 32],
    pub expiry: u64,
}

#[derive(Serialize)]
pub struct ProofResult {
    pub proof: String,
    pub journal_hash: String,
    pub seal_hash: String,
    pub public: PublicOutputs,
}

#[derive(Serialize)]
pub struct PublicOutputs {
    pub root: String,
    pub from: String,
    pub to: String,
    pub amt: String,
    pub exp: u64,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let matches = Command::new("pain001-prover")
        .about("RISC Zero prover for payment instruction messages")
        .arg(
            Arg::new("input")
                .short('i')
                .long("input")
                .value_name("FILE")
                .help("Input JSON file with proof data")
                .required(true),
        )
        .arg(
            Arg::new("output")
                .short('o')
                .long("output")
                .value_name("FILE")
                .help("Output JSON file for proof result")
                .required(true),
        )
        .get_matches();

    let input_file = matches.get_one::<String>("input").unwrap();
    let output_file = matches.get_one::<String>("output").unwrap();

    // Read input data
    let input_data = fs::read_to_string(input_file)?;
    let input: PaymentInstructionInput = serde_json::from_str(&input_data)?;

    // Create executor environment and add input
    let env = ExecutorEnv::builder().write(&input)?.build()?;

    // Generate the proof
    let prover = default_prover();
    let prove_info = prover.prove(env, METHOD_ELF)?;
    let receipt = prove_info.receipt;

    // Verify the proof
    receipt.verify(METHOD_ID)?;

    // Extract the committed output
    let output: PaymentInstructionOutput = receipt.journal.decode()?;

    // Convert METHOD_ID to bytes for hex encoding
    let method_id_bytes: Vec<u8> = METHOD_ID.iter().flat_map(|&x| x.to_be_bytes()).collect();

    // Create a simple proof representation (since we can't access the seal directly)
    let proof_bytes = format!("{:?}", receipt.inner);

    // Create the result structure
    let result = ProofResult {
        proof: hex::encode(proof_bytes.as_bytes()),
        journal_hash: hex::encode(receipt.journal.bytes.clone()),
        seal_hash: hex::encode(proof_bytes.as_bytes()),
        public: PublicOutputs {
            root: format!("0x{}", hex::encode(output.root)),
            from: format!("0x{}", hex::encode(output.sender_hash)),
            to: format!("0x{}", hex::encode(output.recipient_hash)),
            amt: output.min_amount_milli.to_string(), // Using min_amount for simplicity
            exp: output.expiry,
        },
    };

    // Write the result
    let result_json = serde_json::to_string_pretty(&result)?;
    fs::write(output_file, result_json)?;

    println!("Proof generated successfully!");
    println!("Journal hash: 0x{}", hex::encode(&receipt.journal.bytes));
    println!("Method ID: 0x{}", hex::encode(&method_id_bytes));

    Ok(())
}
